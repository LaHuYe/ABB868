---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\main.c ----------------------------------------------------------------------
1:                /*-------------------------------------------
2:                /////////////////////////////////////////////////////////
3:                //  Project: B98-K3 / 4 modes
4:                //  Write by: yj
5:                //  Date:     2024-03-22
6:                //  Version:  V1
7:                //  CheckSum:
8:                //  MCU:      SC8P1711E/sop14
9:                ////////////////////////////////////////////////////////
10:               //
11:               -------------------------------------------*/
12:               
13:               #include <sc.h>
14:               #include "main.h"
15:               
16:               volatile bit Flag_250us;
17:               volatile bit Flag_1ms;
18:               volatile bit Flag_10ms;
19:               unsigned char Cnt250us = 0;
20:               unsigned int Cnt10ms = 0;
21:               unsigned int Cnt1ms = 0;
22:               unsigned char CntSleep;
23:               
24:               /////////////////////////////////////////// PortInit ///////////////////////////
25:               void PortInit()
26:               {
27:               	TRISA = 0b00000000; // input=1,output=0
  0723    0185    CLR	0x5
28:               	PORTA = 0b00000000;
  0724    1283    CLRB	0x3,5
  0725    0185    CLR	0x5
29:               	WPUA = 0b00000000; // FULL引脚，充电为低，满电为高阻态
  0726    0187    CLR	0x7
30:               	IOCA = 0b00000000;
  0727    0189    CLR	0x9
31:               
32:               	TRISB = 0b00010111; // input=1,output=0
  0728    3017    LDIA	0x17
  0729    1683    SETB	0x3,5
  072A    0086    LD	0x6,A
33:               	PORTB = 0b00000000;
  072B    1283    CLRB	0x3,5
  072C    0186    CLR	0x6
34:               	ANSELH = 0b00010000;
  072D    3010    LDIA	0x10
  072E    1683    SETB	0x3,5
  072F    0094    LD	0x14,A
35:               	WPUB = 0b00000111;
  0730    3007    LDIA	0x7
  0731    0095    LD	0x15,A
36:               	IOCB = 0b00000000; // wakeup,
  0732    0196    CLR	0x16
  0733    0008    RET
37:               }
38:               
39:               /////////////////////////////////////////// TimerConfig ///////////////////////////
40:               void Timer0Cofng()
41:               {
42:               	OPTION_REG = 0B00000000; // TMR0时钟 Fsys/4 4Mhz  预分频 /32  0.125Mhz 8us
  07BA    0181    CLR	0x1
43:               
44:               	// 50us
45:               	TMR0 = 165; // 215;//165;			//实测132为1ms
  07BB    30A5    LDIA	0xA5
  07BC    1283    CLRB	0x3,5
  07BD    0081    LD	0x1,A
46:               
47:               	T0IF = 0;
  07BE    110B    CLRB	0xB,2
48:               	T0IE = 1; // 使能Timer0溢出中断
  07BF    168B    SETB	0xB,5
  07C0    0008    RET
49:               }
50:               
51:               /////////////////////////////////////////// TimerConfig ///////////////////////////
52:               void Timer2Config()
53:               {
54:               	/////// timer2
55:               	// PR2 = 24;					//=125*4*16/8M=1mS
56:               	// TMR2IF = 0;
57:               	// TMR2IE = 1;					//=
58:               
59:               	// T2CON = 0X78;			//=
60:               	// TMR2ON=1;
61:               	/////// timer2
62:               	PR2 = 250; // 设定Timer初始值，定时周期是250us=250
  0786    30FA    LDIA	0xFA
  0787    1683    SETB	0x3,5
  0788    0092    LD	0x12,A
63:               	TMR2IF = 0;
  0789    1283    CLRB	0x3,5
  078A    108C    CLRB	0xC,1
64:               	TMR2IE = 1;			// 使能Timer2溢出中断
  078B    1683    SETB	0x3,5
  078C    148C    SETB	0xC,1
65:               	T2CON = 0B00011100; // 开启Timer2,设置TMR2的预分频比为1:1，后分频1:2
  078D    301C    LDIA	0x1C
  078E    1283    CLRB	0x3,5
  078F    0092    LD	0x12,A
  0790    0008    RET
66:               }
67:               
68:               /////////////////////////////////////////// AdcConfig ///////////////////////////
69:               void AdcConfig()
70:               {
71:               	ADCON0 = 0b00111101; // AN15
  07CE    303D    LDIA	0x3D
  07CF    1283    CLRB	0x3,5
  07D0    009F    LD	0x1F,A
72:               	ADCON1 = 0b00000000; // VDD
  07D1    1683    SETB	0x3,5
  07D2    019F    CLR	0x1F
  07D3    0008    RET
73:               }
74:               
75:               // /////////////////////////////////////////// PwmConfig ///////////////////////////
76:               void PwmConfig()
77:               {
78:               	PWMCON = 0B01100000; // PWM选择时钟源为Fosc/16   8M/800=10000,10000/64=156
  07C1    3060    LDIA	0x60
  07C2    1283    CLRB	0x3,5
  07C3    009B    LD	0x1B,A
79:               	PWMTH = 0B00000000;	 // 周期的时钟分频在PWMCON选择
  07C4    019A    CLR	0x1A
80:               	PWMTL = 99;			 // 10K
  07C5    3063    LDIA	0x63
  07C6    0099    LD	0x19,A
  07C7    0008    RET
81:               }
82:               
83:               // #define _XTAL_FREQ 8000000UL		//如果用16M晶振则改为16000000UL
84:               
85:               void main(void)
  0664    0000    NOP
  0665    0064    CLRWDT
86:               {
87:               	asm("nop");
88:               	asm("clrwdt");
89:               	OSCCON = 0X70; // 为8M/4=2M
  0666    3070    LDIA	0x70
  0667    1683    SETB	0x3,5
  0668    008F    LD	0xF,A
90:               
91:               	PortInit();
  0669    2723    CALL	0x723
92:               	Timer0Cofng();
  066A    27BA    CALL	0x7BA
93:               	Timer2Config();
  066B    2786    CALL	0x786
94:               	AdcConfig();
  066C    27CE    CALL	0x7CE
95:               	PwmConfig();
  066D    27C1    CALL	0x7C1
  066E    0064    CLRWDT
96:               
97:               	asm("clrwdt");
98:               	INTCON |= 0XC0; // 开启中断
  066F    30C0    LDIA	0xC0
  0670    048B    ORR	0xB
99:               	SWDTEN = 1;		// enable wdt
  0671    1683    SETB	0x3,5
  0672    1408    SETB	0x8,0
100:              
101:              	app_process_set_work_state(WORK_STATE_POWEROFF);
  0673    3000    LDIA	0x0
  0674    27D4    CALL	0x7D4
102:              	app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  0675    3000    LDIA	0x0
  0676    27D9    CALL	0x7D9
103:              
104:              #if 0
105:              	BatStates = 1;
106:              	app_charge.Remind = 1;
107:              
108:              #endif
109:              	// FlagOldMode = 1;
110:              	// app_work_state = WORK_STATE_WORKING;
111:              	// // work_mode.mode = 3;
112:              	// // led_pwm_ctrl(LED_INDEX_1,ON);
113:              	// app_charge.FullCharge = 1;
114:              	// app_charge.Charge = 1;
115:              	//  BatStates = 2;
116:              	//  app_work_state = WORK_STATE_WORKING;
117:              	// app_charge.LowPower = 1;
118:              	while (1)
  0677    0064    CLRWDT
119:              	{
120:              		asm("clrwdt");
121:              
122:              		if (Flag_10ms)
  0678    1C7B    SNZB	0x7B,0
  0679    2E77    JP	0x677
123:              		{
124:              			Flag_10ms = 0;
  067A    107B    CLRB	0x7B,0
125:              			app_adc_process();
  067B    27E4    CALL	0x7E4
126:              			app_process_charge();
  067C    27E3    CALL	0x7E3
127:              
128:              			app_process_key();
  067D    27C8    CALL	0x7C8
129:              			app_process_work();		  // brush
  067E    276F    CALL	0x76F
130:              			app_water_process_work(); // water
  067F    2744    CALL	0x744
131:              
132:              			app_process_go_to_sleep();
  0680    2712    CALL	0x712
133:              			process_led_remind_low_power();
  0681    21C3    CALL	0x1C3
  0682    2E77    JP	0x677
134:              		}
135:              	}
136:              }
137:              
138:              /////////////////////////////////////////// GotoSleep ///////////////////////////
139:              void GotoSleep()
140:              {
141:              	if (IO_KEY_BRUSH_PWR && IO_KEY_WATER_PWR && IO_KEY_WATER_MODE)
  03D5    1283    CLRB	0x3,5
  03D6    1906    SZB	0x6,2
  03D7    1C06    SNZB	0x6,0
  03D8    2C10    JP	0x410
  03D9    1C86    SNZB	0x6,1
  03DA    2C10    JP	0x410
  03DB    30C8    LDIA	0xC8
142:              	{
143:              
144:              		CntSleep++;
  03DC    0AC5    INCR	0x45
145:              		if (CntSleep >= 200)
  03DD    0245    SUBA	0x45
  03DE    1C03    SNZB	0x3,0
  03DF    0008    RET
146:              		{
147:              			CntSleep = 0;
  03E0    01C5    CLR	0x45
148:              			// ADC
149:              			ADCON0 = 0b00000000;
  03E1    019F    CLR	0x1F
150:              			ADCON1 = 0b00000000;
  03E2    1683    SETB	0x3,5
  03E3    019F    CLR	0x1F
151:              			//
152:              			SWDTEN = 0;
  03E4    1008    CLRB	0x8,0
153:              			WDTCON = 0x00;
  03E5    0188    CLR	0x8
154:              			//
155:              			GIE = 0;
  03E6    138B    CLRB	0xB,7
156:              			TRISB = 0b00010111; // input=1,output=0
  03E7    3017    LDIA	0x17
  03E8    0086    LD	0x6,A
157:              			WPUB = 0b00000111;
  03E9    3007    LDIA	0x7
  03EA    0095    LD	0x15,A
158:              			TRISA = 0b00000000; // input=1,output=0
  03EB    0185    CLR	0x5
159:              			PORTA = 0b00000000;
  03EC    1283    CLRB	0x3,5
  03ED    0185    CLR	0x5
160:              			ChargePwmOut(0);
  03EE    3000    LDIA	0x0
  03EF    2734    CALL	0x734
161:              			//
162:              			ANSELH = 0b00000000;
  03F0    1683    SETB	0x3,5
  03F1    0194    CLR	0x14
163:              			//
164:              
165:              			IOCA = 0b00000000;
  03F2    1283    CLRB	0x3,5
  03F3    0189    CLR	0x9
166:              			IOCB = 0b00010111; // wakeup,
  03F4    3017    LDIA	0x17
  03F5    1683    SETB	0x3,5
  03F6    0096    LD	0x16,A
167:              
168:              			RAIE = 1;
  03F7    158C    SETB	0xC,3
169:              			RBIE = 1;
  03F8    158B    SETB	0xB,3
170:              			PEIE = 1;
  03F9    170B    SETB	0xB,6
171:              
172:              			RAIF = 0; // clear flag
  03FA    1283    CLRB	0x3,5
  03FB    118C    CLRB	0xC,3
173:              			PORTA;	  /// this must have
  03FC    0805    LD	A,0x5
174:              			RBIF = 0; // clear flag
  03FD    100B    CLRB	0xB,0
175:              			PORTB;	  /// this must have
  03FE    0806    LD	A,0x6
  03FF    0064    CLRWDT
  0400    0063    STOP
  0401    0000    NOP
  0402    0000    NOP
  0403    0000    NOP
176:              
177:              			asm("clrwdt");
178:              			asm("sleep"); /// goto sleep
179:              
180:              			asm("nop"); /// wake up
181:              			asm("nop");
182:              			asm("nop");
183:              			// ADC
184:              			ADON = 1;
  0404    1283    CLRB	0x3,5
  0405    141F    SETB	0x1F,0
185:              			//
186:              			SWDTEN = 1;
  0406    1683    SETB	0x3,5
  0407    1408    SETB	0x8,0
187:              			//  RB1 RB2 RA3
188:              			IOCB = 0x00; // 0b 0000 0110
  0408    0196    CLR	0x16
189:              			IOCA = 0x00; // 0b 0000 1000
  0409    1283    CLRB	0x3,5
  040A    0189    CLR	0x9
190:              			//
191:              			GIE = 1;
  040B    178B    SETB	0xB,7
192:              
193:              			SWDTEN = 1;
  040C    1683    SETB	0x3,5
  040D    1408    SETB	0x8,0
194:              			AdcConfig();
  040E    27CE    CALL	0x7CE
195:              			PortInit();
  040F    2F23    JP	0x723
196:              		}
197:              	}
198:              	else
199:              	{
200:              		CntSleep = 0;
  0410    01C5    CLR	0x45
  0411    0008    RET
201:              	}
202:              }
203:              
204:              /***********************************************
205:              //1ms
206:              ************************************************/
207:              void interrupt Timer2_Isr(void)
208:              {
209:              	// RB5 = 1;
210:              	//  if(T0IF)
211:              	//  {
212:              	//  	//RB5 = ~RB5;
213:              	//  	T0IF = 0;
214:              
215:              	// 	#if DEBUG
216:              	// 	//TMR0 +=  256 - 5;
217:              	// 	#endif
218:              	// 	app_motor_pwm_out();
219:              	// 	led_old_mode_pwm();
220:              	// }
221:              	if (PWMIF)
  044D    1283    CLRB	0x3,5
  044E    190C    SZB	0xC,2
222:              	{
223:              		PWMIF = 0;
  044F    110C    CLRB	0xC,2
224:              	}
225:              
226:              	if (T0IF) // 50us中断
  0450    1D0B    SNZB	0xB,2
  0451    2C57    JP	0x457
227:              	{
228:              		TMR0 = 165; // 215;//165;			//TMR0不能自动赋值
  0452    30A5    LDIA	0xA5
  0453    0081    LD	0x1,A
229:              		T0IF = 0;
  0454    110B    CLRB	0xB,2
230:              		Mode_control(); // 牙刷电机驱动
  0455    2346    CALL	0x346
231:              		led_charge_pwm();
  0456    2139    CALL	0x139
232:              		// Cnt250us++;
233:              		//  if (Cnt250us >= 5)
234:              		//  {
235:              		//  	MotorWaterDrive();
236:              		//  	Cnt250us = 0;
237:              		//  	Flag_250us = 1;
238:              		//  }
239:              	}
240:              	if (TMR2IF)
  0457    1283    CLRB	0x3,5
  0458    1C8C    SNZB	0xC,1
  0459    2C77    JP	0x477
241:              	{
242:              		TMR2IF = 0;
  045A    108C    CLRB	0xC,1
243:              		Cnt10ms++;
  045B    1683    SETB	0x3,5
  045C    0ACD    INCR	0x4D
  045D    1903    SZB	0x3,2
  045E    0ACE    INCR	0x4E
244:              		Cnt1ms++;
  045F    0ACB    INCR	0x4B
  0460    1903    SZB	0x3,2
  0461    0ACC    INCR	0x4C
245:              		MotorWaterDrive();
  0462    26EE    CALL	0x6EE
246:              		if (Cnt1ms == 4)
  0463    3004    LDIA	0x4
  0464    1683    SETB	0x3,5
  0465    064B    XORA	0x4B
  0466    044C    ORA	0x4C
  0467    1D03    SNZB	0x3,2
  0468    2C6C    JP	0x46C
247:              		{
248:              			Cnt1ms = 0;
  0469    01CB    CLR	0x4B
  046A    01CC    CLR	0x4C
249:              			process_led();
  046B    2232    CALL	0x232
250:              		}
251:              		if (Cnt10ms >= 40) // 100 * 100 = 10000us = 10ms
  046C    3000    LDIA	0x0
  046D    1683    SETB	0x3,5
  046E    024E    SUBA	0x4E
  046F    3028    LDIA	0x28
  0470    1903    SZB	0x3,2
  0471    024D    SUBA	0x4D
  0472    1C03    SNZB	0x3,0
  0473    2C77    JP	0x477
252:              		{
253:              			Cnt10ms = 0;
  0474    01CD    CLR	0x4D
  0475    01CE    CLR	0x4E
254:              			Flag_10ms = 1;
  0476    147B    SETB	0x7B,0
255:              		}
256:              	}
257:              	if (RAIF)
  0477    1283    CLRB	0x3,5
  0478    1D8C    SNZB	0xC,3
  0479    2C7C    JP	0x47C
258:              	{
259:              		RAIF = 0; //
  047A    118C    CLRB	0xC,3
260:              		PORTA;	  //
  047B    0805    LD	A,0x5
261:              	}
262:              	if (RBIF)
  047C    1C0B    SNZB	0xB,0
  047D    2C80    JP	0x480
263:              	{
264:              		RBIF = 0; //
  047E    100B    CLRB	0xB,0
265:              		PORTB;	  //
  047F    0806    LD	A,0x6
  0480    087A    LD	A,0x7A
  0481    008A    LD	0xA,A
  0482    0E79    SWAPA	0x79
  0483    0083    LD	0x3,A
  0484    0EFE    SWAPR	0x7E
  0485    0E7E    SWAPA	0x7E
  0486    0009    RETI
266:              	}
267:              	// RB5 = 0;
268:              }
269:              
270:              /*
271:              	长按按键老化的时候没有做低电处理
272:              	充电的时候应该只关闭电机，不关闭灯
273:              
274:              */
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_led.c ----------------------------------------------------------------------
1:                #include "main.h"
2:                
3:                uint16_t CntLedFlash;
4:                // #define _XTAL_FREQ 8000000UL		//如果用16M晶振则改为16000000UL
5:                
6:                // uint16_t PWM_Cnt;
7:                
8:                // bit led_lock;
9:                
10:               bit PWM_dir;
11:               uint16_t PWM_Duty;
12:               uint16_t PWM_Cnt;
13:               
14:               // typedef enum
15:               // {
16:               //     LED_STATE_OFF = 0,
17:               //     LED_STATE_ON = !LED_STATE_OFF,
18:               // }led_state_t;
19:               
20:               uint32_t led_index;
21:               // uint8_t led_state;
22:               
23:               // 单独的灯
24:               void led_pwm_ctrl(led_index_t index, uint8_t state)
25:               {
26:                   led_index |= index;
27:               }
28:               
29:               void led_pwm_close(led_index_t index, uint8_t state)
30:               {
31:                   if ((led_index & LED_INDEX_1) == (index & LED_INDEX_1))
32:                   {
33:                       led_index &= ~LED_INDEX_1;
34:                   }
35:                   if ((led_index & LED_INDEX_1) == (index & LED_INDEX_1))
36:                   {
37:                       led_index &= ~LED_INDEX_2;
38:                   }
39:                   if ((led_index & LED_INDEX_1) == (index & LED_INDEX_1))
40:                   {
41:                       led_index &= ~LED_INDEX_3;
42:                   }
43:                   if (led_index == LED_INDEX_ALL)
44:                   {
45:                       led_index = 0;
46:                   }
47:               }
48:               
49:               // 呼吸灯
50:               bit PWM_dir;
51:               uint16_t PWM_Duty = 0;
52:               uint16_t PWM_Cnt;
53:               #define pwm_time 200
54:               uint16_t pwm_timer;
55:               #define PWM_WHAT 199
56:               
57:               bit is_charge_pwm;
58:               void led_charge_pwm()
59:               {
60:                   if (WORK_STATE_CHARGING == app_work_state)
  0139    3002    LDIA	0x2
  013A    066D    XORA	0x6D
  013B    1D03    SNZB	0x3,2
  013C    29BD    JP	0x1BD
61:                   {
62:                       if (app_charge.Charge)
  013D    1683    SETB	0x3,5
  013E    1C20    SNZB	0x20,0
  013F    0008    RET
63:                       {
64:                            IO_LED1 = 0;
  0140    1283    CLRB	0x3,5
  0141    1005    CLRB	0x5,0
65:                           TRISA &= ~BIT(0);
  0142    1683    SETB	0x3,5
  0143    1005    CLRB	0x5,0
66:                            IO_LED2 = 0;
  0144    1283    CLRB	0x3,5
  0145    1085    CLRB	0x5,1
67:                           TRISA &= ~BIT(1);
  0146    1683    SETB	0x3,5
  0147    1085    CLRB	0x5,1
68:                           IO_LED6 = 0;
  0148    1283    CLRB	0x3,5
  0149    1305    CLRB	0x5,6
69:                           TRISA &= ~BIT(6);
  014A    1683    SETB	0x3,5
  014B    1305    CLRB	0x5,6
70:                           if (app_charge.flag_charge_force_full_24hour)
  014C    1DA0    SNZB	0x20,3
  014D    2955    JP	0x155
  014E    3003    LDIA	0x3
71:                           {
72:                               is_charge_pwm = 0;
  014F    11FB    CLRB	0x7B,3
73:                               set_led_state(LED_INDEX_9 | LED_INDEX_10, LED_STATE_OFF);
  0150    01F0    CLR	0x70
  0151    00F1    LD	0x71,A
  0152    01F2    CLR	0x72
  0153    255D    CALL	0x55D
74:                           }
  0154    0008    RET
75:                           else if (app_charge.FullCharge || app_charge.ForceFullCharge)
  0155    18A0    SZB	0x20,1
  0156    2959    JP	0x159
  0157    1D20    SNZB	0x20,2
  0158    2966    JP	0x166
  0159    3001    LDIA	0x1
76:                           {
77:                               is_charge_pwm = 0;
  015A    11FB    CLRB	0x7B,3
78:                               set_led_state(LED_INDEX_9, LED_STATE_ON);
  015B    01F0    CLR	0x70
  015C    00F1    LD	0x71,A
  015D    01F2    CLR	0x72
  015E    0AF2    INCR	0x72
  015F    255D    CALL	0x55D
79:                               set_led_state(LED_INDEX_10, LED_STATE_OFF);
  0160    3002    LDIA	0x2
  0161    01F0    CLR	0x70
  0162    00F1    LD	0x71,A
  0163    01F2    CLR	0x72
  0164    255D    CALL	0x55D
80:                           }
  0165    0008    RET
81:                           else
82:                           {
83:                               is_charge_pwm = 1;
  0166    15FB    SETB	0x7B,3
84:                               PWM_Cnt++;
  0167    1283    CLRB	0x3,5
  0168    0AAA    INCR	0x2A
  0169    1903    SZB	0x3,2
  016A    0AAB    INCR	0x2B
85:                               //
86:                               //  PWM_Duty = 50;
87:                               if (PWM_Duty >= PWM_Cnt) // 100us进来一次    50 * 100
  016B    082B    LD	A,0x2B
  016C    022D    SUBA	0x2D
  016D    1D03    SNZB	0x3,2
  016E    2971    JP	0x171
  016F    082A    LD	A,0x2A
  0170    022C    SUBA	0x2C
  0171    1C03    SNZB	0x3,0
  0172    297F    JP	0x17F
88:                               {
89:                                   IO_LED3 = 1;
  0173    1505    SETB	0x5,2
90:                                   TRISA &= ~BIT(2);
  0174    1683    SETB	0x3,5
  0175    1105    CLRB	0x5,2
91:                                   IO_LED5 = 0;
  0176    1283    CLRB	0x3,5
  0177    1205    CLRB	0x5,4
92:                                   TRISA &= ~BIT(4);
  0178    1683    SETB	0x3,5
  0179    1205    CLRB	0x5,4
93:                                   IO_LED4 = 1;
  017A    1283    CLRB	0x3,5
  017B    1585    SETB	0x5,3
94:                                   TRISA &= ~BIT(3);
  017C    1683    SETB	0x3,5
  017D    1185    CLRB	0x5,3
95:                               }
  017E    2986    JP	0x186
96:                               else
97:                               {
98:                                   IO_LED3 = 0;
  017F    1105    CLRB	0x5,2
99:                                   TRISA &= ~BIT(2);
  0180    1683    SETB	0x3,5
  0181    1105    CLRB	0x5,2
100:                                  IO_LED5 = 0;
  0182    1283    CLRB	0x3,5
  0183    1205    CLRB	0x5,4
101:                                  TRISA &= ~BIT(4);
  0184    1683    SETB	0x3,5
  0185    1205    CLRB	0x5,4
102:                              }
103:                              if (PWM_Cnt >= PWM_WHAT) // 每50us PWM_Cnt加一次 ，
  0186    3000    LDIA	0x0
  0187    1283    CLRB	0x3,5
  0188    022B    SUBA	0x2B
  0189    30C7    LDIA	0xC7
  018A    1903    SZB	0x3,2
  018B    022A    SUBA	0x2A
  018C    1C03    SNZB	0x3,0
  018D    2990    JP	0x190
104:                              {
105:                                  PWM_Cnt = 0;
  018E    01AA    CLR	0x2A
  018F    01AB    CLR	0x2B
106:                              }
107:                              pwm_timer++;
  0190    0AA8    INCR	0x28
  0191    1903    SZB	0x3,2
  0192    0AA9    INCR	0x29
108:                              if (!PWM_dir)
  0193    1A7B    SZB	0x7B,4
  0194    29A9    JP	0x1A9
109:                              {
110:                                  if (pwm_timer >= pwm_time) // 50us * 200
  0195    3000    LDIA	0x0
  0196    0229    SUBA	0x29
  0197    30C8    LDIA	0xC8
  0198    1903    SZB	0x3,2
  0199    0228    SUBA	0x28
  019A    1C03    SNZB	0x3,0
  019B    0008    RET
  019C    3000    LDIA	0x0
111:                                  {
112:                                      pwm_timer = 0;
  019D    01A8    CLR	0x28
  019E    01A9    CLR	0x29
113:              
114:                                      if (PWM_Duty >= PWM_WHAT)
  019F    022D    SUBA	0x2D
  01A0    30C7    LDIA	0xC7
  01A1    1903    SZB	0x3,2
  01A2    022C    SUBA	0x2C
  01A3    1803    SZB	0x3,0
115:                                      {
116:                                          PWM_dir = 1;
  01A4    167B    SETB	0x7B,4
117:                                      }
118:                                      PWM_Duty++;
  01A5    0AAC    INCR	0x2C
  01A6    1903    SZB	0x3,2
  01A7    0AAD    INCR	0x2D
  01A8    0008    RET
119:                                  }
120:                              }
121:                              else
122:                              {
123:                                  if (pwm_timer >= pwm_time) // 每进来一次
  01A9    3000    LDIA	0x0
  01AA    0229    SUBA	0x29
  01AB    30C8    LDIA	0xC8
  01AC    1903    SZB	0x3,2
  01AD    0228    SUBA	0x28
  01AE    1C03    SNZB	0x3,0
  01AF    0008    RET
  01B0    3001    LDIA	0x1
124:                                  {
125:              
126:                                      pwm_timer = 0;
  01B1    01A8    CLR	0x28
  01B2    01A9    CLR	0x29
127:                                      // PWM_Cnt = 0;
128:                                      // 换方向
129:                                      PWM_Duty--;
  01B3    02AC    SUBR	0x2C
  01B4    3000    LDIA	0x0
  01B5    1C03    SNZB	0x3,0
  01B6    03AD    DECR	0x2D
  01B7    02AD    SUBR	0x2D
130:                                      if (!PWM_Duty)
  01B8    082C    LD	A,0x2C
  01B9    042D    ORA	0x2D
  01BA    1903    SZB	0x3,2
131:                                      {
132:                                          PWM_dir = 0;
  01BB    127B    CLRB	0x7B,4
  01BC    0008    RET
133:                                      }
134:                                  }
135:                              }
136:                          }
137:                      }
138:                  }
139:                  else
140:                  {
141:                      is_charge_pwm = 0;
  01BD    11FB    CLRB	0x7B,3
142:                      PWM_Cnt = 0;
  01BE    01AA    CLR	0x2A
  01BF    01AB    CLR	0x2B
143:                      pwm_timer = 0;
  01C0    01A8    CLR	0x28
  01C1    01A9    CLR	0x29
  01C2    0008    RET
144:                  }
145:              }
146:              
147:              void app_led_mode_set()
148:              {
149:                  if (work_mode.mode == WORK_MODE_ONE)
  05B8    1283    CLRB	0x3,5
  05B9    0B66    SZDECA	0x66
  05BA    2DC6    JP	0x5C6
150:                  {
151:                      set_led_state(LED_INDEX_2 | LED_INDEX_3, LED_STATE_OFF);
  05BB    3006    LDIA	0x6
  05BC    00D3    LD	0x53,A
  05BD    01D4    CLR	0x54
  05BE    01D5    CLR	0x55
  05BF    25E4    CALL	0x5E4
152:                      set_led_state(LED_INDEX_1, LED_STATE_ON);
  05C0    01D3    CLR	0x53
  05C1    0AD3    INCR	0x53
  05C2    01D4    CLR	0x54
  05C3    01D5    CLR	0x55
  05C4    0AD5    INCR	0x55
  05C5    2DE4    JP	0x5E4
153:                  }
154:                  else if (work_mode.mode == WORK_MODE_TWO)
  05C6    3002    LDIA	0x2
  05C7    0666    XORA	0x66
  05C8    1D03    SNZB	0x3,2
  05C9    2DD5    JP	0x5D5
155:                  {
156:                      set_led_state(LED_INDEX_1 | LED_INDEX_3, LED_STATE_OFF);
  05CA    3005    LDIA	0x5
  05CB    00D3    LD	0x53,A
  05CC    01D4    CLR	0x54
  05CD    01D5    CLR	0x55
  05CE    25E4    CALL	0x5E4
157:                      set_led_state(LED_INDEX_2, LED_STATE_ON);
  05CF    3002    LDIA	0x2
  05D0    00D3    LD	0x53,A
  05D1    01D4    CLR	0x54
  05D2    01D5    CLR	0x55
  05D3    0AD5    INCR	0x55
  05D4    2DE4    JP	0x5E4
158:                  }
159:                  else if (work_mode.mode == WORK_MODE_THREE)
  05D5    3003    LDIA	0x3
  05D6    0666    XORA	0x66
  05D7    1D03    SNZB	0x3,2
  05D8    0008    RET
160:                  {
161:                      set_led_state(LED_INDEX_1 | LED_INDEX_2, LED_STATE_OFF);
  05D9    3003    LDIA	0x3
  05DA    00D3    LD	0x53,A
  05DB    01D4    CLR	0x54
  05DC    01D5    CLR	0x55
  05DD    25E4    CALL	0x5E4
162:                      set_led_state(LED_INDEX_3, LED_STATE_ON);
  05DE    3004    LDIA	0x4
  05DF    00D3    LD	0x53,A
  05E0    01D4    CLR	0x54
  05E1    01D5    CLR	0x55
  05E2    0AD5    INCR	0x55
  05E3    2DE4    JP	0x5E4
163:                  }
164:              }
165:              
166:              void app_led_water_mode_set()
167:              {
168:                  if (water_work_mode.water_mode == WATER_WORK_MODE_ONE)
  0412    1283    CLRB	0x3,5
  0413    0B61    SZDECA	0x61
  0414    2C1D    JP	0x41D
169:                  {
170:                      set_led_state(LED_INDEX_8, LED_STATE_ON);
  0415    3080    LDIA	0x80
  0416    2448    CALL	0x448
  0417    25E4    CALL	0x5E4
171:                      set_led_state(LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0418    3078    LDIA	0x78
  0419    00D3    LD	0x53,A
  041A    01D4    CLR	0x54
  041B    01D5    CLR	0x55
  041C    2DE4    JP	0x5E4
172:                  }
173:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_TWO)
  041D    3002    LDIA	0x2
  041E    0661    XORA	0x61
  041F    1D03    SNZB	0x3,2
  0420    2C29    JP	0x429
174:                  {
175:                      set_led_state(LED_INDEX_8 | LED_INDEX_7, LED_STATE_ON);
  0421    30C0    LDIA	0xC0
  0422    2448    CALL	0x448
  0423    25E4    CALL	0x5E4
176:                      set_led_state(LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0424    3038    LDIA	0x38
  0425    00D3    LD	0x53,A
  0426    01D4    CLR	0x54
  0427    01D5    CLR	0x55
  0428    2DE4    JP	0x5E4
177:                  }
178:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_THREE)
  0429    3003    LDIA	0x3
  042A    0661    XORA	0x61
  042B    1D03    SNZB	0x3,2
  042C    2C35    JP	0x435
179:                  {
180:                      set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6, LED_STATE_ON);
  042D    30E0    LDIA	0xE0
  042E    2448    CALL	0x448
  042F    25E4    CALL	0x5E4
181:                      set_led_state(LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0430    3018    LDIA	0x18
  0431    00D3    LD	0x53,A
  0432    01D4    CLR	0x54
  0433    01D5    CLR	0x55
  0434    2DE4    JP	0x5E4
182:                  }
183:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_FOUR)
  0435    3004    LDIA	0x4
  0436    0661    XORA	0x61
  0437    1D03    SNZB	0x3,2
  0438    2C41    JP	0x441
184:                  {
185:                      set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5, LED_STATE_ON);
  0439    30F0    LDIA	0xF0
  043A    2448    CALL	0x448
  043B    25E4    CALL	0x5E4
186:                      set_led_state(LED_INDEX_4, LED_STATE_OFF);
  043C    3008    LDIA	0x8
  043D    00D3    LD	0x53,A
  043E    01D4    CLR	0x54
  043F    01D5    CLR	0x55
  0440    2DE4    JP	0x5E4
187:                  }
188:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_FIVE)
  0441    3005    LDIA	0x5
  0442    0661    XORA	0x61
  0443    1D03    SNZB	0x3,2
  0444    0008    RET
189:                  {
190:                      set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_ON);
  0445    30F8    LDIA	0xF8
  0446    2448    CALL	0x448
  0447    2DE4    JP	0x5E4
191:                  }
192:              }
193:              
194:              void process_led_remind_low_power()
195:              {
196:                  if (app_charge.LowPower)
  01C3    1683    SETB	0x3,5
  01C4    0826    LD	A,0x26
  01C5    1903    SZB	0x3,2
  01C6    29ED    JP	0x1ED
197:                  {
198:                      if (app_charge.LowLed)
  01C7    0827    LD	A,0x27
  01C8    1903    SZB	0x3,2
  01C9    0008    RET
  01CA    3002    LDIA	0x2
199:                      {
200:                          app_charge.LowLed_cnt++;
  01CB    0AA8    INCR	0x28
201:                          if (app_charge.LowLed_cnt <= 1)
  01CC    0228    SUBA	0x28
  01CD    1803    SZB	0x3,0
  01CE    29DA    JP	0x1DA
202:                          {
203:                              app_process_set_work_state(WORK_STATE_POWEROFF);
  01CF    3000    LDIA	0x0
  01D0    27D4    CALL	0x7D4
204:                              app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  01D1    3000    LDIA	0x0
  01D2    27D9    CALL	0x7D9
205:                              app_charge.low_led_blink_cnt = 5;
  01D3    3005    LDIA	0x5
  01D4    1683    SETB	0x3,5
  01D5    00B1    LD	0x31,A
206:                              set_led_dirct_state(LED_INDEX_NULL);
  01D6    1283    CLRB	0x3,5
  01D7    01D3    CLR	0x53
  01D8    01D4    CLR	0x54
  01D9    2FB3    JP	0x7B3
207:                          }
208:                          else if (app_charge.LowLed_cnt < 25)
  01DA    3019    LDIA	0x19
  01DB    0228    SUBA	0x28
  01DC    1803    SZB	0x3,0
  01DD    29E1    JP	0x1E1
209:                          {
210:                              set_led_state(LED_INDEX_10, LED_STATE_ON);
  01DE    222C    CALL	0x22C
  01DF    0AD5    INCR	0x55
  01E0    2DE4    JP	0x5E4
211:                          }
212:                          else if (app_charge.LowLed_cnt < 50)
  01E1    3032    LDIA	0x32
  01E2    0228    SUBA	0x28
  01E3    1803    SZB	0x3,0
  01E4    29E7    JP	0x1E7
213:                          {
214:                              set_led_state(LED_INDEX_10, LED_STATE_OFF);
  01E5    222C    CALL	0x22C
  01E6    2DE4    JP	0x5E4
215:                          }
216:                          else
217:                          {
218:                              app_charge.low_led_blink_cnt--;
  01E7    03B1    DECR	0x31
219:                              if (!app_charge.low_led_blink_cnt)
  01E8    1903    SZB	0x3,2
220:                              {
221:                                  app_charge.LowLed = FLASE;
  01E9    01A7    CLR	0x27
222:                              }
223:                              app_charge.LowLed_cnt = 2;
  01EA    3002    LDIA	0x2
  01EB    00A8    LD	0x28,A
  01EC    0008    RET
224:                          }
225:                      }
226:                  }
227:                  else if (app_charge.Remind)
  01ED    1E20    SNZB	0x20,4
  01EE    2A28    JP	0x228
228:                  {
229:                      if (app_work_state == WORK_STATE_WORKING || water_work_state == WATER_WORK_STATE_WORKING || app_charge.flag_remind_delay_10s)
  01EF    1283    CLRB	0x3,5
  01F0    036D    DECA	0x6D
  01F1    1903    SZB	0x3,2
  01F2    29FA    JP	0x1FA
  01F3    036C    DECA	0x6C
  01F4    1903    SZB	0x3,2
  01F5    29FA    JP	0x1FA
  01F6    1683    SETB	0x3,5
  01F7    0822    LD	A,0x22
  01F8    1903    SZB	0x3,2
  01F9    0008    RET
230:                      {
231:                          CntLedFlash++;
  01FA    1283    CLRB	0x3,5
  01FB    0AAE    INCR	0x2E
  01FC    1903    SZB	0x3,2
  01FD    0AAF    INCR	0x2F
232:                          if (CntLedFlash <= MS(500))
  01FE    3000    LDIA	0x0
  01FF    022F    SUBA	0x2F
  0200    3033    LDIA	0x33
  0201    1903    SZB	0x3,2
  0202    022E    SUBA	0x2E
  0203    1C03    SNZB	0x3,0
  0204    29DE    JP	0x1DE
233:                          {
234:                              set_led_state(LED_INDEX_10, LED_STATE_ON);
235:                          }
236:                          else if (CntLedFlash <= MS(1000))
  0205    3000    LDIA	0x0
  0206    022F    SUBA	0x2F
  0207    3065    LDIA	0x65
  0208    1903    SZB	0x3,2
  0209    022E    SUBA	0x2E
  020A    1C03    SNZB	0x3,0
  020B    29E5    JP	0x1E5
237:                          {
238:                              set_led_state(LED_INDEX_10, LED_STATE_OFF);
239:                          }
240:                          else
241:                          {
242:                              CntLedFlash = 0;
  020C    01AE    CLR	0x2E
  020D    01AF    CLR	0x2F
243:                              if (app_charge.flag_remind_delay_10s)
  020E    1683    SETB	0x3,5
  020F    0822    LD	A,0x22
  0210    1903    SZB	0x3,2
  0211    0008    RET
244:                              {
245:                                  //低电关机亮灯10S
246:                                  if (++app_charge.remind_delay_10s_timer >= 10)
  0212    0AA3    INCR	0x23
  0213    1903    SZB	0x3,2
  0214    0AA4    INCR	0x24
  0215    3000    LDIA	0x0
  0216    0224    SUBA	0x24
  0217    300A    LDIA	0xA
  0218    1903    SZB	0x3,2
  0219    0223    SUBA	0x23
  021A    1C03    SNZB	0x3,0
  021B    0008    RET
  021C    3002    LDIA	0x2
247:                                  {
248:                                      app_charge.flag_remind_delay_10s = 0;
  021D    01A2    CLR	0x22
249:                                      // 关机
250:                                      set_led_state(LED_INDEX_10, LED_STATE_OFF);
  021E    2134    CALL	0x134
  021F    25E4    CALL	0x5E4
251:                                      if (water_work_state != WATER_WORK_STATE_MODE_LED)
  0220    3003    LDIA	0x3
  0221    066C    XORA	0x6C
  0222    1903    SZB	0x3,2
  0223    0008    RET
252:                                      {
253:                                           app_process_set_work_state(WORK_STATE_POWEROFF);
  0224    3000    LDIA	0x0
  0225    27D4    CALL	0x7D4
254:                                          app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  0226    3000    LDIA	0x0
  0227    2FD9    JP	0x7D9
255:                                      }
256:                                      
257:                                     
258:                                  }
259:                              }
260:                          }
261:                      }
262:                  }
263:                  else
264:                  {
265:                      CntLedFlash = 0;
  0228    1283    CLRB	0x3,5
  0229    01AE    CLR	0x2E
  022A    01AF    CLR	0x2F
  022B    0008    RET
266:                  }
267:              }
268:              
269:              void set_led_state(led_index_t index, led_state_t state)
270:              {
271:                  if (LED_STATE_ON == state)
  055D    0B72    SZDECA	0x72
  055E    2D6F    JP	0x56F
  05E4    0B55    SZDECA	0x55
  05E5    2DF5    JP	0x5F5
272:                  {
273:                      led_index |= index;
  055F    0870    LD	A,0x70
  0560    00F3    LD	0x73,A
  0561    0871    LD	A,0x71
  0562    00F4    LD	0x74,A
  0563    01F5    CLR	0x75
  0564    01F6    CLR	0x76
  0565    0873    LD	A,0x73
  0566    1283    CLRB	0x3,5
  0567    04A0    ORR	0x20
  0568    0874    LD	A,0x74
  0569    04A1    ORR	0x21
  056A    0875    LD	A,0x75
  056B    04A2    ORR	0x22
  056C    0876    LD	A,0x76
  056D    04A3    ORR	0x23
  05E6    0853    LD	A,0x53
  05E7    00D6    LD	0x56,A
  05E8    0854    LD	A,0x54
  05E9    00D7    LD	0x57,A
  05EA    01D8    CLR	0x58
  05EB    01D9    CLR	0x59
  05EC    0856    LD	A,0x56
  05ED    04A0    ORR	0x20
  05EE    0857    LD	A,0x57
  05EF    04A1    ORR	0x21
  05F0    0858    LD	A,0x58
  05F1    04A2    ORR	0x22
  05F2    0859    LD	A,0x59
  05F3    04A3    ORR	0x23
274:                  }
  056E    0008    RET
  05F4    0008    RET
275:                  else if (LED_STATE_OFF == state)
  056F    0872    LD	A,0x72
  0570    1D03    SNZB	0x3,2
  0571    0008    RET
  05F5    0855    LD	A,0x55
  05F6    1D03    SNZB	0x3,2
  05F7    0008    RET
276:                  {
277:                      led_index &= ~index;
  0572    0871    LD	A,0x71
  0573    00F4    LD	0x74,A
  0574    0870    LD	A,0x70
  0575    00F3    LD	0x73,A
  0576    09F3    COMR	0x73
  0577    09F4    COMR	0x74
  0578    0873    LD	A,0x73
  0579    00F5    LD	0x75,A
  057A    0874    LD	A,0x74
  057B    00F6    LD	0x76,A
  057C    3000    LDIA	0x0
  057D    1BF6    SZB	0x76,7
  057E    30FF    LDIA	0xFF
  057F    00F7    LD	0x77,A
  0580    00F8    LD	0x78,A
  0581    0875    LD	A,0x75
  0582    1283    CLRB	0x3,5
  0583    05A0    ANDR	0x20
  0584    0876    LD	A,0x76
  0585    05A1    ANDR	0x21
  0586    0877    LD	A,0x77
  0587    05A2    ANDR	0x22
  0588    0878    LD	A,0x78
  0589    05A3    ANDR	0x23
  058A    0008    RET
  05F8    0854    LD	A,0x54
  05F9    00D7    LD	0x57,A
  05FA    0853    LD	A,0x53
  05FB    00D6    LD	0x56,A
  05FC    09D6    COMR	0x56
  05FD    09D7    COMR	0x57
  05FE    0856    LD	A,0x56
  05FF    00D8    LD	0x58,A
  0600    0857    LD	A,0x57
  0601    00D9    LD	0x59,A
  0602    3000    LDIA	0x0
  0603    1BD9    SZB	0x59,7
  0604    30FF    LDIA	0xFF
  0605    00DA    LD	0x5A,A
  0606    00DB    LD	0x5B,A
  0607    0858    LD	A,0x58
  0608    05A0    ANDR	0x20
  0609    0859    LD	A,0x59
  060A    05A1    ANDR	0x21
  060B    085A    LD	A,0x5A
  060C    05A2    ANDR	0x22
  060D    085B    LD	A,0x5B
  060E    05A3    ANDR	0x23
  060F    0008    RET
278:                  }
279:              }
280:              
281:              void set_led_dirct_state(led_index_t index)
282:              {
283:                  led_index = index;
  07B3    0853    LD	A,0x53
  07B4    00A0    LD	0x20,A
  07B5    0854    LD	A,0x54
  07B6    00A1    LD	0x21,A
  07B7    01A2    CLR	0x22
  07B8    01A3    CLR	0x23
  07B9    0008    RET
284:              }
285:              static volatile u8 step = 0;
286:              void process_led(void)
287:              {
288:                 if (is_charge_pwm)
  0232    19FB    SZB	0x7B,3
  0233    0008    RET
289:                  {
290:                      return;
291:                  }
292:                  TRISA = 0b01011111;
  0234    305F    LDIA	0x5F
  0235    0085    LD	0x5,A
293:                  // PORTA = 0b00000000;
294:                  if (step == 0)
  0236    1283    CLRB	0x3,5
  0237    0846    LD	A,0x46
  0238    1D03    SNZB	0x3,2
  0239    2A5B    JP	0x25B
295:                  {
296:                      if (led_index & LED_INDEX_1)//GREEN1
  023A    1C20    SNZB	0x20,0
  023B    2A3F    JP	0x23F
297:                      {
298:                          IO_LED2 = 0;
  023C    1085    CLRB	0x5,1
299:                          TRISA &= ~BIT(1);
  023D    1683    SETB	0x3,5
  023E    1085    CLRB	0x5,1
300:                      }
301:                      if (led_index & LED_INDEX_2)//GREEN2
  023F    1283    CLRB	0x3,5
  0240    1CA0    SNZB	0x20,1
  0241    2A45    JP	0x245
302:                      {
303:                          IO_LED3 = 0;
  0242    1105    CLRB	0x5,2
304:                          TRISA &= ~BIT(2);
  0243    1683    SETB	0x3,5
  0244    1105    CLRB	0x5,2
305:                      }
306:                      if (led_index & LED_INDEX_3)//GREEN3
  0245    1283    CLRB	0x3,5
  0246    1D20    SNZB	0x20,2
  0247    2A4B    JP	0x24B
307:                      {
308:                          IO_LED4 = 0;
  0248    1185    CLRB	0x5,3
309:                          TRISA &= ~BIT(3);
  0249    1683    SETB	0x3,5
  024A    1185    CLRB	0x5,3
310:                      }
311:                      if (led_index & LED_INDEX_4)//BLUE4
  024B    1283    CLRB	0x3,5
  024C    1DA0    SNZB	0x20,3
  024D    2A51    JP	0x251
312:                      {
313:                          IO_LED5 = 0;
  024E    1205    CLRB	0x5,4
314:                          TRISA &= ~BIT(4);
  024F    1683    SETB	0x3,5
  0250    1205    CLRB	0x5,4
315:                      }
316:                      if (led_index & LED_INDEX_5)//BLUE5
  0251    1283    CLRB	0x3,5
  0252    1E20    SNZB	0x20,4
  0253    2A57    JP	0x257
317:                      {
318:                          IO_LED6 = 0;
  0254    1305    CLRB	0x5,6
319:                          TRISA &= ~BIT(6);
  0255    1683    SETB	0x3,5
  0256    1305    CLRB	0x5,6
320:                      }
321:                      IO_LED1 = 1;
  0257    1283    CLRB	0x3,5
  0258    1405    SETB	0x5,0
322:                      TRISA &= ~BIT(0);
  0259    1683    SETB	0x3,5
  025A    1005    CLRB	0x5,0
323:                  }
324:                  if (step == 1)
  025B    1283    CLRB	0x3,5
  025C    0B46    SZDECA	0x46
  025D    2A73    JP	0x273
325:                  {
326:                      if (led_index & LED_INDEX_6)//BLUE6
  025E    1EA0    SNZB	0x20,5
  025F    2A63    JP	0x263
327:                      {
328:                          IO_LED4 = 0;
  0260    1185    CLRB	0x5,3
329:                          TRISA &= ~BIT(3);
  0261    1683    SETB	0x3,5
  0262    1185    CLRB	0x5,3
330:                      }
331:                      if (led_index & LED_INDEX_7)//BLUE7
  0263    1283    CLRB	0x3,5
  0264    1F20    SNZB	0x20,6
  0265    2A69    JP	0x269
332:                      {
333:                          IO_LED6 = 0;
  0266    1305    CLRB	0x5,6
334:                          TRISA &= ~BIT(6);
  0267    1683    SETB	0x3,5
  0268    1305    CLRB	0x5,6
335:                      }
336:                      if (led_index & LED_INDEX_8)//BLUE8
  0269    1283    CLRB	0x3,5
  026A    1FA0    SNZB	0x20,7
  026B    2A6F    JP	0x26F
337:                      {
338:                          IO_LED5 = 0;
  026C    1205    CLRB	0x5,4
339:                          TRISA &= ~BIT(4);
  026D    1683    SETB	0x3,5
  026E    1205    CLRB	0x5,4
340:                      }
341:                      IO_LED2 = 1;
  026F    1283    CLRB	0x3,5
  0270    1485    SETB	0x5,1
342:                      TRISA &= ~BIT(1);
  0271    1683    SETB	0x3,5
  0272    1085    CLRB	0x5,1
343:                  }
344:                  if (step == 2)
  0273    3002    LDIA	0x2
  0274    1283    CLRB	0x3,5
  0275    0646    XORA	0x46
  0276    1D03    SNZB	0x3,2
  0277    2A7E    JP	0x27E
345:                  {
346:                      if (led_index & LED_INDEX_9)//GREEN
  0278    1C21    SNZB	0x21,0
  0279    2A7D    JP	0x27D
347:                      {
348:                          IO_LED4 = 0;
  027A    1185    CLRB	0x5,3
349:                          TRISA &= ~BIT(3);
  027B    1683    SETB	0x3,5
  027C    1185    CLRB	0x5,3
350:                      }
351:                      IO_LED3 = 1;
352:                      TRISA &= ~BIT(2);
  027D    2290    CALL	0x290
353:                  }
354:                  if (step == 3)
  027E    3003    LDIA	0x3
  027F    1283    CLRB	0x3,5
  0280    0646    XORA	0x46
  0281    1D03    SNZB	0x3,2
  0282    2A89    JP	0x289
355:                  {
356:                      if (led_index & LED_INDEX_10)//RED
  0283    1CA1    SNZB	0x21,1
  0284    2A88    JP	0x288
357:                      {
358:                          IO_LED5 = 0;
  0285    1205    CLRB	0x5,4
359:                          TRISA &= ~BIT(4);
  0286    1683    SETB	0x3,5
  0287    1205    CLRB	0x5,4
360:                      }
361:                      IO_LED3 = 1;
362:                      TRISA &= ~BIT(2);
  0288    2290    CALL	0x290
363:                  }
364:                  step++;
  0289    1283    CLRB	0x3,5
  028A    0AC6    INCR	0x46
365:                  if (step > 3)
  028B    3004    LDIA	0x4
  028C    0246    SUBA	0x46
  028D    1803    SZB	0x3,0
366:                  {
367:                      step = 0;
  028E    01C6    CLR	0x46
  028F    0008    RET
368:                  }
369:              }
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_water_process.c ----------------------------------------------------------------------
1:                 #include "main.h"
2:                
3:                uint8_t water_work_step;
4:                uint8_t CntWaterDrive;
5:                uint8_t MotorWaterDuty;
6:                
7:                volatile water_work_state_t water_work_state =  WATER_WORK_STATE_POWEROFF;
8:                app_process_water_mode_t water_work_mode = 
9:                {
10:                   WATER_WORK_MODE_THREE,0,0,0
11:               };
12:               app_timer_t app_water_timer = 
13:               {
14:               	0
15:               };
16:               
17:               void app_process_set_water_state(water_work_state_t states)
18:               {
19:                   water_work_state = states;
  07DB    00EC    LD	0x6C,A
20:                   water_work_step = 0;
  07DC    01BE    CLR	0x3E
  07DD    0008    RET
21:               }
22:               
23:               void water_motor()
24:               {
25:                   if (water_work_mode.water_mode == WATER_WORK_MODE_ONE)
  0683    0B61    SZDECA	0x61
  0684    2E87    JP	0x687
26:                   {
27:                       // MotorWaterDuty=41;
28:                       MotorWaterDuty=36;
  0685    3024    LDIA	0x24
  0686    00BC    LD	0x3C,A
29:                   }
30:                   if (water_work_mode.water_mode == WATER_WORK_MODE_TWO)
  0687    3002    LDIA	0x2
  0688    0661    XORA	0x61
  0689    1D03    SNZB	0x3,2
  068A    2E8D    JP	0x68D
31:                   {
32:                       // MotorWaterDuty=56;
33:                       MotorWaterDuty=51;
  068B    3033    LDIA	0x33
  068C    00BC    LD	0x3C,A
34:                   }
35:                   if (water_work_mode.water_mode == WATER_WORK_MODE_THREE)
  068D    3003    LDIA	0x3
  068E    0661    XORA	0x61
  068F    1D03    SNZB	0x3,2
  0690    2E93    JP	0x693
36:                   {
37:                       // MotorWaterDuty=71;
38:                       MotorWaterDuty=66;
  0691    3042    LDIA	0x42
  0692    00BC    LD	0x3C,A
39:                   }
40:                   if (water_work_mode.water_mode == WATER_WORK_MODE_FOUR)
  0693    3004    LDIA	0x4
  0694    0661    XORA	0x61
  0695    1D03    SNZB	0x3,2
  0696    2E99    JP	0x699
41:                   {
42:                       // MotorWaterDuty=86;
43:                       MotorWaterDuty=81;
  0697    3051    LDIA	0x51
  0698    00BC    LD	0x3C,A
44:                   }
45:                   if (water_work_mode.water_mode == WATER_WORK_MODE_FIVE)
  0699    3005    LDIA	0x5
  069A    0661    XORA	0x61
  069B    1D03    SNZB	0x3,2
  069C    2E9F    JP	0x69F
46:                   {
47:                       // MotorWaterDuty=101;
48:                       MotorWaterDuty=96;
  069D    3060    LDIA	0x60
  069E    00BC    LD	0x3C,A
49:                   }
50:                   water_work_mode.water_mode_out_put = water_work_mode.water_mode;
  069F    0861    LD	A,0x61
  06A0    00E2    LD	0x62,A
  06A1    0008    RET
51:               }
52:               
53:               // void app_process_set_water_mode_init()
54:               // {
55:               //     app_led_water_mode_set();
56:               //     water_motor();
57:               // }
58:               
59:               void app_process_set_water_mode_next(void)
60:               {
61:                   water_work_mode.water_mode++;
  07AC    0AE1    INCR	0x61
62:                   if (water_work_mode.water_mode > WATER_WORK_MODE_FIVE)
  07AD    0261    SUBA	0x61
  07AE    1C03    SNZB	0x3,0
  07AF    0008    RET
63:                   {
64:                       water_work_mode.water_mode = WATER_WORK_MODE_ONE;
  07B0    01E1    CLR	0x61
  07B1    0AE1    INCR	0x61
  07B2    0008    RET
65:                   }
66:                   // app_led_water_mode_set();
67:                   // if (water_work_state == WATER_WORK_STATE_WORKING)
68:                   // {
69:                   //     water_motor();
70:                   // }
71:               }
72:               
73:               void MotorWaterDrive()
74:               {
75:                   if(water_work_mode.water_mode_out_put == WATER_WORK_MODE_IDEL)
  06EE    1283    CLRB	0x3,5
  06EF    0862    LD	A,0x62
  06F0    1D03    SNZB	0x3,2
  06F1    2EF4    JP	0x6F4
76:                   {
77:                       MotorWaterOff;
  06F2    1285    CLRB	0x5,5
78:                       return;
  06F3    0008    RET
79:                   }
80:                   CntWaterDrive++;
  06F4    0ABD    INCR	0x3D
81:                   if(CntWaterDrive==1)
  06F5    0B3D    SZDECA	0x3D
  06F6    2EF8    JP	0x6F8
82:                   {
83:                   MotorWaterOn;
  06F7    1685    SETB	0x5,5
84:                   }
85:                   if(CntWaterDrive==MotorWaterDuty)
  06F8    083D    LD	A,0x3D
  06F9    063C    XORA	0x3C
  06FA    1903    SZB	0x3,2
86:                   {
87:                   MotorWaterOff;
  06FB    1285    CLRB	0x5,5
88:                   }	 
89:                   if(CntWaterDrive>99)
  06FC    3064    LDIA	0x64
  06FD    023D    SUBA	0x3D
  06FE    1803    SZB	0x3,0
90:                   {
91:                   CntWaterDrive=0;
  06FF    01BD    CLR	0x3D
  0700    0008    RET
92:                   }		
93:               }
94:               
95:               void app_process_water_working()
96:               {
97:                    if (!water_work_step)
  063B    083E    LD	A,0x3E
  063C    1D03    SNZB	0x3,2
  063D    2E40    JP	0x640
98:                   {
99:                       water_work_step++;
  063E    0ABE    INCR	0x3E
100:                  }
  063F    0008    RET
101:                  else
102:                  {
103:                      water_work_mode.water_mode_count++;
  0640    0AE3    INCR	0x63
  0641    1903    SZB	0x3,2
  0642    0AE4    INCR	0x64
104:                      if (water_work_mode.water_mode_count == SECOND(30))
  0643    30B8    LDIA	0xB8
  0644    0663    XORA	0x63
  0645    300B    LDIA	0xB
  0646    1903    SZB	0x3,2
  0647    0664    XORA	0x64
  0648    1D03    SNZB	0x3,2
  0649    2E4C    JP	0x64C
105:                      {
106:                          water_work_mode.water_mode_out_put = WORK_MODE_IDEL;
  064A    01E2    CLR	0x62
107:                      }
  064B    0008    RET
108:                      else if (water_work_mode.water_mode_count >= SECOND(30) + MS(200))
  064C    300B    LDIA	0xB
  064D    0264    SUBA	0x64
  064E    30CC    LDIA	0xCC
  064F    1903    SZB	0x3,2
  0650    0263    SUBA	0x63
  0651    1C03    SNZB	0x3,0
  0652    0008    RET
  0653    3004    LDIA	0x4
109:                      {
110:                          water_work_mode.water_mode_count = 0;
  0654    01E3    CLR	0x63
  0655    01E4    CLR	0x64
111:              			water_work_mode.times++;
  0656    0AE5    INCR	0x65
112:              			if(water_work_mode.times >=  4)   
  0657    0265    SUBA	0x65
  0658    1C03    SNZB	0x3,0
  0659    2E61    JP	0x661
113:              			{
114:              				water_work_mode.times = 0;
  065A    01E5    CLR	0x65
115:                              if (app_charge.Remind)
  065B    1683    SETB	0x3,5
  065C    1E20    SNZB	0x20,4
  065D    2E5F    JP	0x65F
116:                              {
117:                                  app_charge.flag_remind_delay_10s = 1;
118:              				    app_charge.remind_delay_10s_timer = 0;
  065E    2558    CALL	0x558
119:                              }
120:                                  //关机
121:                              app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  065F    3000    LDIA	0x0
  0660    2FD9    JP	0x7D9
122:                          }
123:                          else
124:                          {
125:                              water_work_mode.water_mode_out_put = water_work_mode.water_mode;
  0661    0861    LD	A,0x61
  0662    00E2    LD	0x62,A
  0663    0008    RET
126:                          }
127:                      }
128:                  }
129:              }
130:              
131:              void water_turn_off()
132:              {
133:                  water_work_mode.water_mode_count = 0;
  0792    01E3    CLR	0x63
  0793    01E4    CLR	0x64
134:                  water_work_mode.times = 0;
  0794    01E5    CLR	0x65
135:                  //关电机
136:                  water_work_mode.water_mode_out_put = WATER_WORK_MODE_IDEL;
  0795    01E2    CLR	0x62
137:                  //关灯
138:                  set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0796    00D3    LD	0x53,A
  0797    01D4    CLR	0x54
  0798    01D5    CLR	0x55
  0799    2DE4    JP	0x5E4
139:              }
140:              
141:              void app_process_water_workoff()
142:              {
143:                  water_turn_off();
  07E2    2F91    JP	0x791
144:              }
145:              
146:              static uint16_t water_mode_led_cnt;
147:              void app_process_water_mdoe_led()
148:              {
149:                   if (!water_work_step)
  06A2    083E    LD	A,0x3E
  06A3    1D03    SNZB	0x3,2
  06A4    2EAB    JP	0x6AB
150:                  {
151:                      water_mode_led_cnt = SECOND(10);
  06A5    30E8    LDIA	0xE8
  06A6    00A4    LD	0x24,A
  06A7    3003    LDIA	0x3
  06A8    00A5    LD	0x25,A
152:                      water_work_step++;
  06A9    0ABE    INCR	0x3E
153:                  }
  06AA    0008    RET
154:                  else
155:                  {
156:                      water_work_mode.water_mode_count++;
  06AB    0AE3    INCR	0x63
  06AC    1903    SZB	0x3,2
  06AD    0AE4    INCR	0x64
157:                      if (water_mode_led_cnt)
  06AE    0824    LD	A,0x24
  06AF    0425    ORA	0x25
  06B0    1903    SZB	0x3,2
  06B1    0008    RET
158:                      {
159:                          water_mode_led_cnt--;
  06B2    3001    LDIA	0x1
  06B3    02A4    SUBR	0x24
  06B4    3000    LDIA	0x0
  06B5    1C03    SNZB	0x3,0
  06B6    03A5    DECR	0x25
  06B7    02A5    SUBR	0x25
160:                          if (!water_mode_led_cnt)
  06B8    0824    LD	A,0x24
  06B9    0425    ORA	0x25
  06BA    1D03    SNZB	0x3,2
  06BB    0008    RET
161:                          {
162:                              //关机
163:                              app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  06BC    3000    LDIA	0x0
  06BD    2FD9    JP	0x7D9
164:                          }
165:                      }
166:                  }
167:              }
168:              
169:              void app_water_process_work()
170:              {
171:                  switch (water_work_state)
  0744    086C    LD	A,0x6C
  0745    0084    LD	0x4,A
  0746    3004    LDIA	0x4
  0747    0204    SUBA	0x4
  0748    1803    SZB	0x3,0
  0749    0008    RET
  074A    3007    LDIA	0x7
  074B    008A    LD	0xA,A
  074C    30DE    LDIA	0xDE
  074D    0704    ADDA	0x4
  074E    0082    LD	0x2,A
  074F    0008    RET
172:                  {
173:                  case WATER_WORK_STATE_WORKING:
174:                      app_process_water_working();
  0750    2E3B    JP	0x63B
175:                      break;
176:                  case WATER_WORK_STATE_POWEROFF:
177:                      app_process_water_workoff();
  0751    2F91    JP	0x791
178:                      break;
179:                  case WATER_WORK_STATE_MODE_LED:
180:                      app_process_water_mdoe_led();
  0752    2EA2    JP	0x6A2
181:                      break;
182:                  
183:                  default:
184:                      break;
185:                  }
186:              }
187:              
188:              
189:              
190:              
191:              
192:              
193:              
194:              
195:              
196:              
197:              
198:              
199:              
200:              
201:              
202:              
203:              
204:              
205:              
206:              
207:              
208:              
209:              
210:              
211:              
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_process.c ----------------------------------------------------------------------
1:                 #include "main.h"
2:                
3:                uint8_t work_step;
4:                volatile work_state_t app_work_state =  WORK_STATE_POWEROFF;
5:                uint16_t bat_remind_timer;	
6:                
7:                app_process_mode_t work_mode = 
8:                {
9:                    WORK_MODE_TWO,0,0,0
10:                   // WORK_MODE_ONE,
11:                   // WORK_MODE_ONE
12:               };
13:               
14:               //uint8_t power_off_led_timer;
15:               //uint8_t blink_cnt;
16:               
17:               
18:               
19:               bit flag_old_mode;
20:               
21:               app_timer_t app_timer = 
22:               {
23:               	0
24:               };
25:               
26:               void turn_off()//这是牙刷的
27:               {
28:               	work_mode.work_mode_count = 0;
29:               	work_mode.times = 0;
30:                   work_mode.mode_out_put = WORK_MODE_IDEL;
31:               	set_led_state(LED_INDEX_1 | LED_INDEX_2 | LED_INDEX_3, LED_STATE_OFF);
32:               }
33:               
34:               void app_process_set_work_state(work_state_t states)
  07D4    1283    CLRB	0x3,5
  07D5    00D3    LD	0x53,A
35:               {
36:                   app_work_state = states;
  07D6    00ED    LD	0x6D,A
37:                   work_step = 0;
  07D7    01C4    CLR	0x44
  07D8    0008    RET
38:               }
39:               
40:               u16 times;
41:               void app_process_working()
42:               {
43:                   if (!work_step)
  052D    0844    LD	A,0x44
  052E    1D03    SNZB	0x3,2
  052F    2D32    JP	0x532
44:                   {
45:                       //turn_off();
46:                       work_step++;
  0530    0AC4    INCR	0x44
47:                   }
  0531    0008    RET
48:                   else
49:                   {
50:                       work_chang_timing();//5s      
  0532    26D8    CALL	0x6D8
51:                       work_mode.work_mode_count++;
  0533    1283    CLRB	0x3,5
  0534    0AE8    INCR	0x68
  0535    1903    SZB	0x3,2
  0536    0AE9    INCR	0x69
52:                       if (work_mode.work_mode_count == SECOND(30))
  0537    30B8    LDIA	0xB8
  0538    0668    XORA	0x68
  0539    300B    LDIA	0xB
  053A    1903    SZB	0x3,2
  053B    0669    XORA	0x69
  053C    1D03    SNZB	0x3,2
  053D    2D40    JP	0x540
53:                       {
54:                           work_mode.mode_out_put = WORK_MODE_IDEL;
  053E    01E7    CLR	0x67
55:                       }
  053F    0008    RET
56:                       else if (work_mode.work_mode_count >= SECOND(30) + MS(200))
  0540    300B    LDIA	0xB
  0541    0269    SUBA	0x69
  0542    30CC    LDIA	0xCC
  0543    1903    SZB	0x3,2
  0544    0268    SUBA	0x68
  0545    1C03    SNZB	0x3,0
  0546    0008    RET
  0547    3004    LDIA	0x4
57:                       {
58:                           work_mode.work_mode_count = 0;
  0548    01E8    CLR	0x68
  0549    01E9    CLR	0x69
59:               			work_mode.times++;
  054A    0AEA    INCR	0x6A
60:               			if(work_mode.times >=  4)   
  054B    026A    SUBA	0x6A
  054C    1C03    SNZB	0x3,0
  054D    2D55    JP	0x555
61:               			{
62:               				work_mode.times = 0;
  054E    01EA    CLR	0x6A
63:                               if (app_charge.Remind)
  054F    1683    SETB	0x3,5
  0550    1E20    SNZB	0x20,4
  0551    2D53    JP	0x553
64:                               {
65:                                   app_charge.flag_remind_delay_10s = 1;
66:               				    app_charge.remind_delay_10s_timer = 0;
  0552    2558    CALL	0x558
67:                               }
68:                               app_process_set_work_state(WORK_STATE_POWEROFF);
  0553    3000    LDIA	0x0
  0554    2FD4    JP	0x7D4
69:                           }
70:                           else
71:                           {
72:                               work_mode.mode_out_put = work_mode.mode;
  0555    0866    LD	A,0x66
  0556    00E7    LD	0x67,A
  0557    0008    RET
73:                           }
74:                       }
75:                   }
76:               }
77:               
78:               void app_process_power_off()
  079A    3007    LDIA	0x7
79:               {
80:                   work_mode.work_mode_count = 0;
  079B    01E8    CLR	0x68
  079C    01E9    CLR	0x69
81:               	work_mode.times = 0;
  079D    01EA    CLR	0x6A
82:                   work_mode.mode_out_put = WORK_MODE_IDEL;
  079E    01E7    CLR	0x67
83:               	set_led_state(LED_INDEX_1 | LED_INDEX_2 | LED_INDEX_3, LED_STATE_OFF);
  079F    00D3    LD	0x53,A
  07A0    01D4    CLR	0x54
  07A1    01D5    CLR	0x55
  07A2    2DE4    JP	0x5E4
84:               }
85:               
86:               void app_process_go_to_sleep()
87:               {
88:                   if (app_work_state == WORK_STATE_POWEROFF && water_work_state == WATER_WORK_STATE_POWEROFF && !app_charge.flag_remind_delay_10s && !app_charge.LowLed)
  0712    086D    LD	A,0x6D
  0713    1D03    SNZB	0x3,2
  0714    2F20    JP	0x720
  0715    086C    LD	A,0x6C
  0716    1D03    SNZB	0x3,2
  0717    2F20    JP	0x720
  0718    1683    SETB	0x3,5
  0719    0822    LD	A,0x22
  071A    1D03    SNZB	0x3,2
  071B    2F20    JP	0x720
  071C    0827    LD	A,0x27
  071D    1D03    SNZB	0x3,2
  071E    2F20    JP	0x720
89:                   {
90:                       GotoSleep();
  071F    2BD5    JP	0x3D5
91:                   }
92:                   else
93:                   {
94:                       CntSleep = 0;
  0720    1283    CLRB	0x3,5
  0721    01C5    CLR	0x45
  0722    0008    RET
95:                   }
96:               }
97:               
98:               
99:               void app_process_charing()
100:              {
101:                 if (!work_step)
  0753    0844    LD	A,0x44
  0754    1D03    SNZB	0x3,2
  0755    0008    RET
102:                  {
103:                      app_process_power_off();
  0756    279A    CALL	0x79A
104:                      app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  0757    3000    LDIA	0x0
  0758    27D9    CALL	0x7D9
105:                      app_timer.charge_to_oldmode_count = SECOND(8);
  0759    3020    LDIA	0x20
  075A    1683    SETB	0x3,5
  075B    00BA    LD	0x3A,A
  075C    3003    LDIA	0x3
  075D    00BB    LD	0x3B,A
106:                      work_step++;
  075E    1283    CLRB	0x3,5
  075F    0AC4    INCR	0x44
107:                  }
  0760    0008    RET
108:                  else
109:                  {
110:                      // charge_to_oldmode_timing();
111:                      // if (app_charge.flag_charge_force_full_24hour)
112:                      // {
113:                      //     set_led_state(LED_INDEX_9 | LED_INDEX_10,LED_STATE_OFF);
114:                      // }
115:                      // else if (app_charge.FullCharge || app_charge.ForceFullCharge)
116:                      // {
117:                      //     set_led_state(LED_INDEX_9,LED_STATE_ON);
118:                      //     set_led_state(LED_INDEX_10,LED_STATE_OFF);
119:                      // }
120:                      // else
121:                      // {
122:                      //     set_led_state(LED_INDEX_10,LED_STATE_ON);
123:                      //     set_led_state(LED_INDEX_9,LED_STATE_OFF);
124:                      // }
125:              	}
126:              }
127:              
128:              // void process_lowBat_led()
129:              // {
130:              //     switch (work_step)
131:              //     {
132:              //     case 0:
133:              //         flag_discharge_once = 0;
134:              //         flag_old_mode = 0;
135:              //         turn_off();
136:              //         work_step++;
137:              //         power_off_led_timer = 0;
138:              //         blink_cnt = 6;//  烁十  
139:              //         break;
140:              //     case 1:
141:              //         power_off_led_timer++;
142:              //         if (power_off_led_timer / MS(300))
143:              //         {
144:              //             power_off_led_timer = 0;
145:              //             if (blink_cnt)
146:              //             {
147:              //                 blink_cnt--;
148:              //                 if (!blink_cnt)
149:              //                 {
150:              //                     work_step++;
151:              //                 }
152:              //             }
153:              //         }
154:              //         break;
155:              //     case 2:
156:              //         app_process_set_work_state(WORK_STATE_POWEROFF);
157:              //         break;
158:              //     default:
159:              //         break;
160:              //     }
161:              // }
162:              
163:              // void process_old_mode_run()
164:              // {
165:              //     static u16 old_mode_count;
166:              //     switch (work_step)
167:              //     {
168:              //     case 0:
169:              //         turn_off();
170:              //         work_step++;
171:              //         break;
172:              //     case 1:
173:              //         old_mode_count++;
174:              //         if (old_mode_count == MINUTE(2))
175:              //         {
176:              //             work_mode.mode_out_put = work_mode.mode;
177:              //         }
178:              //         else if(old_mode_count >= MINUTE(2))
179:              // 		{
180:              //             work_mode.mode_out_put = WORK_MODE_IDEL;
181:              //             INA = 0;
182:              //             INB = 0;
183:              // 			old_mode_count = 0;
184:              // 		}
185:              //         break;
186:              //     default:
187:              //         break;
188:              //     }
189:              // }
190:              
191:              void process_null()
192:              {
193:              
194:              }
195:              
196:              work_state_action_t work_state_action_tab[] = 
197:              {
198:                  {WORK_STATE_POWEROFF,app_process_power_off},
199:                  {WORK_STATE_WORKING,app_process_working},
200:                  {WORK_STATE_CHARGING,app_process_charing},
201:                  //{WORK_STATE_CHARGED,process_charged},
202:                  //{WORK_STATE_REMIND_CHARGE,process_remind_charge},
203:                  //{WORK_STATE_POWEROFF_MODE_LED,process_power_off_mode_led},
204:                  //{WORK_STATE_LOWBAT_LED,process_lowBat_led},
205:                  //{WORK_STATE_OLD_MODE_RUN,process_old_mode_run},
206:                  //{WORK_STATE_NULL,process_null},
207:              };
208:              
209:              void app_process_work()
210:              {
211:              	// uint8_t i = 0;
212:                  // for ( ; i < SIZE_ARRAY(work_state_action_tab); i++)
213:                  // {
214:                  //     if(work_state_action_tab[i].states == app_work_state)
215:                  //     {
216:                  //         work_state_action_tab[i].cb();
217:                  //         break;
218:                  //     }
219:                  // }
220:                  if (app_work_state == WORK_STATE_POWEROFF)
  076F    086D    LD	A,0x6D
  0770    1D03    SNZB	0x3,2
  0771    2F73    JP	0x773
221:                  {
222:                      app_process_power_off();
  0772    279A    CALL	0x79A
223:                  }
224:                  if (app_work_state == WORK_STATE_WORKING)
  0773    0B6D    SZDECA	0x6D
  0774    2F76    JP	0x776
225:                  {
226:                      app_process_working();
  0775    252D    CALL	0x52D
227:                  }
228:                  if (app_work_state == WORK_STATE_CHARGING)
  0776    3002    LDIA	0x2
  0777    066D    XORA	0x6D
  0778    1D03    SNZB	0x3,2
  0779    0008    RET
229:                  {
230:                      app_process_charing();
  077A    2F53    JP	0x753
231:                  }
232:                  // if (app_work_state == WORK_STATE_OLD_MODE_RUN)
233:                  // {
234:                  //     process_old_mode_run();
235:                  // }
236:              }
237:              
238:              
239:              
240:              
241:              
242:              
243:              
244:              
245:              
246:              
247:              
248:              
249:              
250:              
251:              
252:              
253:              
254:              
255:              
256:              
257:              
258:              
259:              
260:              
261:              
262:              
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_timer.c ----------------------------------------------------------------------
1:                #include "main.h"
2:                
3:                void work_chang_timing()	
4:                {
5:                	if (app_timer.work_updown_count)
  06D8    1683    SETB	0x3,5
  06D9    0837    LD	A,0x37
  06DA    0436    ORA	0x36
  06DB    0435    ORA	0x35
  06DC    0434    ORA	0x34
  06DD    1903    SZB	0x3,2
  06DE    0008    RET
6:                	{
7:                		app_timer.work_updown_count--;
  06DF    3001    LDIA	0x1
  06E0    02B4    SUBR	0x34
  06E1    3000    LDIA	0x0
  06E2    1C03    SNZB	0x3,0
  06E3    3001    LDIA	0x1
  06E4    02B5    SUBR	0x35
  06E5    3000    LDIA	0x0
  06E6    1C03    SNZB	0x3,0
  06E7    3001    LDIA	0x1
  06E8    02B6    SUBR	0x36
  06E9    3000    LDIA	0x0
  06EA    1C03    SNZB	0x3,0
  06EB    3001    LDIA	0x1
  06EC    02B7    SUBR	0x37
  06ED    0008    RET
8:                		// if (!app_timer.work_updown_count)
9:                		// {
10:               			// app_process_set_work_state(WORK_STATE_POWEROFF);
11:               		// }
12:               	}	
13:               }
14:               
15:               void charge_to_oldmode_timing()	
16:               {
17:               	if (app_timer.charge_to_oldmode_count)
18:               	{
19:               		app_timer.charge_to_oldmode_count--;
20:               		// if (!app_timer.charge_to_oldmode_count)
21:               		// {
22:               
23:               		// }
24:               	}	
25:               }
26:               
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
36:               
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_key.c ----------------------------------------------------------------------
1:                #include "main.h"
2:                
3:                key_type_t key_brush_pwrtype = KEY_TYPE_IDLE;
4:                key_type_t key_water_pwr_type = KEY_TYPE_IDLE;
5:                key_type_t key_water_mode_type = KEY_TYPE_IDLE;
6:                //key_type_t key_mode_type = KEY_TYPE_IDLE;
7:                
8:                //bit flag_no_charge;
9:                
10:               volatile uint KeyPressCnt1 = 0;
11:               volatile uchar KeyRelaxCnt1 = 0;
12:               
13:               volatile uint KeyPressCnt2 = 0;
14:               volatile uchar KeyRelaxCnt2 = 0;
15:               
16:               volatile uint KeyPressCnt3 = 0;
17:               volatile uchar KeyRelaxCnt3 = 0;
18:               
19:               void key_brush_pwr_check()
20:               {
21:               	if(!IO_KEY_BRUSH_PWR)
  0487    1283    CLRB	0x3,5
  0488    1906    SZB	0x6,2
  0489    2CA6    JP	0x4A6
22:               	{
23:               		if(KeyPressCnt1 < 100)
  048A    3000    LDIA	0x0
  048B    0235    SUBA	0x35
  048C    3064    LDIA	0x64
  048D    1903    SZB	0x3,2
  048E    0234    SUBA	0x34
  048F    1803    SZB	0x3,0
  0490    2C94    JP	0x494
24:               		{
25:               			KeyPressCnt1++;
  0491    0AB4    INCR	0x34
  0492    1903    SZB	0x3,2
  0493    0AB5    INCR	0x35
26:               		}
27:               		if(KeyPressCnt1 >= 2)
  0494    3000    LDIA	0x0
  0495    0235    SUBA	0x35
  0496    3002    LDIA	0x2
  0497    1903    SZB	0x3,2
  0498    0234    SUBA	0x34
  0499    1803    SZB	0x3,0
28:               		{
29:               			KeyRelaxCnt1 = 0;
  049A    01C9    CLR	0x49
30:               		}
31:               		// if (KeyPressCnt1 == 50)   //diy
32:               		// {
33:               		// 	key_brush_pwrtype = KEY_TYPE_LONG;
34:               		// }
35:               		if(KeyPressCnt1 == 100)  //长按5s
  049B    3064    LDIA	0x64
  049C    0634    XORA	0x34
  049D    0435    ORA	0x35
  049E    1D03    SNZB	0x3,2
  049F    0008    RET
36:               		{	
37:               			KeyPressCnt1 = 101;
  04A0    3065    LDIA	0x65
  04A1    00B4    LD	0x34,A
  04A2    01B5    CLR	0x35
38:               			//如果第二个按键没按下，这里有效
39:               			key_brush_pwrtype = KEY_TYPE_LONG;
  04A3    3002    LDIA	0x2
  04A4    00CC    LD	0x4C,A
  04A5    0008    RET
40:               		}
41:               	}
42:               	else
43:               	{
44:               		if(KeyRelaxCnt1 < 2)
  04A6    3002    LDIA	0x2
  04A7    0249    SUBA	0x49
  04A8    1803    SZB	0x3,0
  04A9    2CAC    JP	0x4AC
45:               		{
46:               			KeyRelaxCnt1++;
  04AA    0AC9    INCR	0x49
47:               		}
  04AB    0008    RET
48:               		else
49:               		{	
50:               			if(KeyPressCnt1 >= 3 && KeyPressCnt1 <= 50)
  04AC    3000    LDIA	0x0
  04AD    0235    SUBA	0x35
  04AE    3003    LDIA	0x3
  04AF    1903    SZB	0x3,2
  04B0    0234    SUBA	0x34
  04B1    1C03    SNZB	0x3,0
  04B2    2CBC    JP	0x4BC
  04B3    3000    LDIA	0x0
  04B4    0235    SUBA	0x35
  04B5    3033    LDIA	0x33
  04B6    1903    SZB	0x3,2
  04B7    0234    SUBA	0x34
  04B8    1803    SZB	0x3,0
  04B9    2CBC    JP	0x4BC
51:               			{
52:               				//单击
53:                               key_brush_pwrtype = KEY_TYPE_SHORT;
  04BA    3005    LDIA	0x5
  04BB    00CC    LD	0x4C,A
54:               			}
55:               			KeyPressCnt1 = 0;
  04BC    01B4    CLR	0x34
  04BD    01B5    CLR	0x35
  04BE    0008    RET
56:               		}
57:               	}
58:               } 
59:               
60:               void key_water_pwr_check()
61:               {
62:               	if(!IO_KEY_WATER_PWR)
  04BF    1806    SZB	0x6,0
  04C0    2CDD    JP	0x4DD
63:               	{
64:               		if(KeyPressCnt2 < 200)
  04C1    3000    LDIA	0x0
  04C2    0233    SUBA	0x33
  04C3    30C8    LDIA	0xC8
  04C4    1903    SZB	0x3,2
  04C5    0232    SUBA	0x32
  04C6    1803    SZB	0x3,0
  04C7    2CCB    JP	0x4CB
65:               		{
66:               			KeyPressCnt2++;
  04C8    0AB2    INCR	0x32
  04C9    1903    SZB	0x3,2
  04CA    0AB3    INCR	0x33
67:               		}
68:               		if(KeyPressCnt2 >= 2)
  04CB    3000    LDIA	0x0
  04CC    0233    SUBA	0x33
  04CD    3002    LDIA	0x2
  04CE    1903    SZB	0x3,2
  04CF    0232    SUBA	0x32
  04D0    1803    SZB	0x3,0
69:               		{
70:               			KeyRelaxCnt2 = 0;
  04D1    01C8    CLR	0x48
71:               		}
72:               		// if (KeyPressCnt1 == 50)   //diy
73:               		// {
74:               		// 	key_water_pwr_type = KEY_TYPE_LONG;
75:               		// }
76:               		if(KeyPressCnt2 == 200)  //长按5s
  04D2    30C8    LDIA	0xC8
  04D3    0632    XORA	0x32
  04D4    0433    ORA	0x33
  04D5    1D03    SNZB	0x3,2
  04D6    0008    RET
77:               		{	
78:               			KeyPressCnt2 = 201;
  04D7    30C9    LDIA	0xC9
  04D8    00B2    LD	0x32,A
  04D9    01B3    CLR	0x33
79:               			//如果第二个按键没按下，这里有效
80:               			key_water_pwr_type = KEY_TYPE_LONG_LONG;
  04DA    3003    LDIA	0x3
  04DB    00CB    LD	0x4B,A
  04DC    0008    RET
81:               		}
82:               	}
83:               	else
84:               	{
85:               		if(KeyRelaxCnt2 < 2)
  04DD    3002    LDIA	0x2
  04DE    0248    SUBA	0x48
  04DF    1803    SZB	0x3,0
  04E0    2CE3    JP	0x4E3
86:               		{
87:               			KeyRelaxCnt2++;
  04E1    0AC8    INCR	0x48
88:               		}
  04E2    0008    RET
89:               		else
90:               		{	
91:               			if(KeyPressCnt2 >= 3 && KeyPressCnt2 <= 50)
  04E3    3000    LDIA	0x0
  04E4    0233    SUBA	0x33
  04E5    3003    LDIA	0x3
  04E6    1903    SZB	0x3,2
  04E7    0232    SUBA	0x32
  04E8    1C03    SNZB	0x3,0
  04E9    2CF3    JP	0x4F3
  04EA    3000    LDIA	0x0
  04EB    0233    SUBA	0x33
  04EC    3033    LDIA	0x33
  04ED    1903    SZB	0x3,2
  04EE    0232    SUBA	0x32
  04EF    1803    SZB	0x3,0
  04F0    2CF3    JP	0x4F3
92:               			{
93:               				//单击
94:                               key_water_pwr_type = KEY_TYPE_SHORT;
  04F1    3005    LDIA	0x5
  04F2    00CB    LD	0x4B,A
95:               			}
96:               			KeyPressCnt2 = 0;
  04F3    01B2    CLR	0x32
  04F4    01B3    CLR	0x33
  04F5    0008    RET
97:               		}
98:               	}
99:               } 
100:              void key_water_mode_check()
101:              {
102:              	if(!IO_KEY_WATER_MODE)
  04F6    1886    SZB	0x6,1
  04F7    2D14    JP	0x514
103:              	{
104:              		if(KeyPressCnt3 < 200)
  04F8    3000    LDIA	0x0
  04F9    0231    SUBA	0x31
  04FA    30C8    LDIA	0xC8
  04FB    1903    SZB	0x3,2
  04FC    0230    SUBA	0x30
  04FD    1803    SZB	0x3,0
  04FE    2D02    JP	0x502
105:              		{
106:              			KeyPressCnt3++;
  04FF    0AB0    INCR	0x30
  0500    1903    SZB	0x3,2
  0501    0AB1    INCR	0x31
107:              		}
108:              		if(KeyPressCnt3 >= 2)
  0502    3000    LDIA	0x0
  0503    0231    SUBA	0x31
  0504    3002    LDIA	0x2
  0505    1903    SZB	0x3,2
  0506    0230    SUBA	0x30
  0507    1803    SZB	0x3,0
109:              		{
110:              			KeyRelaxCnt3 = 0;
  0508    01C7    CLR	0x47
111:              		}
112:              		// if (KeyPressCnt1 == 50)   //diy
113:              		// {
114:              		// 	key_water_mode_type = KEY_TYPE_LONG;
115:              		// }
116:              		if(KeyPressCnt3 == 200)  //长按5s
  0509    30C8    LDIA	0xC8
  050A    0630    XORA	0x30
  050B    0431    ORA	0x31
  050C    1D03    SNZB	0x3,2
  050D    0008    RET
117:              		{	
118:              			KeyPressCnt3 = 201;
  050E    30C9    LDIA	0xC9
  050F    00B0    LD	0x30,A
  0510    01B1    CLR	0x31
119:              			//如果第二个按键没按下，这里有效
120:              			key_water_mode_type = KEY_TYPE_LONG_LONG;
  0511    3003    LDIA	0x3
  0512    00CA    LD	0x4A,A
  0513    0008    RET
121:              		}
122:              	}
123:              	else
124:              	{
125:              		if(KeyRelaxCnt3 < 2)
  0514    3002    LDIA	0x2
  0515    0247    SUBA	0x47
  0516    1803    SZB	0x3,0
  0517    2D1A    JP	0x51A
126:              		{
127:              			KeyRelaxCnt3++;
  0518    0AC7    INCR	0x47
128:              		}
  0519    0008    RET
129:              		else
130:              		{	
131:              			if(KeyPressCnt3 >= 3 && KeyPressCnt3 <= 50)
  051A    3000    LDIA	0x0
  051B    0231    SUBA	0x31
  051C    3003    LDIA	0x3
  051D    1903    SZB	0x3,2
  051E    0230    SUBA	0x30
  051F    1C03    SNZB	0x3,0
  0520    2D2A    JP	0x52A
  0521    3000    LDIA	0x0
  0522    0231    SUBA	0x31
  0523    3033    LDIA	0x33
  0524    1903    SZB	0x3,2
  0525    0230    SUBA	0x30
  0526    1803    SZB	0x3,0
  0527    2D2A    JP	0x52A
132:              			{
133:              				//单击
134:                              key_water_mode_type = KEY_TYPE_SHORT;
  0528    3005    LDIA	0x5
  0529    00CA    LD	0x4A,A
135:              			}
136:              			KeyPressCnt3 = 0;
  052A    01B0    CLR	0x30
  052B    01B1    CLR	0x31
  052C    0008    RET
137:              		}
138:              	}
139:              } 
140:              
141:              void charge_or_lowBat_check()
142:              {
143:                  if (app_charge.Charge)  //充电
  06BE    1683    SETB	0x3,5
  06BF    1C20    SNZB	0x20,0
  06C0    2EC2    JP	0x6C2
144:                  {
145:              		// if (!flag_old_mode)
146:              		// {
147:              		// 	if (key_brush_pwrtype == KEY_TYPE_LONG_LONG)
148:              		// 	{
149:              		// 		if (app_timer.charge_to_oldmode_count)
150:              		// 		{
151:              		// 			flag_old_mode = 1;
152:              		// 			app_process_set_work_state(WORK_STATE_OLD_MODE_RUN); 
153:              		// 			app_process_set_mode_init();
154:              		// 		}
155:              		// 	}
156:              		// }
157:              		key_brush_pwrtype = KEY_TYPE_IDLE;
158:              		key_water_pwr_type = KEY_TYPE_IDLE;
159:              		key_water_mode_type = KEY_TYPE_IDLE;
160:                  } 
  06C1    2ED3    JP	0x6D3
161:                  else if (app_charge.LowPower) //低电
  06C2    0826    LD	A,0x26
  06C3    1903    SZB	0x3,2
  06C4    0008    RET
162:                  {
163:                      if (key_brush_pwrtype || key_water_pwr_type || key_water_mode_type)
  06C5    1283    CLRB	0x3,5
  06C6    084C    LD	A,0x4C
  06C7    1D03    SNZB	0x3,2
  06C8    2ECE    JP	0x6CE
  06C9    084B    LD	A,0x4B
  06CA    1903    SZB	0x3,2
  06CB    084A    LD	A,0x4A
  06CC    1903    SZB	0x3,2
  06CD    0008    RET
164:                      {
165:              			app_charge.LowLed = TURE;
  06CE    1683    SETB	0x3,5
  06CF    01A7    CLR	0x27
  06D0    0AA7    INCR	0x27
166:              			app_charge.LowLed_cnt = 0;
  06D1    01A8    CLR	0x28
167:                          key_brush_pwrtype = KEY_TYPE_IDLE;
168:              			key_water_pwr_type = KEY_TYPE_IDLE;
169:              			key_water_mode_type = KEY_TYPE_IDLE;
  06D2    2ED3    JP	0x6D3
170:                      }
171:                  }
172:              
173:              	// if (!app_charge.Charge)
174:              	// {
175:              	// 	if (flag_old_mode)
176:              	// 	{
177:              	// 		if (key_brush_pwrtype == KEY_TYPE_SHORT)
178:              	// 		{
179:              	// 			key_brush_pwrtype = KEY_TYPE_IDLE;
180:              	// 			app_process_set_work_state(WORK_STATE_POWEROFF);
181:              	// 		}
182:              	// 	}
183:              	// }
184:              	
185:              	
186:              	// if(key_brush_pwrtype == KEY_TYPE_LONG_LONG)
187:              	// {
188:              	// 	key_brush_pwrtype = KEY_TYPE_IDLE;
189:              	// }
190:              }
191:              
192:              void handle_key_pwr()
193:              {
194:                  switch (key_brush_pwrtype)
  0610    2E30    JP	0x630
195:                  {
196:                  case KEY_TYPE_SHORT:
197:              		if (app_work_state == WORK_STATE_POWEROFF || app_charge.flag_remind_delay_10s)
  0611    086D    LD	A,0x6D
  0612    1683    SETB	0x3,5
  0613    1903    SZB	0x3,2
  0614    2E19    JP	0x619
  0615    0822    LD	A,0x22
  0616    1903    SZB	0x3,2
  0617    2E1E    JP	0x61E
198:              		{
199:              			app_charge.flag_remind_delay_10s = 0;
  0618    1683    SETB	0x3,5
  0619    3001    LDIA	0x1
  061A    01A2    CLR	0x22
200:              			app_process_set_work_state(WORK_STATE_WORKING); 
  061B    27D4    CALL	0x7D4
201:              			app_process_set_mode_init();
  061C    277B    CALL	0x77B
202:              		}
  061D    2E39    JP	0x639
203:              		else if (app_work_state == WORK_STATE_WORKING)
  061E    1283    CLRB	0x3,5
  061F    0B6D    SZDECA	0x6D
  0620    2E39    JP	0x639
204:              		{
205:              			// if (app_timer.work_updown_count)
206:              			// {
207:              			// 	app_process_set_mode_next();
208:              			// }
209:              	 		// else
210:              			// {
211:              				if (water_work_state == WATER_WORK_STATE_POWEROFF)
  0621    086C    LD	A,0x6C
  0622    1D03    SNZB	0x3,2
  0623    2E2B    JP	0x62B
212:              				{
213:              					if (app_charge.Remind)
  0624    1683    SETB	0x3,5
  0625    1E20    SNZB	0x20,4
  0626    2E2B    JP	0x62B
214:              					{
215:              						app_charge.flag_remind_delay_10s = 1;
  0627    01A2    CLR	0x22
  0628    0AA2    INCR	0x22
216:              						app_charge.remind_delay_10s_timer = 0;
  0629    01A3    CLR	0x23
  062A    01A4    CLR	0x24
217:              					}
218:              				}
219:              				app_process_set_work_state(WORK_STATE_POWEROFF);
  062B    3000    LDIA	0x0
  062C    27D4    CALL	0x7D4
  062D    2E39    JP	0x639
220:              			// }
221:              		}
222:                      break;
223:              		
224:                  case KEY_TYPE_LONG:
225:              		// if (app_work_state == WORK_STATE_WORKING)
226:              		// {
227:              		// 	if (water_work_state == WATER_WORK_STATE_POWEROFF)
228:              		// 	{
229:              		// 		if (app_charge.Remind)
230:              		// 		{
231:              		// 			app_charge.flag_remind_delay_10s = 1;
232:              		// 			app_charge.remind_delay_10s_timer = 0;
233:              		// 		}
234:              		// 	}
235:              		// 	app_process_set_work_state(WORK_STATE_POWEROFF);
236:              		// }
237:                      app_process_set_mode_next();
  062E    2701    CALL	0x701
238:                      break;
  062F    2E39    JP	0x639
  0630    1283    CLRB	0x3,5
  0631    084C    LD	A,0x4C
  0632    3A02    XORIA	0x2
  0633    1903    SZB	0x3,2
  0634    2E2E    JP	0x62E
  0635    3A07    XORIA	0x7
  0636    1903    SZB	0x3,2
  0637    2E11    JP	0x611
  0638    2E39    JP	0x639
239:                  default:
240:                      break;
241:                  }
242:              	key_brush_pwrtype = KEY_TYPE_IDLE;
  0639    01CC    CLR	0x4C
  063A    0008    RET
243:              }
244:              
245:              void handle_key_water()
246:              {
247:              	switch (key_water_pwr_type)
  038F    2BAF    JP	0x3AF
248:                  {
249:                  case KEY_TYPE_SHORT:
250:              		if (water_work_state == WATER_WORK_STATE_WORKING)
  0390    0B6C    SZDECA	0x6C
  0391    2B9B    JP	0x39B
251:              		{
252:              			if (app_work_state == WORK_STATE_POWEROFF)
  0392    086D    LD	A,0x6D
  0393    1D03    SNZB	0x3,2
  0394    2B99    JP	0x399
253:              			{
254:              				if (app_charge.Remind)
  0395    1683    SETB	0x3,5
  0396    1E20    SNZB	0x20,4
  0397    2B99    JP	0x399
255:              				{
256:              					app_charge.flag_remind_delay_10s = 1;
257:              					app_charge.remind_delay_10s_timer = 0;
  0398    2558    CALL	0x558
258:              				}
259:              			}
260:              			app_process_set_water_state(WATER_WORK_STATE_POWEROFF); 
  0399    3000    LDIA	0x0
  039A    2BAC    JP	0x3AC
261:              		}
262:              		else if (water_work_state == WATER_WORK_STATE_POWEROFF  || app_charge.flag_remind_delay_10s || water_work_state == WATER_WORK_STATE_MODE_LED)//开机
  039B    086C    LD	A,0x6C
  039C    1683    SETB	0x3,5
  039D    1903    SZB	0x3,2
  039E    2BA8    JP	0x3A8
  039F    0822    LD	A,0x22
  03A0    1D03    SNZB	0x3,2
  03A1    2BA7    JP	0x3A7
  03A2    3003    LDIA	0x3
  03A3    1283    CLRB	0x3,5
  03A4    066C    XORA	0x6C
  03A5    1D03    SNZB	0x3,2
  03A6    2BAD    JP	0x3AD
263:              		{
264:              			app_charge.flag_remind_delay_10s = 0;
  03A7    1683    SETB	0x3,5
  03A8    01A2    CLR	0x22
265:              			app_led_water_mode_set();
  03A9    2412    CALL	0x412
266:              			water_motor();
  03AA    2683    CALL	0x683
267:              			app_process_set_water_state(WATER_WORK_STATE_WORKING);
  03AB    3001    LDIA	0x1
  03AC    27D9    CALL	0x7D9
268:              		}
269:              		key_water_pwr_type = KEY_TYPE_IDLE;
  03AD    01CB    CLR	0x4B
270:                      break;
  03AE    2BB4    JP	0x3B4
  03AF    084B    LD	A,0x4B
  03B0    3A05    XORIA	0x5
  03B1    1903    SZB	0x3,2
  03B2    2B90    JP	0x390
  03B3    2BB4    JP	0x3B4
271:              		
272:                  default:
273:                      break;
274:                  }
275:              	key_water_pwr_type = KEY_TYPE_IDLE;
  03B4    01CB    CLR	0x4B
276:              	//----------------------water_mode---------------------------//
277:              	switch (key_water_mode_type)
  03B5    2BCB    JP	0x3CB
278:                  {
279:                  case KEY_TYPE_SHORT:
280:              		if (water_work_state == WATER_WORK_STATE_WORKING)
  03B6    0B6C    SZDECA	0x6C
  03B7    2BBC    JP	0x3BC
281:              		{
282:              			app_process_set_water_mode_next();
  03B8    27AB    CALL	0x7AB
283:              			app_led_water_mode_set();
  03B9    2412    CALL	0x412
284:              			water_motor();
  03BA    2683    CALL	0x683
285:              		}
  03BB    2BC9    JP	0x3C9
286:              		else if (water_work_state == WATER_WORK_STATE_POWEROFF)
  03BC    086C    LD	A,0x6C
287:              		{
288:              			app_process_set_water_state(WATER_WORK_STATE_MODE_LED);
  03BD    3003    LDIA	0x3
  03BE    1D03    SNZB	0x3,2
  03BF    2BC2    JP	0x3C2
  03C0    27D9    CALL	0x7D9
  03C1    2BC8    JP	0x3C8
289:              			app_led_water_mode_set();
  03C2    066C    XORA	0x6C
  03C3    1D03    SNZB	0x3,2
  03C4    2BC9    JP	0x3C9
290:              		}
291:              		else if (water_work_state == WATER_WORK_STATE_MODE_LED)
292:              		{
293:              			app_process_set_water_state(WATER_WORK_STATE_MODE_LED);
  03C5    3003    LDIA	0x3
  03C6    27D9    CALL	0x7D9
294:              			app_process_set_water_mode_next();
  03C7    27AB    CALL	0x7AB
295:              			app_led_water_mode_set();
  03C8    2412    CALL	0x412
296:              		}
297:              		key_water_mode_type = KEY_TYPE_IDLE;
  03C9    01CA    CLR	0x4A
298:                      break;
  03CA    2BD3    JP	0x3D3
  03CB    084A    LD	A,0x4A
  03CC    3A02    XORIA	0x2
  03CD    1903    SZB	0x3,2
  03CE    2BD3    JP	0x3D3
  03CF    3A07    XORIA	0x7
  03D0    1903    SZB	0x3,2
  03D1    2BB6    JP	0x3B6
  03D2    2BD3    JP	0x3D3
299:                  case KEY_TYPE_LONG:
300:              		// app_charge.flag_remind_delay_10s = 0;
301:              		// app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
302:                      break;
303:                  default:
304:                      break;
305:                  }
306:              	key_water_mode_type = KEY_TYPE_IDLE;
  03D3    01CA    CLR	0x4A
  03D4    0008    RET
307:              }
308:              
309:              void app_process_key()
310:              {
311:              	key_brush_pwr_check();
  07C8    2487    CALL	0x487
312:              	key_water_pwr_check();
  07C9    24BF    CALL	0x4BF
313:              	key_water_mode_check();
  07CA    24F6    CALL	0x4F6
314:                  charge_or_lowBat_check();
  07CB    26BE    CALL	0x6BE
315:                  handle_key_pwr();
  07CC    2610    CALL	0x610
316:              	handle_key_water();
  07CD    2B8F    JP	0x38F
317:              }
318:              
319:              
320:              
321:              
322:              
323:              
324:              
325:              
326:              
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_motor.c ----------------------------------------------------------------------
1:                 #include "main.h"
2:                
3:                // work_state_t work_mode = WORK_MODE_IDEL;
4:                // work_state_t work_mode_old_keep;
5:                // volatile unsigned char ModeDuty = 0;
6:                // volatile unsigned char ModeDuty_restore = 0;
7:                // volatile unsigned char Mode2TimeCnt = 0;
8:                // volatile unsigned char TimerDiyShakeDelay;
9:                // unsigned char TimerDiyDelay300ms;
10:               
11:               
12:               u8 low_a;
13:               u8 dead_area1;
14:               
15:               u8 low_b;
16:               u8 dead_area_b1;
17:               u8 dead_area_b2;
18:               
19:               //u8 Period;
20:               //u8 DutyLow;
21:               //u8 DutyHigh;
22:               //u8 motor_time;
23:               
24:               MOTOR_InitTypeDef MOTOR_InitStruct = { 0 };
25:               //---------------------------------------------
26:               
27:               app_motor_pwm_pram_t app_motor_pwm_pram = 
28:               {
29:                   0
30:               };
31:               
32:               static volatile uint16_t motor_fix_cnt;
33:               
34:               void app_process_set_mode_init()
35:               {
36:                   work_mode.mode_out_put = work_mode.mode;
  077B    0866    LD	A,0x66
  077C    00E7    LD	0x67,A
37:                   app_timer.work_updown_count = SECOND(5);
  077D    3001    LDIA	0x1
  077E    1683    SETB	0x3,5
  077F    01B7    CLR	0x37
  0780    01B6    CLR	0x36
  0781    00B5    LD	0x35,A
  0782    30F4    LDIA	0xF4
  0783    00B4    LD	0x34,A
38:                   app_led_mode_set();
  0784    25B8    CALL	0x5B8
39:               	app_process_motor_duty();
  0785    2AF6    JP	0x2F6
40:               }
41:               
42:               void app_process_set_mode_next(void)
  0701    3004    LDIA	0x4
43:               {
44:                   work_mode.mode++;
  0702    1283    CLRB	0x3,5
  0703    0AE6    INCR	0x66
45:               	if (work_mode.mode > WORK_MODE_THREE)
  0704    0266    SUBA	0x66
  0705    1C03    SNZB	0x3,0
  0706    2F09    JP	0x709
46:               	{
47:               		work_mode.mode = WORK_MODE_ONE;
  0707    01E6    CLR	0x66
  0708    0AE6    INCR	0x66
48:               	}
49:                   app_timer.work_updown_count = SECOND(5);
  0709    3001    LDIA	0x1
  070A    1683    SETB	0x3,5
  070B    01B7    CLR	0x37
  070C    01B6    CLR	0x36
  070D    00B5    LD	0x35,A
  070E    30F4    LDIA	0xF4
  070F    00B4    LD	0x34,A
50:                   app_led_mode_set();
  0710    25B8    CALL	0x5B8
51:               	app_process_motor_duty();
  0711    2AF6    JP	0x2F6
52:               }
53:               
54:               void app_process_motor_duty()
55:               {
56:               	 switch (work_mode.mode)
  02F6    2B0B    JP	0x30B
57:                   {
58:                   case WORK_MODE_ONE:
59:                       MOTOR_InitStruct.Period = MOTOR_155Hz;
  02F7    307F    LDIA	0x7F
  02F8    1683    SETB	0x3,5
  02F9    00BC    LD	0x3C,A
60:                       MOTOR_InitStruct.DutyLow = MOTOR_155Hz_Duty_100;
  02FA    3033    LDIA	0x33
  02FB    2B05    JP	0x305
61:                       MOTOR_InitStruct.DutyHigh = MOTOR_155Hz_Duty_100;
62:                       work_mode.mode_out_put = work_mode.mode;
63:                       break;
64:                   case WORK_MODE_TWO:
65:                       MOTOR_InitStruct.Period = MOTOR_200Hz;
  02FC    3062    LDIA	0x62
  02FD    1683    SETB	0x3,5
  02FE    00BC    LD	0x3C,A
66:                       MOTOR_InitStruct.DutyLow = MOTOR_200Hz_Duty_90;
  02FF    3027    LDIA	0x27
  0300    2B05    JP	0x305
67:                       MOTOR_InitStruct.DutyHigh = MOTOR_200Hz_Duty_90;
68:                        work_mode.mode_out_put = work_mode.mode;
69:                       break;
70:                   case WORK_MODE_THREE:
71:                       MOTOR_InitStruct.Period = MOTOR_260Hz;
  0301    304B    LDIA	0x4B
  0302    1683    SETB	0x3,5
  0303    00BC    LD	0x3C,A
72:                       MOTOR_InitStruct.DutyLow = MOTOR_260Hz_Duty_70;
  0304    301E    LDIA	0x1E
  0305    00BD    LD	0x3D,A
73:                       MOTOR_InitStruct.DutyHigh = MOTOR_260Hz_Duty_70;
  0306    00BE    LD	0x3E,A
74:                       work_mode.mode_out_put = work_mode.mode;
  0307    1283    CLRB	0x3,5
  0308    0866    LD	A,0x66
  0309    00E7    LD	0x67,A
75:                       break;
  030A    2B16    JP	0x316
  030B    0866    LD	A,0x66
  030C    3A01    XORIA	0x1
  030D    1903    SZB	0x3,2
  030E    2AF7    JP	0x2F7
  030F    3A03    XORIA	0x3
  0310    1903    SZB	0x3,2
  0311    2AFC    JP	0x2FC
  0312    3A01    XORIA	0x1
  0313    1903    SZB	0x3,2
  0314    2B01    JP	0x301
  0315    2B16    JP	0x316
76:                   
77:                   default: 
78:                       break;
79:                   }
80:               	low_a = (MOTOR_InitStruct.DutyLow);//低电平的时间
  0316    1683    SETB	0x3,5
  0317    083D    LD	A,0x3D
  0318    1283    CLRB	0x3,5
  0319    00C3    LD	0x43,A
81:                   dead_area1 =  (MOTOR_InitStruct.Period);
  031A    1683    SETB	0x3,5
  031B    083C    LD	A,0x3C
  031C    1283    CLRB	0x3,5
  031D    00C2    LD	0x42,A
82:               
83:                   dead_area_b1 = MOTOR_InitStruct.DutyLow + (((MOTOR_InitStruct.Period - MOTOR_InitStruct.DutyLow) - MOTOR_InitStruct.DutyHigh) >> 1);
  031E    1683    SETB	0x3,5
  031F    083C    LD	A,0x3C
  0320    1283    CLRB	0x3,5
  0321    00D3    LD	0x53,A
  0322    01D4    CLR	0x54
  0323    0854    LD	A,0x54
  0324    00D6    LD	0x56,A
  0325    1683    SETB	0x3,5
  0326    083D    LD	A,0x3D
  0327    1283    CLRB	0x3,5
  0328    0253    SUBA	0x53
  0329    00D5    LD	0x55,A
  032A    1C03    SNZB	0x3,0
  032B    03D6    DECR	0x56
  032C    0856    LD	A,0x56
  032D    00D8    LD	0x58,A
  032E    1683    SETB	0x3,5
  032F    083E    LD	A,0x3E
  0330    1283    CLRB	0x3,5
  0331    0255    SUBA	0x55
  0332    00D7    LD	0x57,A
  0333    1C03    SNZB	0x3,0
  0334    03D8    DECR	0x58
  0335    0D58    RLCA	0x58
  0336    0CD8    RRCR	0x58
  0337    0CD7    RRCR	0x57
  0338    1683    SETB	0x3,5
  0339    083D    LD	A,0x3D
  033A    1283    CLRB	0x3,5
  033B    0757    ADDA	0x57
  033C    00C0    LD	0x40,A
84:                   low_b = MOTOR_InitStruct.DutyHigh + dead_area_b1;
  033D    1683    SETB	0x3,5
  033E    073E    ADDA	0x3E
  033F    1283    CLRB	0x3,5
  0340    00C1    LD	0x41,A
85:                   dead_area_b2 =  (MOTOR_InitStruct.Period);
  0341    1683    SETB	0x3,5
  0342    083C    LD	A,0x3C
  0343    1283    CLRB	0x3,5
  0344    00BF    LD	0x3F,A
  0345    0008    RET
86:               }
87:               
88:               #if 1
89:               void Mode_control(void)	//50us
90:               {
91:               	//if((app_work_state == WORK_STATE_WORKING || app_work_state == WORK_STATE_OLD_MODE_RUN))
92:               	//if(PwrOnBit && (!MotorStopBit))
93:               	//{
94:               		if(WORK_MODE_IDEL == work_mode.mode_out_put)
  0346    0867    LD	A,0x67
  0347    1D03    SNZB	0x3,2
  0348    2B4C    JP	0x34C
95:               		{
96:               			INA = 0;
  0349    1286    CLRB	0x6,5
97:               			INB = 0;
  034A    1306    CLRB	0x6,6
98:               			return;
  034B    0008    RET
99:               		}
100:              
101:              		motor_fix_cnt++;
  034C    0AA6    INCR	0x26
  034D    1903    SZB	0x3,2
  034E    0AA7    INCR	0x27
102:              		if (motor_fix_cnt <= low_a) 
  034F    0843    LD	A,0x43
  0350    00F0    LD	0x70,A
  0351    01F1    CLR	0x71
  0352    0827    LD	A,0x27
  0353    0271    SUBA	0x71
  0354    1D03    SNZB	0x3,2
  0355    2B58    JP	0x358
  0356    0826    LD	A,0x26
  0357    0270    SUBA	0x70
  0358    1C03    SNZB	0x3,0
  0359    2B5C    JP	0x35C
103:              		{
104:              			INA = 0;
  035A    1286    CLRB	0x6,5
105:              			// INA_OFF
106:              		}
  035B    2B67    JP	0x367
107:              		else if (motor_fix_cnt <= dead_area1)
  035C    0842    LD	A,0x42
  035D    00F0    LD	0x70,A
  035E    01F1    CLR	0x71
  035F    0827    LD	A,0x27
  0360    0271    SUBA	0x71
  0361    1D03    SNZB	0x3,2
  0362    2B65    JP	0x365
  0363    0826    LD	A,0x26
  0364    0270    SUBA	0x70
  0365    1803    SZB	0x3,0
108:              		{
109:              			INA = 1;
  0366    1686    SETB	0x6,5
110:              			// INA_ON
111:              		}
112:              		else
113:              		{
114:              			// motor_fix_cnt = 0;
115:              		}
116:              
117:              		if (motor_fix_cnt <= dead_area_b1)
  0367    0840    LD	A,0x40
  0368    00F0    LD	0x70,A
  0369    01F1    CLR	0x71
  036A    0827    LD	A,0x27
  036B    0271    SUBA	0x71
  036C    1D03    SNZB	0x3,2
  036D    2B70    JP	0x370
  036E    0826    LD	A,0x26
  036F    0270    SUBA	0x70
  0370    1C03    SNZB	0x3,0
  0371    2B74    JP	0x374
118:              		{
119:              			INB = 1;
  0372    1706    SETB	0x6,6
120:              			// INB_ON
121:              		}
  0373    0008    RET
122:              		else if (motor_fix_cnt <= low_b)
  0374    0841    LD	A,0x41
  0375    00F0    LD	0x70,A
  0376    01F1    CLR	0x71
  0377    0827    LD	A,0x27
  0378    0271    SUBA	0x71
  0379    1D03    SNZB	0x3,2
  037A    2B7D    JP	0x37D
  037B    0826    LD	A,0x26
  037C    0270    SUBA	0x70
  037D    1C03    SNZB	0x3,0
  037E    2B81    JP	0x381
123:              		{
124:              			INB = 0;
  037F    1306    CLRB	0x6,6
125:              			// INB_OFF
126:              		}
  0380    0008    RET
127:              		else if (motor_fix_cnt <= dead_area_b2)
  0381    083F    LD	A,0x3F
  0382    00F0    LD	0x70,A
  0383    01F1    CLR	0x71
  0384    0827    LD	A,0x27
  0385    0271    SUBA	0x71
  0386    1D03    SNZB	0x3,2
  0387    2B8A    JP	0x38A
  0388    0826    LD	A,0x26
  0389    0270    SUBA	0x70
  038A    1803    SZB	0x3,0
  038B    2B72    JP	0x372
128:              		{
129:              			INB = 1;
130:              			// INB_ON
131:              		}
132:              		else
133:              		{
134:              			motor_fix_cnt = 0;
  038C    01A6    CLR	0x26
  038D    01A7    CLR	0x27
  038E    0008    RET
135:              		}
136:              	//}
137:              }
138:              
139:              #endif
140:              
141:              // void app_motor_process()
142:              // {
143:              //    if (app_work_state == WORK_STATE_WORKING)
144:              //     {
145:              //         if (!app_charge.Charge)
146:              //         {
147:              //             app_motor_mode_one_set();
148:              //             app_motor_mode_two_set();
149:              //             app_motor_mode_three_set();
150:              //             app_motor_pulse_mode_set();
151:              //             app_motor_diy_mode_set();
152:              //         }
153:              //     }
154:              // }
155:              
156:              
157:              
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_charge.c ----------------------------------------------------------------------
1:                
2:                #include "main.h"
3:                
4:                app_charge_t app_charge = 
5:                {
6:                	0
7:                	// .Charge = 0,
8:                	// .FullCharge = 0,
9:                	// .low_bat_3V3 = 0,
10:               	// .LowPower = 0,
11:               	// .LowLed = 0,
12:               	// .ChargeCnt = 0,
13:               	// .ChargeFullCnt = 0,
14:               };
15:               
16:               bit flag_charge_once;
17:               bit flag_discharge_once;
18:               
19:               volatile uint adresultvdd_back = 0;
20:               
21:               //bit flag_charge_force_full_24hour;
22:               unsigned long charge_force_full_cnt;
23:               
24:               unsigned char charge_full_cnt;
25:               unsigned int charge_full_cnt1;
26:               
27:               volatile uint adresult_chagrge_vdd = 0;
28:               //u16 Charge_BatAdValue = 0;
29:               u8	Charge_BatAdSumCnt = 0;
30:               u16 Charge_BatAdTmp = 0;
31:               u32 Charge_BatAdSum = 0;
32:               
33:               #define CHARGE_VOL_SET_FULL   1300   //1V
34:               
35:               #define CHARGE_VOL_SET   1700   //2.4V
36:               
37:               #define _XTAL_FREQ 16000000UL		//如果用16M晶振则改为16000000UL
38:               void ChargePwmOut(unsigned char Duty)
  0734    00D3    LD	0x53,A
39:               {
40:               	if(Duty == 0)
  0735    0853    LD	A,0x53
  0736    1D03    SNZB	0x3,2
  0737    2F3C    JP	0x73C
41:               	{
42:               		PWM0EN = 0;
  0738    101B    CLRB	0x1B,0
43:               		TRISB3 = 1;
  0739    1683    SETB	0x3,5
  073A    1586    SETB	0x6,3
44:               	}
  073B    0008    RET
45:               	else
46:               	{
47:               		if(!PWM0EN)
  073C    1C1B    SNZB	0x1B,0
48:               		{
49:               			PWM0EN = 1;
  073D    141B    SETB	0x1B,0
50:               		}
51:               		CHRG_OUT_PUT();
  073E    1683    SETB	0x3,5
  073F    1186    CLRB	0x6,3
52:               		PWMD0L = Duty;
  0740    1283    CLRB	0x3,5
  0741    0853    LD	A,0x53
  0742    0096    LD	0x16,A
  0743    0008    RET
53:               	}
54:               }
55:               
56:               void Charge_Check(void)                       // 0001 0001
57:               {	
58:               	ADCON0 = 0b00110001;   //AN12 0011 0001
  002E    3031    LDIA	0x31
  002F    1283    CLRB	0x3,5
  0030    009F    LD	0x1F,A
59:               	__delay_us(20);		//延时100us 	
  0031    301A    LDIA	0x1A
  0032    1283    CLRB	0x3,5
  0033    00E0    LD	0x60,A
  0034    0BE0    SZDECR	0x60
  0035    2834    JP	0x34
60:               	ADCON1 = 0b00000100;   //2.4V
  0036    3004    LDIA	0x4
  0037    1683    SETB	0x3,5
  0038    009F    LD	0x1F,A
61:               	__delay_us(20);		//延时100us 	
  0039    301A    LDIA	0x1A
  003A    1283    CLRB	0x3,5
  003B    00E0    LD	0x60,A
  003C    0BE0    SZDECR	0x60
  003D    283C    JP	0x3C
62:               	adresult_chagrge_vdd = AdcResultChk(VREF2_4V,CHARGE_AN12);
  003E    300C    LDIA	0xC
  003F    1283    CLRB	0x3,5
  0040    00D9    LD	0x59,A
  0041    3004    LDIA	0x4
  0042    2761    CALL	0x761
  0043    085A    LD	A,0x5A
  0044    00B7    LD	0x37,A
  0045    0859    LD	A,0x59
  0046    00B6    LD	0x36,A
63:               	// if(Charge_BatAdSumCnt < 8)
64:               	// {
65:               	// 	Charge_BatAdSumCnt++;
66:               	// 	Charge_BatAdSum += Charge_BatAdTmp;
67:               	// }
68:               	// else
69:               	// {
70:               	// 	adresult_chagrge_vdd = Charge_BatAdTmp >> 3;
71:               		
72:               	// 	Charge_BatAdSum = 0;
73:               	// 	Charge_BatAdSumCnt = 0;
74:               	// }
75:               	if (adresult_chagrge_vdd < CHARGE_VOL_SET_FULL) //拔电
  0047    3005    LDIA	0x5
  0048    0237    SUBA	0x37
  0049    3014    LDIA	0x14
  004A    1903    SZB	0x3,2
  004B    0236    SUBA	0x36
  004C    1803    SZB	0x3,0
  004D    2869    JP	0x69
76:               	{
77:               		if (!flag_charge_once)
  004E    1B7B    SZB	0x7B,6
  004F    286C    JP	0x6C
78:               		{
79:               			app_charge.DisChargeCnt++;
  0050    1683    SETB	0x3,5
  0051    0AAB    INCR	0x2B
  0052    1903    SZB	0x3,2
  0053    0AAC    INCR	0x2C
80:               			if(app_charge.DisChargeCnt >= MS(500))
  0054    3000    LDIA	0x0
  0055    022C    SUBA	0x2C
  0056    3032    LDIA	0x32
  0057    1903    SZB	0x3,2
  0058    022B    SUBA	0x2B
  0059    1C03    SNZB	0x3,0
  005A    286C    JP	0x6C
  005B    3003    LDIA	0x3
81:               			{
82:               				flag_charge_once = 1;
  005C    177B    SETB	0x7B,6
83:               				flag_discharge_once = 0;
  005D    12FB    CLRB	0x7B,5
84:               
85:               				app_charge.DisChargeCnt = 0;
  005E    01AB    CLR	0x2B
  005F    01AC    CLR	0x2C
86:               				app_charge.Charge = FLASE;
  0060    1020    CLRB	0x20,0
87:               				app_charge.FullCharge = FLASE;
  0061    10A0    CLRB	0x20,1
88:                          		set_led_state(LED_INDEX_9 | LED_INDEX_10,LED_STATE_OFF);
  0062    2134    CALL	0x134
  0063    25E4    CALL	0x5E4
89:               				ChargePwmOut(0);
  0064    3000    LDIA	0x0
  0065    2734    CALL	0x734
90:               				app_process_set_work_state(WORK_STATE_POWEROFF);
  0066    3000    LDIA	0x0
  0067    27D4    CALL	0x7D4
  0068    286C    JP	0x6C
91:               			}
92:               		}
93:               	}
94:               	else
95:               	{
96:               		app_charge.DisChargeCnt = 0;
  0069    1683    SETB	0x3,5
  006A    01AB    CLR	0x2B
  006B    01AC    CLR	0x2C
97:               	}
98:               	if (adresult_chagrge_vdd > CHARGE_VOL_SET)
  006C    3006    LDIA	0x6
  006D    1283    CLRB	0x3,5
  006E    0237    SUBA	0x37
  006F    30A5    LDIA	0xA5
  0070    1903    SZB	0x3,2
  0071    0236    SUBA	0x36
  0072    1C03    SNZB	0x3,0
  0073    2891    JP	0x91
99:               	{
100:              		if (!flag_discharge_once)
  0074    1AFB    SZB	0x7B,5
  0075    2894    JP	0x94
101:              		{
102:              			if (app_charge.ChargeCnt <= MS(100))
  0076    3000    LDIA	0x0
  0077    1683    SETB	0x3,5
  0078    022A    SUBA	0x2A
  0079    300B    LDIA	0xB
  007A    1903    SZB	0x3,2
  007B    0229    SUBA	0x29
  007C    1803    SZB	0x3,0
  007D    2882    JP	0x82
103:              			{
104:              				app_charge.ChargeCnt++;
  007E    0AA9    INCR	0x29
  007F    1903    SZB	0x3,2
  0080    0AAA    INCR	0x2A
105:              			}
  0081    2894    JP	0x94
106:              			else
107:              			{
108:              				flag_charge_once = 0;
  0082    137B    CLRB	0x7B,6
109:              				flag_discharge_once = 1;
  0083    16FB    SETB	0x7B,5
110:              
111:              				app_charge.ChargeFullCnt = 0;
  0084    01AD    CLR	0x2D
  0085    01AE    CLR	0x2E
112:              				app_charge.ChargeCnt = 0;
  0086    01A9    CLR	0x29
  0087    01AA    CLR	0x2A
113:              				app_charge.Charge = TURE;
  0088    1420    SETB	0x20,0
114:              				app_charge.FullCharge = 0;
  0089    10A0    CLRB	0x20,1
115:              
116:              				adresultvdd_back = 4096;
  008A    1283    CLRB	0x3,5
  008B    01B8    CLR	0x38
  008C    3010    LDIA	0x10
  008D    00B9    LD	0x39,A
117:              				app_process_set_work_state(WORK_STATE_CHARGING);
  008E    3002    LDIA	0x2
  008F    27D4    CALL	0x7D4
  0090    2894    JP	0x94
118:              			}
119:              		}
120:              	}
121:              	else
122:              	{
123:              		app_charge.ChargeCnt = 0;
  0091    1683    SETB	0x3,5
  0092    01A9    CLR	0x29
  0093    01AA    CLR	0x2A
124:              	}
125:              	if(app_charge.Charge)
  0094    1683    SETB	0x3,5
  0095    1C20    SNZB	0x20,0
  0096    2921    JP	0x121
126:              	{
127:              		if(app_charge.FullCharge || app_charge.ForceFullCharge)
  0097    18A0    SZB	0x20,1
  0098    289B    JP	0x9B
  0099    1D20    SNZB	0x20,2
  009A    28CC    JP	0xCC
128:              		{
129:              			if (charge_force_full_cnt <= (100UL * 3600 *15 + 100UL * 3600 *9)) //再过九个小时灯灭
  009B    0846    LD	A,0x46
  009C    1D03    SNZB	0x3,2
  009D    28B2    JP	0xB2
  009E    3083    LDIA	0x83
  009F    0245    SUBA	0x45
  00A0    1D03    SNZB	0x3,2
  00A1    28A8    JP	0xA8
  00A2    30D6    LDIA	0xD6
  00A3    0244    SUBA	0x44
  00A4    1D03    SNZB	0x3,2
  00A5    28A8    JP	0xA8
  00A6    3001    LDIA	0x1
  00A7    0243    SUBA	0x43
  00A8    1803    SZB	0x3,0
  00A9    28B2    JP	0xB2
130:              			// if (charge_force_full_cnt <= (100UL * 60 *2 + 100UL * 60 *1)) //再过九个小时灯灭
131:              			{
132:              				charge_force_full_cnt++;
  00AA    0AC3    INCR	0x43
  00AB    1903    SZB	0x3,2
  00AC    0AC4    INCR	0x44
  00AD    1903    SZB	0x3,2
  00AE    0AC5    INCR	0x45
  00AF    1903    SZB	0x3,2
  00B0    0AC6    INCR	0x46
133:              			}
  00B1    28B3    JP	0xB3
134:              			else
135:              			{
136:              				app_charge.flag_charge_force_full_24hour = 1;
  00B2    15A0    SETB	0x20,3
137:              			}
138:              			if (app_charge.flag_charge_force_full_24hour)
  00B3    1DA0    SNZB	0x20,3
  00B4    28B8    JP	0xB8
139:              			{
140:              				CHRG_OUT_PUT_FULL();//关掉充电
  00B5    1283    CLRB	0x3,5
  00B6    212E    CALL	0x12E
141:              			}
  00B7    0008    RET
142:              			else
143:              			{
144:              				if (app_charge.ForceFullCharge)
  00B8    1920    SZB	0x20,2
  00B9    28B5    JP	0xB5
145:              				{
146:              					CHRG_OUT_PUT_FULL();//关掉充电
147:              				}
148:              				else
149:              				{
150:              					if (adresultvdd > Voltage4V05)  //如果小于4.05V复冲
  00BA    3004    LDIA	0x4
  00BB    1283    CLRB	0x3,5
  00BC    023B    SUBA	0x3B
  00BD    30BE    LDIA	0xBE
  00BE    1903    SZB	0x3,2
  00BF    023A    SUBA	0x3A
  00C0    1C03    SNZB	0x3,0
  00C1    28C4    JP	0xC4
151:              					{
152:              						ChargePwmOut(60);
  00C2    303C    LDIA	0x3C
  00C3    2F34    JP	0x734
153:              					}
154:              					else if(adresultvdd <= Voltage4V15)
  00C4    3004    LDIA	0x4
  00C5    023B    SUBA	0x3B
  00C6    309D    LDIA	0x9D
  00C7    1903    SZB	0x3,2
  00C8    023A    SUBA	0x3A
  00C9    1803    SZB	0x3,0
  00CA    0008    RET
  00CB    28B5    JP	0xB5
155:              					{
156:              						CHRG_OUT_PUT_FULL();//关掉充电
157:              					}
158:              			}
159:              			}
160:              			
161:              		}
162:              		else
163:              		{
164:              			//当电池电压冲到4.1V，强制充满电
165:              			// if (adresultvdd < Voltage4V1)
166:              			// {
167:              			// 	SysTime30minCnt++;
168:              			// 	if (SysTime30minCnt > 100UL * 60 * 30)//30min
169:              			// 	{
170:              			// 		app_charge.FullCharge = 1;
171:              			// 	}
172:              			// }
173:              			// else
174:              			// {
175:              			// 	SysTime30minCnt = 0;
176:              			// }	
177:              			if (adresultvdd <= Voltage4V1) //如果大于4.15V停止充电
178:              			{
179:              				if (++charge_full_cnt1 >= MINUTE(30))
180:              				{
181:              					CHRG_OUT_PUT_FULL();//关掉充电
182:              					app_charge.FullCharge = TURE;
183:              				}
184:              			} 
185:              			if (adresultvdd <= Voltage4V2) //如果大于4.2V停止充电
  00CC    3004    LDIA	0x4
  00CD    1283    CLRB	0x3,5
  00CE    023B    SUBA	0x3B
  00CF    3093    LDIA	0x93
  00D0    1903    SZB	0x3,2
  00D1    023A    SUBA	0x3A
  00D2    1803    SZB	0x3,0
  00D3    28DD    JP	0xDD
186:              			{
187:              				if (++charge_full_cnt >= 100)
  00D4    3064    LDIA	0x64
  00D5    0ACD    INCR	0x4D
  00D6    024D    SUBA	0x4D
  00D7    1C03    SNZB	0x3,0
  00D8    28DE    JP	0xDE
188:              				{
189:              					CHRG_OUT_PUT_FULL();//关掉充电
  00D9    212E    CALL	0x12E
190:              					app_charge.FullCharge = TURE;
  00DA    1683    SETB	0x3,5
  00DB    14A0    SETB	0x20,1
  00DC    28DE    JP	0xDE
191:              				}
192:              			} 
193:              			else
194:              			{
195:              				charge_full_cnt = 0;
  00DD    01CD    CLR	0x4D
196:              			}
197:              			//
198:              			if (charge_force_full_cnt <= 100UL * 3600 *15)//100 * 3600 *15  
  00DE    1683    SETB	0x3,5
  00DF    0846    LD	A,0x46
  00E0    1D03    SNZB	0x3,2
  00E1    28F6    JP	0xF6
  00E2    3052    LDIA	0x52
  00E3    0245    SUBA	0x45
  00E4    1D03    SNZB	0x3,2
  00E5    28EC    JP	0xEC
  00E6    3065    LDIA	0x65
  00E7    0244    SUBA	0x44
  00E8    1D03    SNZB	0x3,2
  00E9    28EC    JP	0xEC
  00EA    30C1    LDIA	0xC1
  00EB    0243    SUBA	0x43
  00EC    1803    SZB	0x3,0
  00ED    28F6    JP	0xF6
199:              			// if (charge_force_full_cnt <= 100UL * 60 * 2)//100 * 3600 *15  
200:              			{
201:              				charge_force_full_cnt++;
  00EE    0AC3    INCR	0x43
  00EF    1903    SZB	0x3,2
  00F0    0AC4    INCR	0x44
  00F1    1903    SZB	0x3,2
  00F2    0AC5    INCR	0x45
  00F3    1903    SZB	0x3,2
  00F4    0AC6    INCR	0x46
202:              			}
  00F5    28F7    JP	0xF7
203:              			else
204:              			{
205:              				app_charge.ForceFullCharge = TURE;
  00F6    1520    SETB	0x20,2
206:              			}
207:              
208:              			if (adresultvdd_back >= adresultvdd)
  00F7    1283    CLRB	0x3,5
  00F8    083B    LD	A,0x3B
  00F9    0239    SUBA	0x39
  00FA    1D03    SNZB	0x3,2
  00FB    28FE    JP	0xFE
  00FC    083A    LD	A,0x3A
  00FD    0238    SUBA	0x38
  00FE    1C03    SNZB	0x3,0
  00FF    2904    JP	0x104
209:              			{
210:              				adresultvdd_back = adresultvdd;
  0100    083B    LD	A,0x3B
  0101    00B9    LD	0x39,A
  0102    083A    LD	A,0x3A
  0103    00B8    LD	0x38,A
211:              			}
212:              			
213:              			
214:              			if(adresultvdd_back < Voltage4V1)
  0104    3004    LDIA	0x4
  0105    0239    SUBA	0x39
  0106    30AF    LDIA	0xAF
  0107    1903    SZB	0x3,2
  0108    0238    SUBA	0x38
  0109    1803    SZB	0x3,0
  010A    290D    JP	0x10D
215:              			{
216:              				ChargePwmOut(60);
  010B    303C    LDIA	0x3C
  010C    2F34    JP	0x734
217:              			}
218:              			else if(adresultvdd_back < Voltage4V0)
  010D    3004    LDIA	0x4
  010E    0239    SUBA	0x39
  010F    30CC    LDIA	0xCC
  0110    1903    SZB	0x3,2
  0111    0238    SUBA	0x38
  0112    1803    SZB	0x3,0
  0113    2916    JP	0x116
219:              			{
220:              				ChargePwmOut(60);
  0114    303C    LDIA	0x3C
  0115    2F34    JP	0x734
221:              			}
222:              			else if(adresultvdd_back < Voltage3V4)
  0116    3005    LDIA	0x5
  0117    0239    SUBA	0x39
  0118    30A5    LDIA	0xA5
  0119    1903    SZB	0x3,2
  011A    0238    SUBA	0x38
  011B    1803    SZB	0x3,0
  011C    291F    JP	0x11F
223:              			{
224:              				ChargePwmOut(80);
  011D    3050    LDIA	0x50
  011E    2F34    JP	0x734
225:              			}
226:              			else
227:              			{
228:              				ChargePwmOut(60);   //小于3.5V就是60%的pwm输出
  011F    303C    LDIA	0x3C
  0120    2F34    JP	0x734
229:              			}
230:              		}
231:              	}
232:              	else
233:              	{
234:              		charge_full_cnt1 = 0;
235:              		charge_full_cnt = 0;
  0121    1283    CLRB	0x3,5
  0122    01CD    CLR	0x4D
236:              		charge_force_full_cnt = 0;
  0123    1683    SETB	0x3,5
  0124    01C3    CLR	0x43
  0125    01C4    CLR	0x44
  0126    01C5    CLR	0x45
  0127    01C6    CLR	0x46
237:              		app_charge.flag_charge_force_full_24hour = 0;
  0128    11A0    CLRB	0x20,3
238:              		app_charge.FullCharge = 0;
  0129    10A0    CLRB	0x20,1
239:              		app_charge.ForceFullCharge = 0;	
  012A    1120    CLRB	0x20,2
240:              		app_charge.ChargeFullCnt = 0;
  012B    01AD    CLR	0x2D
  012C    01AE    CLR	0x2E
  012D    0008    RET
241:              	}
242:              }
243:              
244:              void app_process_charge()
245:              {
246:                  Charge_Check(); 
  07E3    282E    JP	0x2E
247:              }
---- D:\Weiai\project\艾珀尔\ABB868\ABB868_V4_SC8P1712E_20250310_0xf33d改为呼吸灯版本\app_adc.c ----------------------------------------------------------------------
1:                
2:                #include "main.h"
3:                
4:                volatile unsigned int	adresult;
5:                volatile unsigned long adsum;
6:                volatile unsigned int admin,admax;
7:                volatile unsigned char adtimes;
8:                volatile uint adresultvdd = 0;
9:                volatile uint adresultvdd_back = 0;
10:               volatile unsigned char BatStates = 5;
11:               volatile unsigned char BatAdcCnt;
12:               volatile unsigned char CntLowPowerOff;
13:               volatile uint adresultmotor;
14:               volatile uchar motor_lock_cnt = 0;
15:               // unsigned char FlagOldMode;
16:               unsigned char bat_remind_delay;
17:               
18:               //u16 BatAdValue = 0;
19:               u8	BatAdSumCnt = 0;
20:               u16 BatAdTmp = 0;
21:               u32 BatAdSum = 0;
22:               
23:               
24:               #define _XTAL_FREQ 16000000UL		//如果用16M晶振则改为16000000UL
25:               
26:               
27:               static uint AdcOneChk(uchar adch,uchar adldo)	//ADC单次采样
28:               {
29:               	volatile uchar i = 0;
  058B    01D6    CLR	0x56
30:               	volatile uint ad_result;
31:               	
32:               	//ADCON1 = adldo;//0B00001100;						//左对齐，用2.4V做AD参考 
33:               	__delay_us(20);		//延时100us 					//延时20us
  058C    301A    LDIA	0x1A
  058D    1283    CLRB	0x3,5
  058E    00D5    LD	0x55,A
  058F    0BD5    SZDECR	0x55
  0590    2D8F    JP	0x58F
  0591    0000    NOP
  0592    0000    NOP
  0593    0000    NOP
  0594    0000    NOP
34:               	//ADCON0 = 0X41 | (adch << 2);	//16分频
35:               	asm("nop");
36:               	asm("nop");
37:               	asm("nop");
38:               	asm("nop");
39:               	GODONE = 1;						//开始转换
  0595    1283    CLRB	0x3,5
  0596    149F    SETB	0x1F,1
40:               
41:               	while(GODONE)
  0597    1C9F    SNZB	0x1F,1
  0598    2DA0    JP	0x5A0
  0599    0064    CLRWDT
42:               	{
43:               		asm("clrwdt");
44:               		if(0 == (--i))
  059A    1283    CLRB	0x3,5
  059B    0BD6    SZDECR	0x56
  059C    2D97    JP	0x597
45:               			return 0;				//转换超时
  059D    01D3    CLR	0x53
  059E    01D4    CLR	0x54
  059F    0008    RET
46:               	}
47:               	ad_result=ADRESH;
  05A0    081E    LD	A,0x1E
  05A1    00D7    LD	0x57,A
  05A2    01D8    CLR	0x58
48:               	ad_result= (ad_result<<4);
  05A3    0ED7    SWAPR	0x57
  05A4    0ED8    SWAPR	0x58
  05A5    30F0    LDIA	0xF0
  05A6    05D8    ANDR	0x58
  05A7    0857    LD	A,0x57
  05A8    390F    ANDIA	0xF
  05A9    04D8    ORR	0x58
  05AA    30F0    LDIA	0xF0
  05AB    05D7    ANDR	0x57
49:               	ad_result +=(ADRESL>>4);	//计算12位AD值
  05AC    1683    SETB	0x3,5
  05AD    0E1E    SWAPA	0x1E
  05AE    390F    ANDIA	0xF
  05AF    1283    CLRB	0x3,5
  05B0    07D7    ADDR	0x57
  05B1    1803    SZB	0x3,0
  05B2    0AD8    INCR	0x58
50:               	//ad_result=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值;
51:               	return ad_result;
  05B3    0858    LD	A,0x58
  05B4    00D4    LD	0x54,A
  05B5    0857    LD	A,0x57
  05B6    00D3    LD	0x53,A
  05B7    0008    RET
52:               }
53:               
54:               uint AdcResultChk(uchar adch,uchar adldo)//ADC多次采样
  0761    00DC    LD	0x5C,A
55:               {
56:               	volatile uchar i = 0;
  0762    01DD    CLR	0x5D
57:               	volatile uint ad_value;
58:               	volatile uint ad_value_max;
59:               	volatile uint ad_value_min;
60:               	
61:               	volatile uint ad_temp;
62:               	
63:               	ad_value = AdcOneChk(adch,adldo);
  0763    0859    LD	A,0x59
  0764    00D3    LD	0x53,A
  0765    258B    CALL	0x58B
  0766    0854    LD	A,0x54
  0767    00DF    LD	0x5F,A
  0768    0853    LD	A,0x53
  0769    00DE    LD	0x5E,A
64:                   return ad_value;
  076A    085F    LD	A,0x5F
  076B    00DA    LD	0x5A,A
  076C    085E    LD	A,0x5E
  076D    00D9    LD	0x59,A
  076E    0008    RET
65:               	
66:               	// ad_value_max = ad_value;//获取最大值
67:               	// ad_value_min = ad_value;//获取最小值
68:               	// ad_temp = ad_value;
69:               	// for(i = 9;i > 0;i--)
70:               	// {
71:               	// 	ad_value = AdcOneChk(adch,adldo);
72:               	// 	if(ad_value > ad_value_max)
73:               	// 	{
74:               	// 		ad_temp += ad_value_max;
75:               	// 		ad_value_max = ad_value;
76:               	// 	}
77:               	// 	else if(ad_value < ad_value_min)
78:               	// 	{
79:               	// 		ad_temp += ad_value_min;
80:               	// 		ad_value_min = ad_value;
81:               	// 	}
82:               	// 	else
83:               	// 	{
84:               	// 		ad_temp += ad_value;
85:               	// 	}
86:               	// }
87:               
88:               	// ad_temp -= ad_value_max;
89:               	// ad_temp -= ad_value_min;
90:               
91:               	// return (ad_temp>>3);	//平均值
92:               }
93:               
94:               
95:               //bit flag_charge_force_full;
96:               bit flag_charge_force_full_24hour;
97:               unsigned long charge_force_full_cnt;
98:               void app_adc_bat_voltage_check()
99:               {
100:                  ADCON0 = 0b00111101;   //AN15
  0295    303D    LDIA	0x3D
  0296    1283    CLRB	0x3,5
  0297    009F    LD	0x1F,A
101:                  __delay_us(20);		//延时100us 	
  0298    301A    LDIA	0x1A
  0299    1283    CLRB	0x3,5
  029A    00E0    LD	0x60,A
  029B    0BE0    SZDECR	0x60
  029C    2A9B    JP	0x29B
102:                  ADCON1 = 0b00000000;   //VDD
  029D    1683    SETB	0x3,5
  029E    019F    CLR	0x1F
103:                  __delay_us(20);		//延时100us 
  029F    301A    LDIA	0x1A
  02A0    1283    CLRB	0x3,5
  02A1    00E0    LD	0x60,A
  02A2    0BE0    SZDECR	0x60
  02A3    2AA2    JP	0x2A2
  02A4    300F    LDIA	0xF
104:              
105:                  adresultvdd = AdcResultChk(ANVdd,VREFVdd);
  02A5    1283    CLRB	0x3,5
  02A6    01D9    CLR	0x59
  02A7    2761    CALL	0x761
  02A8    085A    LD	A,0x5A
  02A9    00BB    LD	0x3B,A
  02AA    0859    LD	A,0x59
  02AB    00BA    LD	0x3A,A
106:                  // BatAdTmp = AdcResultChk(ANVdd,VREFVdd);
107:                  // if(BatAdSumCnt < 32)
108:              	// {
109:              	// 	BatAdSumCnt++;
110:              	// 	BatAdSum += BatAdTmp;
111:              	// }
112:              	// else
113:              	// {
114:              	// 	adresultvdd = BatAdSum >> 5;
115:              		
116:              	// 	BatAdSum = 0;
117:              	// 	BatAdSumCnt = 0;
118:              	// }
119:              
120:                  if(app_charge.Charge)		//充电
  02AC    1683    SETB	0x3,5
  02AD    1C20    SNZB	0x20,0
  02AE    2AC4    JP	0x2C4
121:                  {
122:                      if(adresultvdd < Voltage3V2)      //3.0V  //// / 1.2V/3.0*4096=1638
  02AF    3005    LDIA	0x5
  02B0    1283    CLRB	0x3,5
  02B1    023B    SUBA	0x3B
  02B2    30FF    LDIA	0xFF
  02B3    1903    SZB	0x3,2
  02B4    023A    SUBA	0x3A
  02B5    1803    SZB	0x3,0
  02B6    2AC2    JP	0x2C2
123:                      {
124:                          CntLowPowerOff++;
  02B7    0AD0    INCR	0x50
125:                          if(CntLowPowerOff > 250)
  02B8    30FB    LDIA	0xFB
  02B9    0250    SUBA	0x50
  02BA    1C03    SNZB	0x3,0
  02BB    0008    RET
126:                          {
127:                              CntLowPowerOff = 0;
  02BC    01D0    CLR	0x50
128:                              app_charge.Remind = 0;
  02BD    1683    SETB	0x3,5
  02BE    1220    CLRB	0x20,4
129:                              app_charge.LowLed = 0;
  02BF    01A7    CLR	0x27
130:                              app_charge.LowPower = 0;
  02C0    01A6    CLR	0x26
  02C1    0008    RET
131:                          }		 
132:                      }
133:                      else
134:                      {
135:                          CntLowPowerOff = 0;
  02C2    01D0    CLR	0x50
  02C3    0008    RET
136:                      }
137:                  }           //用电
138:                  else
139:                  {
140:                      if(adresultvdd > Voltage2V9 - 20)      //3.0V  //// / 1.2V/3.0*4096=1638
  02C4    3006    LDIA	0x6
  02C5    1283    CLRB	0x3,5
  02C6    023B    SUBA	0x3B
  02C7    308B    LDIA	0x8B
  02C8    1903    SZB	0x3,2
  02C9    023A    SUBA	0x3A
  02CA    1C03    SNZB	0x3,0
  02CB    2AE2    JP	0x2E2
141:                      {
142:                          CntLowPowerOff++;
  02CC    0AD0    INCR	0x50
143:                          if(CntLowPowerOff > 100)
  02CD    3065    LDIA	0x65
  02CE    0250    SUBA	0x50
  02CF    1C03    SNZB	0x3,0
  02D0    2AE3    JP	0x2E3
144:                          {
145:                              CntLowPowerOff = 0;
  02D1    01D0    CLR	0x50
146:                              app_charge.Remind = FLASE;
  02D2    1683    SETB	0x3,5
  02D3    1220    CLRB	0x20,4
147:              
148:                              if (!app_charge.LowPower)
  02D4    0826    LD	A,0x26
  02D5    1D03    SNZB	0x3,2
  02D6    2AE3    JP	0x2E3
149:                              {
150:                                  app_process_set_work_state(WORK_STATE_POWEROFF);
  02D7    3000    LDIA	0x0
  02D8    27D4    CALL	0x7D4
151:                                  app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  02D9    3000    LDIA	0x0
  02DA    27D9    CALL	0x7D9
152:                                  app_charge.LowPower = 1;
  02DB    1683    SETB	0x3,5
  02DC    01A6    CLR	0x26
  02DD    0AA6    INCR	0x26
153:                                  app_charge.LowLed = TURE;
  02DE    01A7    CLR	0x27
  02DF    0AA7    INCR	0x27
154:                                  app_charge.LowLed_cnt = 0;
  02E0    01A8    CLR	0x28
  02E1    2AE3    JP	0x2E3
155:                              }
156:                          }		 
157:                      }
158:                      else
159:                      {
160:                          CntLowPowerOff = 0;
  02E2    01D0    CLR	0x50
161:                      }
162:              
163:                      if(adresultvdd > Voltage3V4 -15)
  02E3    3005    LDIA	0x5
  02E4    1283    CLRB	0x3,5
  02E5    023B    SUBA	0x3B
  02E6    3097    LDIA	0x97
  02E7    1903    SZB	0x3,2
  02E8    023A    SUBA	0x3A
  02E9    1C03    SNZB	0x3,0
  02EA    2AF4    JP	0x2F4
  02EB    3065    LDIA	0x65
164:                      {
165:                          bat_remind_delay++;
  02EC    0ACE    INCR	0x4E
166:                          if(bat_remind_delay > 100)
  02ED    024E    SUBA	0x4E
  02EE    1C03    SNZB	0x3,0
  02EF    0008    RET
167:                          {
168:                              bat_remind_delay = 0;
  02F0    01CE    CLR	0x4E
169:                              app_charge.Remind = 1;
  02F1    1683    SETB	0x3,5
  02F2    1620    SETB	0x20,4
  02F3    0008    RET
170:                          }
171:                      }
172:                      else
173:                      {
174:                          bat_remind_delay = 0;
  02F4    01CE    CLR	0x4E
  02F5    0008    RET
175:                      }
176:                      
177:                  }
178:              }		
179:              
180:              void MotorAdcIChk(void)
181:              {
182:                  // if (app_work_state == WORK_STATE_WORKING)
183:                  // {
184:                      adresultmotor = AdcResultChk(ANI_DET,VREF2_0V);
185:                      {
186:                          if(adresultmotor > MOTORIOVER)
187:                          {
188:                              if(motor_lock_cnt <= MS(200))
189:                              {
190:                                  motor_lock_cnt++;
191:                              }
192:                              else
193:                              {
194:                                  app_process_set_work_state(WORK_STATE_POWEROFF);
195:                              }
196:                          }
197:                          else
198:                          {
199:                              motor_lock_cnt = 0;
200:                              // if(motor_lock_cnt > 20)
201:                              // {
202:                              // 	motor_lock_cnt--;
203:                              // }
204:                              // 	else
205:                              // 	{
206:                              // 		motor_lock_cnt = 0;
207:                              // 	}
208:                          }
209:                      }
210:                  // }
211:              }
212:              
213:              void app_adc_process()
214:              {
215:                  //MotorAdcIChk();
216:                  app_adc_bat_voltage_check();
  07E4    2A95    JP	0x295
217:              }
218:              
219:              
220:              
221:              
222:              
223:              
224:              
225:              
226:              
227:              
228:              
229:              
230:              
231:              
232:              
233:              
234:              
235:              
236:              
237:              
238:              
239:              
240:              
241:              
242:              // volatile unsigned int adresultmotor;
243:              // volatile unsigned int adresultvdd;
244:              // volatile unsigned long adsum;
245:              // volatile unsigned int admin,admax;
246:              // volatile unsigned char adtimes;
247:              
248:              // volatile unsigned char BatStates = 4;
249:              
250:              // volatile unsigned char CntLowPowerOff;
251:              
252:              
253:              // volatile unsigned char BatAdcCnt;
254:              
255:              
256:              // unsigned char CntOverCurrent;
257:              // volatile unsigned char Mode2ADCDelay;
258:              
259:              // bool FlagAdcSwitch;
260:              // bool FlagAdcVddOver;
261:              // bool FlagAdcMotorOver;
262:              
263:              
264:              // bool FlagCharge = 0;
265:              // bool FlagAdcSwitch=0;
266:              // bool FlagAdcMotorOver;
267:              // bool FlagAdcVddOver;
268:              // bool FlagLowPower;
269:              // bool FlagFullCharge;
270:              // bool FlagLowLed = 0;;
271:              
272:              
273:              // void AdcChkVdd()
274:              // {
275:              // 	volatile unsigned int ad_temp;	
276:              
277:              // 	GODONE = 1;						//开始转换
278:              
279:              // 	unsigned char i = 0;
280:              // 	while(GODONE)
281:              // 	{
282:              // 		if(0 == (--i))
283:              // 		return;
284:              // 	}
285:              // 	ad_temp=ADRESH;
286:              // 	ad_temp= (ad_temp<<4);
287:              // 	ad_temp +=(ADRESL>>4);	//计算12位AD值
288:              	
289:              // 	if(0 == admax)
290:              // 	{
291:              // 		admax = ad_temp;
292:              // 		admin = ad_temp;
293:              // 	}
294:              // 	else if(ad_temp > admax)
295:              // 		admax = ad_temp;				//AD采样最大值
296:              // 	else if(ad_temp < admin)
297:              // 		admin = ad_temp;				//AD采样最小值
298:              	
299:              // 	adsum += ad_temp;
300:              // 	//Flag10ms_Adc=1;
301:              // 	if(++adtimes >= 10)
302:              // 	{
303:              // 		adsum -= admax;
304:              // 		if(adsum >= admin)	adsum -= admin;
305:              // 		else	adsum = 0;
306:              // 		if(FlagAdcSwitch==0)
307:              // 		{
308:              // 			adresultvdd = (unsigned int)(adsum >> 3);		//8次平均值作为最终结果	
309:              // 			FlagAdcVddOver=TURE;
310:              // 			ADCON0 = 0b00000001;   //AN0
311:              // 			ADCON1 = 0b00000101;   //2.0V
312:              // 			//需要转换ADC始终频率
313:              // 				// ADCON0 = 0xc0;  //改变时钟分频，//转换通道检测AN0， 1100 0001
314:              // 				// LDOEN = 1;       //设置参考电压LDO
315:              // 			FlagAdcSwitch=1;		  
316:              // 		}
317:              // 		else
318:              // 		{
319:              // 			adresultmotor = (unsigned int)(adsum >> 3);		//8次平均值作为最终结果	
320:              // 			FlagAdcMotorOver=TURE;
321:              // 			ADCON0 = 0b00111101;   //AN15
322:              //           	ADCON1 = 0b00000000;   //VDD
323:              // 			//需要转换ADC始终频率
324:              // 			// ADCON0 = 0x7d;  //改变时钟分频，//转换通道检测基准电压 0111 1101
325:              // 			// LDOEN = 0;       //设置参考电压VDD
326:              // 		  	FlagAdcSwitch=0;		  
327:              // 		}										
328:              // 		adsum = 0;
329:              // 		admin = 0;
330:              // 		admax = 0;
331:              // 		adtimes = 0;
332:              // 	}
333:              // }
334:              
335:              // bool get_bat_low_state()
336:              // {
337:              //     return FlagLowLed;
338:              // }
339:              // void clear_bat_low_state()
340:              // {
341:              //     FlagLowLed = FLASE;
342:              // }
343:              
344:              // void voltage_check()  //低压检测
345:              // {
346:              // 	if(FlagAdcVddOver==TURE)
347:              //     {
348:              // 		FlagAdcVddOver=FLASE;
349:              	   
350:              // 		if(FlagCharge)		//充电
351:              // 		{
352:              // 			// if(adresultvdd < Voltage3V3)      //3.0V  //// / 1.2V/3.0*4096=1638
353:              // 			// {
354:              // 			// 	CntLowPowerOff++;
355:              // 			// 	if(CntLowPowerOff > 2)
356:              // 			// 	{
357:              // 			// 		CntLowPowerOff = 0;
358:              // 			// 		//if(!FlagLowPower)
359:              // 			// 		//{
360:              // 			// 			//	FlagLowLed = 1;
361:              // 			// 		//}
362:              // 			// 		FlagLowPower = FLASE;
363:              					
364:              // 			// 		//BatStates = 1;
365:              // 			// 	}		 
366:              // 			// }
367:              // 			// else
368:              // 			// {
369:              // 			// 	CntLowPowerOff = 0;
370:              // 			// }
371:              			
372:              // 			if(BatStates == 1)
373:              // 			{
374:              // 				if(adresultvdd < Voltage3V4)  
375:              // 				{
376:              // 					BatAdcCnt++;
377:              // 					if(BatAdcCnt > 2)
378:              // 					{
379:              // 						BatAdcCnt = 0;
380:              // 						BatStates = 2; //大于3.3V
381:              
382:              // 						if(!FlagLowPower)
383:              // 						//{
384:              // 							//	FlagLowLed = 1;
385:              // 						//}
386:              // 						FlagLowPower = FLASE;
387:              // 						FlagLowLed = FLASE;
388:              // 						//BatStates = 1;
389:              // 					}
390:              // 				}
391:              // 				else
392:              // 				{
393:              // 					BatAdcCnt = 0;
394:              // 				}
395:              // 			}
396:              // 			else if(BatStates == 2)
397:              // 			{
398:              // 				if(adresultvdd < Voltage3V7)	
399:              // 				{
400:              // 					BatAdcCnt++;
401:              // 					if(BatAdcCnt > 2)
402:              // 					{
403:              // 						BatAdcCnt = 0;
404:              // 						BatStates = 3;	//大于3.7V
405:              // 					}
406:              // 				}
407:              // 				else
408:              // 				{
409:              // 					BatAdcCnt = 0;
410:              // 				}
411:              // 			}
412:              // 			else if(BatStates == 3)
413:              // 			{
414:              // 				if(adresultvdd < Voltage3V9)
415:              // 				{
416:              // 					BatAdcCnt++;
417:              // 					if(BatAdcCnt > 2)
418:              // 					{
419:              // 						BatAdcCnt = 0;
420:              // 						BatStates = 4;	//大于3.9V
421:              // 					}
422:              // 				}
423:              // 				else
424:              // 				{
425:              // 					BatAdcCnt = 0;
426:              // 				}
427:              // 			}
428:              // 		}
429:              // 		else    //用电
430:              // 		{
431:              // 			if(adresultvdd > Voltage3V0)      //3.0V  //// / 1.2V/3.0*4096=1638
432:              // 			{
433:              // 				CntLowPowerOff++;
434:              // 				if(CntLowPowerOff > 2)
435:              // 				{
436:              // 					CntLowPowerOff = 0;
437:              // 					if(!FlagLowPower)
438:              // 					{
439:              // 						FlagLowLed = TURE;
440:              
441:              // 						// led_deinit();
442:              // 						// motor_PwmOut(0);
443:              // 						// CntLedFlash = 0;
444:              // 						set_work_state(WORK_STATE_LOWBAT_LED);
445:              // 					}
446:              // 					FlagLowPower = TURE;
447:              // 					BatStates = 1;
448:              // 					set_work_state(WORK_STATE_POWEROFF);
449:              // 					// if(!FlagLowPower)
450:              // 					// {
451:              // 					// 	FlagLowLed = TURE;
452:              
453:              // 					// 	// led_deinit();
454:              // 					// 	// motor_PwmOut(0);
455:              // 					// 	// CntLedFlash = 0;
456:              // 					// 	// set_work_state(WORK_STATE_LOWBAT_LED);
457:              // 					// }
458:              // 					// FlagLowPower = TURE;
459:              					
460:              // 				}		 
461:              // 			}
462:              // 			else
463:              // 			{
464:              // 				CntLowPowerOff = 0;
465:              // 			}
466:              			
467:              // 			if(BatStates == 4)		         //3.9~4.2V
468:              // 			{
469:              // 				if(adresultvdd > Voltage3V9)  
470:              // 				{
471:              // 					BatAdcCnt++;
472:              // 					if(BatAdcCnt > 2)
473:              // 					{
474:              // 						BatAdcCnt = 0;
475:              // 						BatStates = 3; 
476:              // 					}
477:              // 				}
478:              // 				else
479:              // 				{
480:              // 					BatAdcCnt = 0;
481:              // 				}
482:              // 			}
483:              // 			else if(BatStates == 3)			//3.6~3.9V
484:              // 			{
485:              // 				if(adresultvdd > Voltage3V6)
486:              // 				{
487:              // 					BatAdcCnt++;
488:              // 					if(BatAdcCnt > 2)
489:              // 					{
490:              // 						BatAdcCnt = 0;
491:              // 						BatStates = 2;
492:              // 					}
493:              // 				}
494:              // 				else
495:              // 				{
496:              // 					BatAdcCnt = 0;
497:              // 				}
498:              // 			}
499:              // 			else if(BatStates == 2)			//3.3~3.6V
500:              // 			{
501:              // 				if(adresultvdd > Voltage3V3)
502:              // 				{
503:              // 					BatAdcCnt++;
504:              // 					if(BatAdcCnt > 2)
505:              // 					{
506:              // 						BatAdcCnt = 0;
507:              // 						BatStates = 1;     //小于3.3V
508:              
509:              // 						// if(!FlagLowPower)
510:              // 						// {
511:              // 						// 	FlagLowLed = TURE;
512:              
513:              // 						// 	// led_deinit();
514:              // 						// 	// motor_PwmOut(0);
515:              // 						// 	// CntLedFlash = 0;
516:              // 						// 	set_work_state(WORK_STATE_LOWBAT_LED);
517:              // 						// }
518:              // 						// FlagLowPower = TURE;
519:              // 						// BatStates = 1;
520:              // 					}
521:              // 				}
522:              // 				else
523:              // 				{
524:              // 					BatAdcCnt = 0;
525:              // 				}
526:              // 			}
527:              // 			// else if(BatStates == 1)			//已经小于3.0
528:              // 			// {
529:              // 			// 	if(adresultvdd > Voltage3V0)
530:              // 			// 	{
531:              // 			// 		BatAdcCnt++;
532:              // 			// 		if(BatAdcCnt > 2)
533:              // 			// 		{
534:              // 			// 			BatAdcCnt = 0;
535:              
536:              // 			// 			if(!FlagLowPower)
537:              // 			// 			{
538:              // 			// 				FlagLowLed = TURE;
539:              
540:              // 			// 				// led_deinit();
541:              // 			// 				// motor_PwmOut(0);
542:              // 			// 				// CntLedFlash = 0;
543:              // 			// 				set_work_state(WORK_STATE_LOWBAT_LED);
544:              // 			// 			}
545:              // 			// 			FlagLowPower = TURE;
546:              // 			// 			BatStates = 1;
547:              // 			// 		}
548:              // 			// 	}
549:              // 			// 	else
550:              // 			// 	{
551:              // 			// 		BatAdcCnt = 0;
552:              // 			// 	}
553:              // 			// }
554:              // 		}
555:              // 	}		
556:              // }
557:              
558:              
559:              // void MotorOverCurrentProtect() //电压过大保护
560:              // {
561:              // //   if(States==2)
562:              // //   {
563:              // 	if(FlagAdcMotorOver)
564:              // 	{
565:              // 		FlagAdcMotorOver=FLASE;
566:              // 		if(adresultmotor>ProtectSet) //电压  todo...
567:              // 		{
568:              // 			if (ModeDuty)
569:              // 			{
570:              // 				Mode2ADCDelay++;
571:              // 				if (Mode2ADCDelay >= 1)
572:              // 				{
573:              // 					Mode2ADCDelay = 0;
574:              // 					CntOverCurrent++;
575:              // 				}
576:              // 			} 
577:              // 			else
578:              // 			{
579:              
580:              // 			}
581:              				
582:              // 			if(CntOverCurrent>2)
583:              // 			{
584:              // 				CntOverCurrent=0; 
585:              // 				set_work_state(WORK_STATE_POWEROFF);
586:              // 			}				
587:              // 	  	}
588:              // 		else
589:              // 		{
590:              // 			//CntOverCurrent=0;			
591:              // 		}			
592:              // 	}	
593:              //   //}	
594:              // }
595:              
596:              // void process_adc_check()
597:              // {
598:              // 	AdcChkVdd();
599:              // 	voltage_check();
600:              // 	MotorOverCurrentProtect();
601:              // }
602:              
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280A    JP	0xA
  000A    280B    JP	0xB
---- start_initialization ------------------------------------------------------------------
  000B    3003    LDIA	0x3
  000C    00E1    LD	0x61,A
  000D    3002    LDIA	0x2
  000E    01E2    CLR	0x62
  000F    01E3    CLR	0x63
  0010    01E4    CLR	0x64
  0011    01E5    CLR	0x65
  0012    00E6    LD	0x66,A
  0013    3005    LDIA	0x5
  0014    01E7    CLR	0x67
  0015    01E8    CLR	0x68
  0016    01E9    CLR	0x69
  0017    01EA    CLR	0x6A
  0018    00EB    LD	0x6B,A
  0019    30A0    LDIA	0xA0
  001A    1383    CLRB	0x3,7
  001B    0084    LD	0x4,A
  001C    30D7    LDIA	0xD7
  001D    27A3    CALL	0x7A3
  001E    3020    LDIA	0x20
  001F    0084    LD	0x4,A
  0020    3053    LDIA	0x53
  0021    27A3    CALL	0x7A3
  0022    01FB    CLR	0x7B
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F9    LD	0x79,A
  0007    080A    LD	A,0xA
  0008    00FA    LD	0x7A,A
  0009    2C4D    JP	0x44D
---- common_function ------------------------------------------------------------------
  0023    0183    CLR	0x3
  0024    2E64    JP	0x664
  0025    00FF    LD	0x7F,A
  0026    3000    LDIA	0x0
  0027    008A    LD	0xA,A
  0028    087F    LD	A,0x7F
  0029    0782    ADDR	0x2
  002A    282A    JP	0x2A
  002B    2F9A    JP	0x79A
  002C    2F53    JP	0x753
  002D    2D2D    JP	0x52D
  012E    101B    CLRB	0x1B,0
  012F    1683    SETB	0x3,5
  0130    1186    CLRB	0x6,3
  0131    1283    CLRB	0x3,5
  0132    1186    CLRB	0x6,3
  0133    0008    RET
  0134    1283    CLRB	0x3,5
  0135    01D3    CLR	0x53
  0136    00D4    LD	0x54,A
  0137    01D5    CLR	0x55
  0138    0008    RET
  022C    3002    LDIA	0x2
  022D    1283    CLRB	0x3,5
  022E    01D3    CLR	0x53
  022F    00D4    LD	0x54,A
  0230    01D5    CLR	0x55
  0231    0008    RET
  0290    1283    CLRB	0x3,5
  0291    1505    SETB	0x5,2
  0292    1683    SETB	0x3,5
  0293    1105    CLRB	0x5,2
  0294    0008    RET
  0448    00D3    LD	0x53,A
  0449    01D4    CLR	0x54
  044A    01D5    CLR	0x55
  044B    0AD5    INCR	0x55
  044C    0008    RET
  0558    01A2    CLR	0x22
  0559    0AA2    INCR	0x22
  055A    01A3    CLR	0x23
  055B    01A4    CLR	0x24
  055C    0008    RET
  06D3    1283    CLRB	0x3,5
  06D4    01CC    CLR	0x4C
  06D5    01CB    CLR	0x4B
  06D6    01CA    CLR	0x4A
  06D7    0008    RET
  0791    30F8    LDIA	0xF8
  07A3    0064    CLRWDT
  07A4    0180    CLR	0x0
  07A5    0A84    INCR	0x4
  07A6    0604    XORA	0x4
  07A7    1903    SZB	0x3,2
  07A8    3400    RET	0x0
  07A9    0604    XORA	0x4
  07AA    2FA4    JP	0x7A4
  07AB    3006    LDIA	0x6
  07D9    1283    CLRB	0x3,5
  07DA    00D3    LD	0x53,A
  07DE    2F51    JP	0x751
  07DF    2F50    JP	0x750
  07E0    2F4F    JP	0x74F
  07E1    2F52    JP	0x752
