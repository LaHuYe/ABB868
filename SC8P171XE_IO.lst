---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\main.c ----------------------------------------------------------------------
1:                /*-------------------------------------------
2:                /////////////////////////////////////////////////////////
3:                //  Project: B98-K3 / 4 modes
4:                //  Write by: yj
5:                //  Date:     2024-03-22
6:                //  Version:  V1
7:                //  CheckSum:
8:                //  MCU:      SC8P1711E/sop14
9:                ////////////////////////////////////////////////////////
10:               //
11:               -------------------------------------------*/
12:               
13:               #include <sc.h>
14:               #include "main.h"
15:               
16:               volatile bit Flag_250us;
17:               volatile bit Flag_1ms;
18:               volatile bit Flag_10ms;
19:               unsigned char Cnt250us = 0;
20:               unsigned int Cnt10ms = 0;
21:               unsigned int Cnt1ms = 0;
22:               unsigned char CntSleep;
23:               
24:               /////////////////////////////////////////// PortInit ///////////////////////////
25:               void PortInit()
26:               {
27:               	TRISA = 0b00000000; // input=1,output=0
  070F    0185    CLR	0x5
28:               	PORTA = 0b00000000;
  0710    1283    CLRB	0x3,5
  0711    0185    CLR	0x5
29:               	WPUA = 0b00000000; // FULL引脚，充电为低，满电为高阻态
  0712    0187    CLR	0x7
30:               	IOCA = 0b00000000;
  0713    0189    CLR	0x9
31:               
32:               	TRISB = 0b00010111; // input=1,output=0
  0714    3017    LDIA	0x17
  0715    1683    SETB	0x3,5
  0716    0086    LD	0x6,A
33:               	PORTB = 0b00000000;
  0717    1283    CLRB	0x3,5
  0718    0186    CLR	0x6
34:               	ANSELH = 0b00010000;
  0719    3010    LDIA	0x10
  071A    1683    SETB	0x3,5
  071B    0094    LD	0x14,A
35:               	WPUB = 0b00000111;
  071C    3007    LDIA	0x7
  071D    0095    LD	0x15,A
36:               	IOCB = 0b00000000; // wakeup,
  071E    0196    CLR	0x16
  071F    0008    RET
37:               }
38:               
39:               /////////////////////////////////////////// TimerConfig ///////////////////////////
40:               void Timer0Cofng()
41:               {
42:               	OPTION_REG = 0B00000000; // TMR0时钟 Fsys/4 4Mhz  预分频 /32  0.125Mhz 8us
  07A4    0181    CLR	0x1
43:               
44:               	// 50us
45:               	TMR0 = 165; // 215;//165;			//实测132为1ms
  07A5    30A5    LDIA	0xA5
  07A6    1283    CLRB	0x3,5
  07A7    0081    LD	0x1,A
46:               
47:               	T0IF = 0;
  07A8    110B    CLRB	0xB,2
48:               	T0IE = 1; // 使能Timer0溢出中断
  07A9    168B    SETB	0xB,5
  07AA    0008    RET
49:               }
50:               
51:               /////////////////////////////////////////// TimerConfig ///////////////////////////
52:               void Timer2Config()
53:               {
54:               	/////// timer2
55:               	// PR2 = 24;					//=125*4*16/8M=1mS
56:               	// TMR2IF = 0;
57:               	// TMR2IE = 1;					//=
58:               
59:               	// T2CON = 0X78;			//=
60:               	// TMR2ON=1;
61:               	/////// timer2
62:               	PR2 = 250; // 设定Timer初始值，定时周期是250us=250
  0766    30FA    LDIA	0xFA
  0767    1683    SETB	0x3,5
  0768    0092    LD	0x12,A
63:               	TMR2IF = 0;
  0769    1283    CLRB	0x3,5
  076A    108C    CLRB	0xC,1
64:               	TMR2IE = 1;			// 使能Timer2溢出中断
  076B    1683    SETB	0x3,5
  076C    148C    SETB	0xC,1
65:               	T2CON = 0B00011100; // 开启Timer2,设置TMR2的预分频比为1:1，后分频1:2
  076D    301C    LDIA	0x1C
  076E    1283    CLRB	0x3,5
  076F    0092    LD	0x12,A
  0770    0008    RET
66:               }
67:               
68:               /////////////////////////////////////////// AdcConfig ///////////////////////////
69:               void AdcConfig()
70:               {
71:               	ADCON0 = 0b00111101; // AN15
  07B8    303D    LDIA	0x3D
  07B9    1283    CLRB	0x3,5
  07BA    009F    LD	0x1F,A
72:               	ADCON1 = 0b00000000; // VDD
  07BB    1683    SETB	0x3,5
  07BC    019F    CLR	0x1F
  07BD    0008    RET
73:               }
74:               
75:               // /////////////////////////////////////////// PwmConfig ///////////////////////////
76:               void PwmConfig()
77:               {
78:               	PWMCON = 0B01100000; // PWM选择时钟源为Fosc/16   8M/800=10000,10000/64=156
  07AB    3060    LDIA	0x60
  07AC    1283    CLRB	0x3,5
  07AD    009B    LD	0x1B,A
79:               	PWMTH = 0B00000000;	 // 周期的时钟分频在PWMCON选择
  07AE    019A    CLR	0x1A
80:               	PWMTL = 99;			 // 10K
  07AF    3063    LDIA	0x63
  07B0    0099    LD	0x19,A
  07B1    0008    RET
81:               }
82:               
83:               // #define _XTAL_FREQ 8000000UL		//如果用16M晶振则改为16000000UL
84:               
85:               void main(void)
  0635    0000    NOP
  0636    0064    CLRWDT
86:               {
87:               	asm("nop");
88:               	asm("clrwdt");
89:               	OSCCON = 0X70; // 为8M/4=2M
  0637    3070    LDIA	0x70
  0638    1683    SETB	0x3,5
  0639    008F    LD	0xF,A
90:               
91:               	PortInit();
  063A    270F    CALL	0x70F
92:               	Timer0Cofng();
  063B    27A4    CALL	0x7A4
93:               	Timer2Config();
  063C    2766    CALL	0x766
94:               	AdcConfig();
  063D    27B8    CALL	0x7B8
95:               	PwmConfig();
  063E    27AB    CALL	0x7AB
  063F    0064    CLRWDT
96:               
97:               	asm("clrwdt");
98:               	INTCON |= 0XC0; // 开启中断
  0640    30C0    LDIA	0xC0
  0641    048B    ORR	0xB
99:               	SWDTEN = 1;		// enable wdt
  0642    1683    SETB	0x3,5
  0643    1408    SETB	0x8,0
100:              
101:              	app_process_set_work_state(WORK_STATE_POWEROFF);
  0644    3000    LDIA	0x0
  0645    27BE    CALL	0x7BE
102:              	app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  0646    3000    LDIA	0x0
  0647    27C3    CALL	0x7C3
103:              
104:              #if 0
105:              	BatStates = 1;
106:              	app_charge.Remind = 1;
107:              
108:              #endif
109:              	// FlagOldMode = 1;
110:              	// app_work_state = WORK_STATE_WORKING;
111:              	// // work_mode.mode = 3;
112:              	// // led_pwm_ctrl(LED_INDEX_1,ON);
113:              	// app_charge.FullCharge = 1;
114:              	// app_charge.Charge = 1;
115:              	//  BatStates = 2;
116:              	//  app_work_state = WORK_STATE_WORKING;
117:              	// app_charge.LowPower = 1;
118:              	while (1)
  0648    0064    CLRWDT
119:              	{
120:              		asm("clrwdt");
121:              
122:              		if (Flag_10ms)
  0649    1C7B    SNZB	0x7B,0
  064A    2E48    JP	0x648
123:              		{
124:              			Flag_10ms = 0;
  064B    107B    CLRB	0x7B,0
125:              			app_adc_process();
  064C    27CE    CALL	0x7CE
126:              			app_process_charge();
  064D    27CD    CALL	0x7CD
127:              
128:              			app_process_key();
  064E    27B2    CALL	0x7B2
129:              			app_process_work();		  // brush
  064F    26ED    CALL	0x6ED
130:              			app_water_process_work(); // water
  0650    2730    CALL	0x730
131:              
132:              			app_process_go_to_sleep();
  0651    26FE    CALL	0x6FE
133:              			process_led_remind_low_power();
  0652    21C3    CALL	0x1C3
  0653    2E48    JP	0x648
134:              		}
135:              	}
136:              }
137:              
138:              /////////////////////////////////////////// GotoSleep ///////////////////////////
139:              void GotoSleep()
140:              {
141:              	if (IO_KEY_BRUSH_PWR && IO_KEY_WATER_PWR && IO_KEY_WATER_MODE)
  03D5    1283    CLRB	0x3,5
  03D6    1906    SZB	0x6,2
  03D7    1C06    SNZB	0x6,0
  03D8    2C10    JP	0x410
  03D9    1C86    SNZB	0x6,1
  03DA    2C10    JP	0x410
  03DB    30C8    LDIA	0xC8
142:              	{
143:              
144:              		CntSleep++;
  03DC    0AC1    INCR	0x41
145:              		if (CntSleep >= 200)
  03DD    0241    SUBA	0x41
  03DE    1C03    SNZB	0x3,0
  03DF    0008    RET
146:              		{
147:              			CntSleep = 0;
  03E0    01C1    CLR	0x41
148:              			// ADC
149:              			ADCON0 = 0b00000000;
  03E1    019F    CLR	0x1F
150:              			ADCON1 = 0b00000000;
  03E2    1683    SETB	0x3,5
  03E3    019F    CLR	0x1F
151:              			//
152:              			SWDTEN = 0;
  03E4    1008    CLRB	0x8,0
153:              			WDTCON = 0x00;
  03E5    0188    CLR	0x8
154:              			//
155:              			GIE = 0;
  03E6    138B    CLRB	0xB,7
156:              			TRISB = 0b00010111; // input=1,output=0
  03E7    3017    LDIA	0x17
  03E8    0086    LD	0x6,A
157:              			WPUB = 0b00000111;
  03E9    3007    LDIA	0x7
  03EA    0095    LD	0x15,A
158:              			TRISA = 0b00000000; // input=1,output=0
  03EB    0185    CLR	0x5
159:              			PORTA = 0b00000000;
  03EC    1283    CLRB	0x3,5
  03ED    0185    CLR	0x5
160:              			ChargePwmOut(0);
  03EE    3000    LDIA	0x0
  03EF    2720    CALL	0x720
161:              			//
162:              			ANSELH = 0b00000000;
  03F0    1683    SETB	0x3,5
  03F1    0194    CLR	0x14
163:              			//
164:              
165:              			IOCA = 0b00000000;
  03F2    1283    CLRB	0x3,5
  03F3    0189    CLR	0x9
166:              			IOCB = 0b00010111; // wakeup,
  03F4    3017    LDIA	0x17
  03F5    1683    SETB	0x3,5
  03F6    0096    LD	0x16,A
167:              
168:              			RAIE = 1;
  03F7    158C    SETB	0xC,3
169:              			RBIE = 1;
  03F8    158B    SETB	0xB,3
170:              			PEIE = 1;
  03F9    170B    SETB	0xB,6
171:              
172:              			RAIF = 0; // clear flag
  03FA    1283    CLRB	0x3,5
  03FB    118C    CLRB	0xC,3
173:              			PORTA;	  /// this must have
  03FC    0805    LD	A,0x5
174:              			RBIF = 0; // clear flag
  03FD    100B    CLRB	0xB,0
175:              			PORTB;	  /// this must have
  03FE    0806    LD	A,0x6
  03FF    0064    CLRWDT
  0400    0063    STOP
  0401    0000    NOP
  0402    0000    NOP
  0403    0000    NOP
176:              
177:              			asm("clrwdt");
178:              			asm("sleep"); /// goto sleep
179:              
180:              			asm("nop"); /// wake up
181:              			asm("nop");
182:              			asm("nop");
183:              			// ADC
184:              			ADON = 1;
  0404    1283    CLRB	0x3,5
  0405    141F    SETB	0x1F,0
185:              			//
186:              			SWDTEN = 1;
  0406    1683    SETB	0x3,5
  0407    1408    SETB	0x8,0
187:              			//  RB1 RB2 RA3
188:              			IOCB = 0x00; // 0b 0000 0110
  0408    0196    CLR	0x16
189:              			IOCA = 0x00; // 0b 0000 1000
  0409    1283    CLRB	0x3,5
  040A    0189    CLR	0x9
190:              			//
191:              			GIE = 1;
  040B    178B    SETB	0xB,7
192:              
193:              			SWDTEN = 1;
  040C    1683    SETB	0x3,5
  040D    1408    SETB	0x8,0
194:              			AdcConfig();
  040E    27B8    CALL	0x7B8
195:              			PortInit();
  040F    2F0F    JP	0x70F
196:              		}
197:              	}
198:              	else
199:              	{
200:              		CntSleep = 0;
  0410    01C1    CLR	0x41
  0411    0008    RET
201:              	}
202:              }
203:              
204:              /***********************************************
205:              //1ms
206:              ************************************************/
207:              void interrupt Timer2_Isr(void)
208:              {
209:              	// RB5 = 1;
210:              	//  if(T0IF)
211:              	//  {
212:              	//  	//RB5 = ~RB5;
213:              	//  	T0IF = 0;
214:              
215:              	// 	#if DEBUG
216:              	// 	//TMR0 +=  256 - 5;
217:              	// 	#endif
218:              	// 	app_motor_pwm_out();
219:              	// 	led_old_mode_pwm();
220:              	// }
221:              	if (PWMIF)
  044D    1283    CLRB	0x3,5
  044E    190C    SZB	0xC,2
222:              	{
223:              		PWMIF = 0;
  044F    110C    CLRB	0xC,2
224:              	}
225:              
226:              	if (T0IF) // 50us中断
  0450    1D0B    SNZB	0xB,2
  0451    2C57    JP	0x457
227:              	{
228:              		TMR0 = 165; // 215;//165;			//TMR0不能自动赋值
  0452    30A5    LDIA	0xA5
  0453    0081    LD	0x1,A
229:              		T0IF = 0;
  0454    110B    CLRB	0xB,2
230:              		Mode_control(); // 牙刷电机驱动
  0455    2346    CALL	0x346
231:              		led_charge_pwm();
  0456    2139    CALL	0x139
232:              		// Cnt250us++;
233:              		//  if (Cnt250us >= 5)
234:              		//  {
235:              		//  	MotorWaterDrive();
236:              		//  	Cnt250us = 0;
237:              		//  	Flag_250us = 1;
238:              		//  }
239:              	}
240:              	if (TMR2IF)
  0457    1283    CLRB	0x3,5
  0458    1C8C    SNZB	0xC,1
  0459    2C77    JP	0x477
241:              	{
242:              		TMR2IF = 0;
  045A    108C    CLRB	0xC,1
243:              		Cnt10ms++;
  045B    1683    SETB	0x3,5
  045C    0ACD    INCR	0x4D
  045D    1903    SZB	0x3,2
  045E    0ACE    INCR	0x4E
244:              		Cnt1ms++;
  045F    0ACB    INCR	0x4B
  0460    1903    SZB	0x3,2
  0461    0ACC    INCR	0x4C
245:              		MotorWaterDrive();
  0462    26DA    CALL	0x6DA
246:              		if (Cnt1ms == 4)
  0463    3004    LDIA	0x4
  0464    1683    SETB	0x3,5
  0465    064B    XORA	0x4B
  0466    044C    ORA	0x4C
  0467    1D03    SNZB	0x3,2
  0468    2C6C    JP	0x46C
247:              		{
248:              			Cnt1ms = 0;
  0469    01CB    CLR	0x4B
  046A    01CC    CLR	0x4C
249:              			process_led();
  046B    2232    CALL	0x232
250:              		}
251:              		if (Cnt10ms >= 40) // 100 * 100 = 10000us = 10ms
  046C    3000    LDIA	0x0
  046D    1683    SETB	0x3,5
  046E    024E    SUBA	0x4E
  046F    3028    LDIA	0x28
  0470    1903    SZB	0x3,2
  0471    024D    SUBA	0x4D
  0472    1C03    SNZB	0x3,0
  0473    2C77    JP	0x477
252:              		{
253:              			Cnt10ms = 0;
  0474    01CD    CLR	0x4D
  0475    01CE    CLR	0x4E
254:              			Flag_10ms = 1;
  0476    147B    SETB	0x7B,0
255:              		}
256:              	}
257:              	if (RAIF)
  0477    1283    CLRB	0x3,5
  0478    1D8C    SNZB	0xC,3
  0479    2C7C    JP	0x47C
258:              	{
259:              		RAIF = 0; //
  047A    118C    CLRB	0xC,3
260:              		PORTA;	  //
  047B    0805    LD	A,0x5
261:              	}
262:              	if (RBIF)
  047C    1C0B    SNZB	0xB,0
  047D    2C80    JP	0x480
263:              	{
264:              		RBIF = 0; //
  047E    100B    CLRB	0xB,0
265:              		PORTB;	  //
  047F    0806    LD	A,0x6
  0480    087A    LD	A,0x7A
  0481    008A    LD	0xA,A
  0482    0E79    SWAPA	0x79
  0483    0083    LD	0x3,A
  0484    0EFE    SWAPR	0x7E
  0485    0E7E    SWAPA	0x7E
  0486    0009    RETI
266:              	}
267:              	// RB5 = 0;
268:              }
269:              
270:              /*
271:              	长按按键老化的时候没有做低电处理
272:              	充电的时候应该只关闭电机，不关闭灯
273:              
274:              */
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_led.c ----------------------------------------------------------------------
1:                #include "main.h"
2:                
3:                uint16_t CntLedFlash;
4:                // #define _XTAL_FREQ 8000000UL		//如果用16M晶振则改为16000000UL
5:                
6:                // uint16_t PWM_Cnt;
7:                
8:                // bit led_lock;
9:                
10:               bit PWM_dir;
11:               uint16_t PWM_Duty;
12:               uint16_t PWM_Cnt;
13:               
14:               // typedef enum
15:               // {
16:               //     LED_STATE_OFF = 0,
17:               //     LED_STATE_ON = !LED_STATE_OFF,
18:               // }led_state_t;
19:               
20:               uint32_t led_index;
21:               // uint8_t led_state;
22:               
23:               // 单独的灯
24:               void led_pwm_ctrl(led_index_t index, uint8_t state)
25:               {
26:                   led_index |= index;
27:               }
28:               
29:               void led_pwm_close(led_index_t index, uint8_t state)
30:               {
31:                   if ((led_index & LED_INDEX_1) == (index & LED_INDEX_1))
32:                   {
33:                       led_index &= ~LED_INDEX_1;
34:                   }
35:                   if ((led_index & LED_INDEX_1) == (index & LED_INDEX_1))
36:                   {
37:                       led_index &= ~LED_INDEX_2;
38:                   }
39:                   if ((led_index & LED_INDEX_1) == (index & LED_INDEX_1))
40:                   {
41:                       led_index &= ~LED_INDEX_3;
42:                   }
43:                   if (led_index == LED_INDEX_ALL)
44:                   {
45:                       led_index = 0;
46:                   }
47:               }
48:               
49:               // 呼吸灯
50:               bit PWM_dir;
51:               uint16_t PWM_Duty = 0;
52:               uint16_t PWM_Cnt;
53:               #define pwm_time 200
54:               uint16_t pwm_timer;
55:               #define PWM_WHAT 199
56:               
57:               bit is_charge_pwm;
58:               void led_charge_pwm()
59:               {
60:                   if (WORK_STATE_CHARGING == app_work_state)
  0139    3002    LDIA	0x2
  013A    066D    XORA	0x6D
  013B    1D03    SNZB	0x3,2
  013C    29BD    JP	0x1BD
61:                   {
62:                       if (app_charge.Charge)
  013D    1683    SETB	0x3,5
  013E    1C20    SNZB	0x20,0
  013F    0008    RET
63:                       {
64:                            IO_LED1 = 0;
  0140    1283    CLRB	0x3,5
  0141    1005    CLRB	0x5,0
65:                           TRISA &= ~BIT(0);
  0142    1683    SETB	0x3,5
  0143    1005    CLRB	0x5,0
66:                            IO_LED2 = 0;
  0144    1283    CLRB	0x3,5
  0145    1085    CLRB	0x5,1
67:                           TRISA &= ~BIT(1);
  0146    1683    SETB	0x3,5
  0147    1085    CLRB	0x5,1
68:                           IO_LED6 = 0;
  0148    1283    CLRB	0x3,5
  0149    1305    CLRB	0x5,6
69:                           TRISA &= ~BIT(6);
  014A    1683    SETB	0x3,5
  014B    1305    CLRB	0x5,6
70:                           if (app_charge.flag_charge_force_full_24hour)
  014C    1DA0    SNZB	0x20,3
  014D    2955    JP	0x155
  014E    3003    LDIA	0x3
71:                           {
72:                               is_charge_pwm = 0;
  014F    11FB    CLRB	0x7B,3
73:                               set_led_state(LED_INDEX_9 | LED_INDEX_10, LED_STATE_OFF);
  0150    01F0    CLR	0x70
  0151    00F1    LD	0x71,A
  0152    01F2    CLR	0x72
  0153    24E6    CALL	0x4E6
74:                           }
  0154    0008    RET
75:                           else if (app_charge.FullCharge || app_charge.ForceFullCharge)
  0155    18A0    SZB	0x20,1
  0156    2959    JP	0x159
  0157    1D20    SNZB	0x20,2
  0158    2966    JP	0x166
  0159    3001    LDIA	0x1
76:                           {
77:                               is_charge_pwm = 0;
  015A    11FB    CLRB	0x7B,3
78:                               set_led_state(LED_INDEX_9, LED_STATE_ON);
  015B    01F0    CLR	0x70
  015C    00F1    LD	0x71,A
  015D    01F2    CLR	0x72
  015E    0AF2    INCR	0x72
  015F    24E6    CALL	0x4E6
79:                               set_led_state(LED_INDEX_10, LED_STATE_OFF);
  0160    3002    LDIA	0x2
  0161    01F0    CLR	0x70
  0162    00F1    LD	0x71,A
  0163    01F2    CLR	0x72
  0164    24E6    CALL	0x4E6
80:                           }
  0165    0008    RET
81:                           else
82:                           {
83:                               is_charge_pwm = 1;
  0166    15FB    SETB	0x7B,3
84:                               PWM_Cnt++;
  0167    1283    CLRB	0x3,5
  0168    0AAC    INCR	0x2C
  0169    1903    SZB	0x3,2
  016A    0AAD    INCR	0x2D
85:                               //
86:                               //  PWM_Duty = 50;
87:                               if (PWM_Duty >= PWM_Cnt) // 100us进来一次    50 * 100
  016B    082D    LD	A,0x2D
  016C    022F    SUBA	0x2F
  016D    1D03    SNZB	0x3,2
  016E    2971    JP	0x171
  016F    082C    LD	A,0x2C
  0170    022E    SUBA	0x2E
  0171    1C03    SNZB	0x3,0
  0172    297F    JP	0x17F
88:                               {
89:                                   IO_LED3 = 1;
  0173    1505    SETB	0x5,2
90:                                   TRISA &= ~BIT(2);
  0174    1683    SETB	0x3,5
  0175    1105    CLRB	0x5,2
91:                                   IO_LED5 = 0;
  0176    1283    CLRB	0x3,5
  0177    1205    CLRB	0x5,4
92:                                   TRISA &= ~BIT(4);
  0178    1683    SETB	0x3,5
  0179    1205    CLRB	0x5,4
93:                                   IO_LED4 = 1;
  017A    1283    CLRB	0x3,5
  017B    1585    SETB	0x5,3
94:                                   TRISA &= ~BIT(3);
  017C    1683    SETB	0x3,5
  017D    1185    CLRB	0x5,3
95:                               }
  017E    2986    JP	0x186
96:                               else
97:                               {
98:                                   IO_LED3 = 0;
  017F    1105    CLRB	0x5,2
99:                                   TRISA &= ~BIT(2);
  0180    1683    SETB	0x3,5
  0181    1105    CLRB	0x5,2
100:                                  IO_LED5 = 0;
  0182    1283    CLRB	0x3,5
  0183    1205    CLRB	0x5,4
101:                                  TRISA &= ~BIT(4);
  0184    1683    SETB	0x3,5
  0185    1205    CLRB	0x5,4
102:                              }
103:                              if (PWM_Cnt >= PWM_WHAT) // 每50us PWM_Cnt加一次 ，
  0186    3000    LDIA	0x0
  0187    1283    CLRB	0x3,5
  0188    022D    SUBA	0x2D
  0189    30C7    LDIA	0xC7
  018A    1903    SZB	0x3,2
  018B    022C    SUBA	0x2C
  018C    1C03    SNZB	0x3,0
  018D    2990    JP	0x190
104:                              {
105:                                  PWM_Cnt = 0;
  018E    01AC    CLR	0x2C
  018F    01AD    CLR	0x2D
106:                              }
107:                              pwm_timer++;
  0190    0AAA    INCR	0x2A
  0191    1903    SZB	0x3,2
  0192    0AAB    INCR	0x2B
108:                              if (!PWM_dir)
  0193    1A7B    SZB	0x7B,4
  0194    29A9    JP	0x1A9
109:                              {
110:                                  if (pwm_timer >= pwm_time) // 50us * 200
  0195    3000    LDIA	0x0
  0196    022B    SUBA	0x2B
  0197    30C8    LDIA	0xC8
  0198    1903    SZB	0x3,2
  0199    022A    SUBA	0x2A
  019A    1C03    SNZB	0x3,0
  019B    0008    RET
  019C    3000    LDIA	0x0
111:                                  {
112:                                      pwm_timer = 0;
  019D    01AA    CLR	0x2A
  019E    01AB    CLR	0x2B
113:              
114:                                      if (PWM_Duty >= PWM_WHAT)
  019F    022F    SUBA	0x2F
  01A0    30C7    LDIA	0xC7
  01A1    1903    SZB	0x3,2
  01A2    022E    SUBA	0x2E
  01A3    1803    SZB	0x3,0
115:                                      {
116:                                          PWM_dir = 1;
  01A4    167B    SETB	0x7B,4
117:                                      }
118:                                      PWM_Duty++;
  01A5    0AAE    INCR	0x2E
  01A6    1903    SZB	0x3,2
  01A7    0AAF    INCR	0x2F
  01A8    0008    RET
119:                                  }
120:                              }
121:                              else
122:                              {
123:                                  if (pwm_timer >= pwm_time) // 每进来一次
  01A9    3000    LDIA	0x0
  01AA    022B    SUBA	0x2B
  01AB    30C8    LDIA	0xC8
  01AC    1903    SZB	0x3,2
  01AD    022A    SUBA	0x2A
  01AE    1C03    SNZB	0x3,0
  01AF    0008    RET
  01B0    3001    LDIA	0x1
124:                                  {
125:              
126:                                      pwm_timer = 0;
  01B1    01AA    CLR	0x2A
  01B2    01AB    CLR	0x2B
127:                                      // PWM_Cnt = 0;
128:                                      // 换方向
129:                                      PWM_Duty--;
  01B3    02AE    SUBR	0x2E
  01B4    3000    LDIA	0x0
  01B5    1C03    SNZB	0x3,0
  01B6    03AF    DECR	0x2F
  01B7    02AF    SUBR	0x2F
130:                                      if (!PWM_Duty)
  01B8    082E    LD	A,0x2E
  01B9    042F    ORA	0x2F
  01BA    1903    SZB	0x3,2
131:                                      {
132:                                          PWM_dir = 0;
  01BB    127B    CLRB	0x7B,4
  01BC    0008    RET
133:                                      }
134:                                  }
135:                              }
136:                          }
137:                      }
138:                  }
139:                  else
140:                  {
141:                      is_charge_pwm = 0;
  01BD    11FB    CLRB	0x7B,3
142:                      PWM_Cnt = 0;
  01BE    01AC    CLR	0x2C
  01BF    01AD    CLR	0x2D
143:                      pwm_timer = 0;
  01C0    01AA    CLR	0x2A
  01C1    01AB    CLR	0x2B
  01C2    0008    RET
144:                  }
145:              }
146:              
147:              void app_led_mode_set()
148:              {
149:                  if (work_mode.mode == WORK_MODE_ONE)
  060F    1283    CLRB	0x3,5
  0610    0B66    SZDECA	0x66
  0611    2E1D    JP	0x61D
150:                  {
151:                      set_led_state(LED_INDEX_2 | LED_INDEX_3, LED_STATE_OFF);
  0612    3006    LDIA	0x6
  0613    00D3    LD	0x53,A
  0614    01D4    CLR	0x54
  0615    01D5    CLR	0x55
  0616    256E    CALL	0x56E
152:                      set_led_state(LED_INDEX_1, LED_STATE_ON);
  0617    01D3    CLR	0x53
  0618    0AD3    INCR	0x53
  0619    01D4    CLR	0x54
  061A    01D5    CLR	0x55
  061B    0AD5    INCR	0x55
  061C    2D6E    JP	0x56E
153:                  }
154:                  else if (work_mode.mode == WORK_MODE_TWO)
  061D    3002    LDIA	0x2
  061E    0666    XORA	0x66
  061F    1D03    SNZB	0x3,2
  0620    2E29    JP	0x629
155:                  {
156:                      set_led_state(LED_INDEX_1 | LED_INDEX_3, LED_STATE_OFF);
  0621    3005    LDIA	0x5
  0622    00D3    LD	0x53,A
  0623    01D4    CLR	0x54
  0624    01D5    CLR	0x55
  0625    256E    CALL	0x56E
157:                      set_led_state(LED_INDEX_2, LED_STATE_ON);
  0626    3002    LDIA	0x2
  0627    2448    CALL	0x448
  0628    2D6E    JP	0x56E
158:                  }
159:                  else if (work_mode.mode == WORK_MODE_THREE)
  0629    3003    LDIA	0x3
  062A    0666    XORA	0x66
  062B    1D03    SNZB	0x3,2
  062C    0008    RET
160:                  {
161:                      set_led_state(LED_INDEX_1 | LED_INDEX_2, LED_STATE_OFF);
  062D    3003    LDIA	0x3
  062E    00D3    LD	0x53,A
  062F    01D4    CLR	0x54
  0630    01D5    CLR	0x55
  0631    256E    CALL	0x56E
162:                      set_led_state(LED_INDEX_3, LED_STATE_ON);
  0632    3004    LDIA	0x4
  0633    2448    CALL	0x448
  0634    2D6E    JP	0x56E
163:                  }
164:              }
165:              
166:              void app_led_water_mode_set()
167:              {
168:                  if (water_work_mode.water_mode == WATER_WORK_MODE_ONE)
  0412    1283    CLRB	0x3,5
  0413    0B61    SZDECA	0x61
  0414    2C1D    JP	0x41D
169:                  {
170:                      set_led_state(LED_INDEX_8, LED_STATE_ON);
  0415    3080    LDIA	0x80
  0416    2448    CALL	0x448
  0417    256E    CALL	0x56E
171:                      set_led_state(LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0418    3078    LDIA	0x78
  0419    00D3    LD	0x53,A
  041A    01D4    CLR	0x54
  041B    01D5    CLR	0x55
  041C    2D6E    JP	0x56E
172:                  }
173:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_TWO)
  041D    3002    LDIA	0x2
  041E    0661    XORA	0x61
  041F    1D03    SNZB	0x3,2
  0420    2C29    JP	0x429
174:                  {
175:                      set_led_state(LED_INDEX_8 | LED_INDEX_7, LED_STATE_ON);
  0421    30C0    LDIA	0xC0
  0422    2448    CALL	0x448
  0423    256E    CALL	0x56E
176:                      set_led_state(LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0424    3038    LDIA	0x38
  0425    00D3    LD	0x53,A
  0426    01D4    CLR	0x54
  0427    01D5    CLR	0x55
  0428    2D6E    JP	0x56E
177:                  }
178:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_THREE)
  0429    3003    LDIA	0x3
  042A    0661    XORA	0x61
  042B    1D03    SNZB	0x3,2
  042C    2C35    JP	0x435
179:                  {
180:                      set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6, LED_STATE_ON);
  042D    30E0    LDIA	0xE0
  042E    2448    CALL	0x448
  042F    256E    CALL	0x56E
181:                      set_led_state(LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0430    3018    LDIA	0x18
  0431    00D3    LD	0x53,A
  0432    01D4    CLR	0x54
  0433    01D5    CLR	0x55
  0434    2D6E    JP	0x56E
182:                  }
183:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_FOUR)
  0435    3004    LDIA	0x4
  0436    0661    XORA	0x61
  0437    1D03    SNZB	0x3,2
  0438    2C41    JP	0x441
184:                  {
185:                      set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5, LED_STATE_ON);
  0439    30F0    LDIA	0xF0
  043A    2448    CALL	0x448
  043B    256E    CALL	0x56E
186:                      set_led_state(LED_INDEX_4, LED_STATE_OFF);
  043C    3008    LDIA	0x8
  043D    00D3    LD	0x53,A
  043E    01D4    CLR	0x54
  043F    01D5    CLR	0x55
  0440    2D6E    JP	0x56E
187:                  }
188:                  else if (water_work_mode.water_mode == WATER_WORK_MODE_FIVE)
  0441    3005    LDIA	0x5
  0442    0661    XORA	0x61
  0443    1D03    SNZB	0x3,2
  0444    0008    RET
189:                  {
190:                      set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_ON);
  0445    30F8    LDIA	0xF8
  0446    2448    CALL	0x448
  0447    2D6E    JP	0x56E
191:                  }
192:              }
193:              
194:              void process_led_remind_low_power()
195:              {
196:                  if (app_charge.LowPower)
  01C3    1683    SETB	0x3,5
  01C4    0826    LD	A,0x26
  01C5    1903    SZB	0x3,2
  01C6    29ED    JP	0x1ED
197:                  {
198:                      if (app_charge.LowLed)
  01C7    0827    LD	A,0x27
  01C8    1903    SZB	0x3,2
  01C9    0008    RET
  01CA    3002    LDIA	0x2
199:                      {
200:                          app_charge.LowLed_cnt++;
  01CB    0AA8    INCR	0x28
201:                          if (app_charge.LowLed_cnt <= 1)
  01CC    0228    SUBA	0x28
  01CD    1803    SZB	0x3,0
  01CE    29DA    JP	0x1DA
202:                          {
203:                              app_process_set_work_state(WORK_STATE_POWEROFF);
  01CF    3000    LDIA	0x0
  01D0    27BE    CALL	0x7BE
204:                              app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  01D1    3000    LDIA	0x0
  01D2    27C3    CALL	0x7C3
205:                              app_charge.low_led_blink_cnt = 5;
  01D3    3005    LDIA	0x5
  01D4    1683    SETB	0x3,5
  01D5    00B1    LD	0x31,A
206:                              set_led_dirct_state(LED_INDEX_NULL);
  01D6    1283    CLRB	0x3,5
  01D7    01D3    CLR	0x53
  01D8    01D4    CLR	0x54
  01D9    2F9D    JP	0x79D
207:                          }
208:                          else if (app_charge.LowLed_cnt < 25)
  01DA    3019    LDIA	0x19
  01DB    0228    SUBA	0x28
  01DC    1803    SZB	0x3,0
  01DD    29E1    JP	0x1E1
209:                          {
210:                              set_led_state(LED_INDEX_10, LED_STATE_ON);
  01DE    222C    CALL	0x22C
  01DF    0AD5    INCR	0x55
  01E0    2D6E    JP	0x56E
211:                          }
212:                          else if (app_charge.LowLed_cnt < 50)
  01E1    3032    LDIA	0x32
  01E2    0228    SUBA	0x28
  01E3    1803    SZB	0x3,0
  01E4    29E7    JP	0x1E7
213:                          {
214:                              set_led_state(LED_INDEX_10, LED_STATE_OFF);
  01E5    222C    CALL	0x22C
  01E6    2D6E    JP	0x56E
215:                          }
216:                          else
217:                          {
218:                              app_charge.low_led_blink_cnt--;
  01E7    03B1    DECR	0x31
219:                              if (!app_charge.low_led_blink_cnt)
  01E8    1903    SZB	0x3,2
220:                              {
221:                                  app_charge.LowLed = FLASE;
  01E9    01A7    CLR	0x27
222:                              }
223:                              app_charge.LowLed_cnt = 2;
  01EA    3002    LDIA	0x2
  01EB    00A8    LD	0x28,A
  01EC    0008    RET
224:                          }
225:                      }
226:                  }
227:                  else if (app_charge.Remind)
  01ED    1E20    SNZB	0x20,4
  01EE    2A28    JP	0x228
228:                  {
229:                      if (app_work_state == WORK_STATE_WORKING || water_work_state == WATER_WORK_STATE_WORKING || app_charge.flag_remind_delay_10s)
  01EF    1283    CLRB	0x3,5
  01F0    036D    DECA	0x6D
  01F1    1903    SZB	0x3,2
  01F2    29FA    JP	0x1FA
  01F3    036C    DECA	0x6C
  01F4    1903    SZB	0x3,2
  01F5    29FA    JP	0x1FA
  01F6    1683    SETB	0x3,5
  01F7    0822    LD	A,0x22
  01F8    1903    SZB	0x3,2
  01F9    0008    RET
230:                      {
231:                          CntLedFlash++;
  01FA    1283    CLRB	0x3,5
  01FB    0AB0    INCR	0x30
  01FC    1903    SZB	0x3,2
  01FD    0AB1    INCR	0x31
232:                          if (CntLedFlash <= MS(500))
  01FE    3000    LDIA	0x0
  01FF    0231    SUBA	0x31
  0200    3033    LDIA	0x33
  0201    1903    SZB	0x3,2
  0202    0230    SUBA	0x30
  0203    1C03    SNZB	0x3,0
  0204    29DE    JP	0x1DE
233:                          {
234:                              set_led_state(LED_INDEX_10, LED_STATE_ON);
235:                          }
236:                          else if (CntLedFlash <= MS(1000))
  0205    3000    LDIA	0x0
  0206    0231    SUBA	0x31
  0207    3065    LDIA	0x65
  0208    1903    SZB	0x3,2
  0209    0230    SUBA	0x30
  020A    1C03    SNZB	0x3,0
  020B    29E5    JP	0x1E5
237:                          {
238:                              set_led_state(LED_INDEX_10, LED_STATE_OFF);
239:                          }
240:                          else
241:                          {
242:                              CntLedFlash = 0;
  020C    01B0    CLR	0x30
  020D    01B1    CLR	0x31
243:                              if (app_charge.flag_remind_delay_10s)
  020E    1683    SETB	0x3,5
  020F    0822    LD	A,0x22
  0210    1903    SZB	0x3,2
  0211    0008    RET
244:                              {
245:                                  //低电关机亮灯10S
246:                                  if (++app_charge.remind_delay_10s_timer >= 10)
  0212    0AA3    INCR	0x23
  0213    1903    SZB	0x3,2
  0214    0AA4    INCR	0x24
  0215    3000    LDIA	0x0
  0216    0224    SUBA	0x24
  0217    300A    LDIA	0xA
  0218    1903    SZB	0x3,2
  0219    0223    SUBA	0x23
  021A    1C03    SNZB	0x3,0
  021B    0008    RET
  021C    3002    LDIA	0x2
247:                                  {
248:                                      app_charge.flag_remind_delay_10s = 0;
  021D    01A2    CLR	0x22
249:                                      // 关机
250:                                      set_led_state(LED_INDEX_10, LED_STATE_OFF);
  021E    2134    CALL	0x134
  021F    256E    CALL	0x56E
251:                                      if (water_work_state != WATER_WORK_STATE_MODE_LED)
  0220    3003    LDIA	0x3
  0221    066C    XORA	0x6C
  0222    1903    SZB	0x3,2
  0223    0008    RET
252:                                      {
253:                                           app_process_set_work_state(WORK_STATE_POWEROFF);
  0224    3000    LDIA	0x0
  0225    27BE    CALL	0x7BE
254:                                          app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  0226    3000    LDIA	0x0
  0227    2FC3    JP	0x7C3
255:                                      }
256:                                      
257:                                     
258:                                  }
259:                              }
260:                          }
261:                      }
262:                  }
263:                  else
264:                  {
265:                      CntLedFlash = 0;
  0228    1283    CLRB	0x3,5
  0229    01B0    CLR	0x30
  022A    01B1    CLR	0x31
  022B    0008    RET
266:                  }
267:              }
268:              
269:              void set_led_state(led_index_t index, led_state_t state)
270:              {
271:                  if (LED_STATE_ON == state)
  04E6    0B72    SZDECA	0x72
  04E7    2CF8    JP	0x4F8
  056E    0B55    SZDECA	0x55
  056F    2D7F    JP	0x57F
272:                  {
273:                      led_index |= index;
  04E8    0870    LD	A,0x70
  04E9    00F3    LD	0x73,A
  04EA    0871    LD	A,0x71
  04EB    00F4    LD	0x74,A
  04EC    01F5    CLR	0x75
  04ED    01F6    CLR	0x76
  04EE    0873    LD	A,0x73
  04EF    1283    CLRB	0x3,5
  04F0    04A0    ORR	0x20
  04F1    0874    LD	A,0x74
  04F2    04A1    ORR	0x21
  04F3    0875    LD	A,0x75
  04F4    04A2    ORR	0x22
  04F5    0876    LD	A,0x76
  04F6    04A3    ORR	0x23
  0570    0853    LD	A,0x53
  0571    00D6    LD	0x56,A
  0572    0854    LD	A,0x54
  0573    00D7    LD	0x57,A
  0574    01D8    CLR	0x58
  0575    01D9    CLR	0x59
  0576    0856    LD	A,0x56
  0577    04A0    ORR	0x20
  0578    0857    LD	A,0x57
  0579    04A1    ORR	0x21
  057A    0858    LD	A,0x58
  057B    04A2    ORR	0x22
  057C    0859    LD	A,0x59
  057D    04A3    ORR	0x23
274:                  }
  04F7    0008    RET
  057E    0008    RET
275:                  else if (LED_STATE_OFF == state)
  04F8    0872    LD	A,0x72
  04F9    1D03    SNZB	0x3,2
  04FA    0008    RET
  057F    0855    LD	A,0x55
  0580    1D03    SNZB	0x3,2
  0581    0008    RET
276:                  {
277:                      led_index &= ~index;
  04FB    0871    LD	A,0x71
  04FC    00F4    LD	0x74,A
  04FD    0870    LD	A,0x70
  04FE    00F3    LD	0x73,A
  04FF    09F3    COMR	0x73
  0500    09F4    COMR	0x74
  0501    0873    LD	A,0x73
  0502    00F5    LD	0x75,A
  0503    0874    LD	A,0x74
  0504    00F6    LD	0x76,A
  0505    3000    LDIA	0x0
  0506    1BF6    SZB	0x76,7
  0507    30FF    LDIA	0xFF
  0508    00F7    LD	0x77,A
  0509    00F8    LD	0x78,A
  050A    0875    LD	A,0x75
  050B    1283    CLRB	0x3,5
  050C    05A0    ANDR	0x20
  050D    0876    LD	A,0x76
  050E    05A1    ANDR	0x21
  050F    0877    LD	A,0x77
  0510    05A2    ANDR	0x22
  0511    0878    LD	A,0x78
  0512    05A3    ANDR	0x23
  0513    0008    RET
  0582    0854    LD	A,0x54
  0583    00D7    LD	0x57,A
  0584    0853    LD	A,0x53
  0585    00D6    LD	0x56,A
  0586    09D6    COMR	0x56
  0587    09D7    COMR	0x57
  0588    0856    LD	A,0x56
  0589    00D8    LD	0x58,A
  058A    0857    LD	A,0x57
  058B    00D9    LD	0x59,A
  058C    3000    LDIA	0x0
  058D    1BD9    SZB	0x59,7
  058E    30FF    LDIA	0xFF
  058F    00DA    LD	0x5A,A
  0590    00DB    LD	0x5B,A
  0591    0858    LD	A,0x58
  0592    05A0    ANDR	0x20
  0593    0859    LD	A,0x59
  0594    05A1    ANDR	0x21
  0595    085A    LD	A,0x5A
  0596    05A2    ANDR	0x22
  0597    085B    LD	A,0x5B
  0598    05A3    ANDR	0x23
  0599    0008    RET
278:                  }
279:              }
280:              
281:              void set_led_dirct_state(led_index_t index)
282:              {
283:                  led_index = index;
  079D    0853    LD	A,0x53
  079E    00A0    LD	0x20,A
  079F    0854    LD	A,0x54
  07A0    00A1    LD	0x21,A
  07A1    01A2    CLR	0x22
  07A2    01A3    CLR	0x23
  07A3    0008    RET
284:              }
285:              static volatile u8 step = 0;
286:              void process_led(void)
287:              {
288:                 if (is_charge_pwm)
  0232    19FB    SZB	0x7B,3
  0233    0008    RET
289:                  {
290:                      return;
291:                  }
292:                  TRISA = 0b01011111;
  0234    305F    LDIA	0x5F
  0235    0085    LD	0x5,A
293:                  // PORTA = 0b00000000;
294:                  if (step == 0)
  0236    1283    CLRB	0x3,5
  0237    0842    LD	A,0x42
  0238    1D03    SNZB	0x3,2
  0239    2A5B    JP	0x25B
295:                  {
296:                      if (led_index & LED_INDEX_1)//GREEN1
  023A    1C20    SNZB	0x20,0
  023B    2A3F    JP	0x23F
297:                      {
298:                          IO_LED2 = 0;
  023C    1085    CLRB	0x5,1
299:                          TRISA &= ~BIT(1);
  023D    1683    SETB	0x3,5
  023E    1085    CLRB	0x5,1
300:                      }
301:                      if (led_index & LED_INDEX_2)//GREEN2
  023F    1283    CLRB	0x3,5
  0240    1CA0    SNZB	0x20,1
  0241    2A45    JP	0x245
302:                      {
303:                          IO_LED3 = 0;
  0242    1105    CLRB	0x5,2
304:                          TRISA &= ~BIT(2);
  0243    1683    SETB	0x3,5
  0244    1105    CLRB	0x5,2
305:                      }
306:                      if (led_index & LED_INDEX_3)//GREEN3
  0245    1283    CLRB	0x3,5
  0246    1D20    SNZB	0x20,2
  0247    2A4B    JP	0x24B
307:                      {
308:                          IO_LED4 = 0;
  0248    1185    CLRB	0x5,3
309:                          TRISA &= ~BIT(3);
  0249    1683    SETB	0x3,5
  024A    1185    CLRB	0x5,3
310:                      }
311:                      if (led_index & LED_INDEX_4)//BLUE4
  024B    1283    CLRB	0x3,5
  024C    1DA0    SNZB	0x20,3
  024D    2A51    JP	0x251
312:                      {
313:                          IO_LED5 = 0;
  024E    1205    CLRB	0x5,4
314:                          TRISA &= ~BIT(4);
  024F    1683    SETB	0x3,5
  0250    1205    CLRB	0x5,4
315:                      }
316:                      if (led_index & LED_INDEX_5)//BLUE5
  0251    1283    CLRB	0x3,5
  0252    1E20    SNZB	0x20,4
  0253    2A57    JP	0x257
317:                      {
318:                          IO_LED6 = 0;
  0254    1305    CLRB	0x5,6
319:                          TRISA &= ~BIT(6);
  0255    1683    SETB	0x3,5
  0256    1305    CLRB	0x5,6
320:                      }
321:                      IO_LED1 = 1;
  0257    1283    CLRB	0x3,5
  0258    1405    SETB	0x5,0
322:                      TRISA &= ~BIT(0);
  0259    1683    SETB	0x3,5
  025A    1005    CLRB	0x5,0
323:                  }
324:                  if (step == 1)
  025B    1283    CLRB	0x3,5
  025C    0B42    SZDECA	0x42
  025D    2A73    JP	0x273
325:                  {
326:                      if (led_index & LED_INDEX_6)//BLUE6
  025E    1EA0    SNZB	0x20,5
  025F    2A63    JP	0x263
327:                      {
328:                          IO_LED4 = 0;
  0260    1185    CLRB	0x5,3
329:                          TRISA &= ~BIT(3);
  0261    1683    SETB	0x3,5
  0262    1185    CLRB	0x5,3
330:                      }
331:                      if (led_index & LED_INDEX_7)//BLUE7
  0263    1283    CLRB	0x3,5
  0264    1F20    SNZB	0x20,6
  0265    2A69    JP	0x269
332:                      {
333:                          IO_LED6 = 0;
  0266    1305    CLRB	0x5,6
334:                          TRISA &= ~BIT(6);
  0267    1683    SETB	0x3,5
  0268    1305    CLRB	0x5,6
335:                      }
336:                      if (led_index & LED_INDEX_8)//BLUE8
  0269    1283    CLRB	0x3,5
  026A    1FA0    SNZB	0x20,7
  026B    2A6F    JP	0x26F
337:                      {
338:                          IO_LED5 = 0;
  026C    1205    CLRB	0x5,4
339:                          TRISA &= ~BIT(4);
  026D    1683    SETB	0x3,5
  026E    1205    CLRB	0x5,4
340:                      }
341:                      IO_LED2 = 1;
  026F    1283    CLRB	0x3,5
  0270    1485    SETB	0x5,1
342:                      TRISA &= ~BIT(1);
  0271    1683    SETB	0x3,5
  0272    1085    CLRB	0x5,1
343:                  }
344:                  if (step == 2)
  0273    3002    LDIA	0x2
  0274    1283    CLRB	0x3,5
  0275    0642    XORA	0x42
  0276    1D03    SNZB	0x3,2
  0277    2A7E    JP	0x27E
345:                  {
346:                      if (led_index & LED_INDEX_9)//GREEN
  0278    1C21    SNZB	0x21,0
  0279    2A7D    JP	0x27D
347:                      {
348:                          IO_LED4 = 0;
  027A    1185    CLRB	0x5,3
349:                          TRISA &= ~BIT(3);
  027B    1683    SETB	0x3,5
  027C    1185    CLRB	0x5,3
350:                      }
351:                      IO_LED3 = 1;
352:                      TRISA &= ~BIT(2);
  027D    2290    CALL	0x290
353:                  }
354:                  if (step == 3)
  027E    3003    LDIA	0x3
  027F    1283    CLRB	0x3,5
  0280    0642    XORA	0x42
  0281    1D03    SNZB	0x3,2
  0282    2A89    JP	0x289
355:                  {
356:                      if (led_index & LED_INDEX_10)//RED
  0283    1CA1    SNZB	0x21,1
  0284    2A88    JP	0x288
357:                      {
358:                          IO_LED5 = 0;
  0285    1205    CLRB	0x5,4
359:                          TRISA &= ~BIT(4);
  0286    1683    SETB	0x3,5
  0287    1205    CLRB	0x5,4
360:                      }
361:                      IO_LED3 = 1;
362:                      TRISA &= ~BIT(2);
  0288    2290    CALL	0x290
363:                  }
364:                  step++;
  0289    1283    CLRB	0x3,5
  028A    0AC2    INCR	0x42
365:                  if (step > 3)
  028B    3004    LDIA	0x4
  028C    0242    SUBA	0x42
  028D    1803    SZB	0x3,0
366:                  {
367:                      step = 0;
  028E    01C2    CLR	0x42
  028F    0008    RET
368:                  }
369:              }
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_water_process.c ----------------------------------------------------------------------
1:                 #include "main.h"
2:                
3:                uint8_t water_work_step;
4:                uint8_t CntWaterDrive;
5:                uint8_t MotorWaterDuty;
6:                
7:                volatile water_work_state_t water_work_state =  WATER_WORK_STATE_POWEROFF;
8:                app_process_water_mode_t water_work_mode = 
9:                {
10:                   WATER_WORK_MODE_THREE,0,0,0
11:               };
12:               app_timer_t app_water_timer = 
13:               {
14:               	0
15:               };
16:               
17:               void app_process_set_water_state(water_work_state_t states)
  07C3    1283    CLRB	0x3,5
  07C4    00D3    LD	0x53,A
18:               {
19:                   water_work_state = states;
  07C5    00EC    LD	0x6C,A
20:                   water_work_step = 0;
  07C6    01BA    CLR	0x3A
  07C7    0008    RET
21:               }
22:               
23:               void water_motor()
24:               {
25:                   if (water_work_mode.water_mode == WATER_WORK_MODE_ONE)
  0654    0B61    SZDECA	0x61
  0655    2E58    JP	0x658
26:                   {
27:                       // MotorWaterDuty=41;
28:                       MotorWaterDuty=36;
  0656    3024    LDIA	0x24
  0657    00B8    LD	0x38,A
29:                   }
30:                   if (water_work_mode.water_mode == WATER_WORK_MODE_TWO)
  0658    3002    LDIA	0x2
  0659    0661    XORA	0x61
  065A    1D03    SNZB	0x3,2
  065B    2E5E    JP	0x65E
31:                   {
32:                       // MotorWaterDuty=56;
33:                       MotorWaterDuty=51;
  065C    3033    LDIA	0x33
  065D    00B8    LD	0x38,A
34:                   }
35:                   if (water_work_mode.water_mode == WATER_WORK_MODE_THREE)
  065E    3003    LDIA	0x3
  065F    0661    XORA	0x61
  0660    1D03    SNZB	0x3,2
  0661    2E64    JP	0x664
36:                   {
37:                       // MotorWaterDuty=71;
38:                       MotorWaterDuty=66;
  0662    3042    LDIA	0x42
  0663    00B8    LD	0x38,A
39:                   }
40:                   if (water_work_mode.water_mode == WATER_WORK_MODE_FOUR)
  0664    3004    LDIA	0x4
  0665    0661    XORA	0x61
  0666    1D03    SNZB	0x3,2
  0667    2E6A    JP	0x66A
41:                   {
42:                       // MotorWaterDuty=86;
43:                       MotorWaterDuty=81;
  0668    3051    LDIA	0x51
  0669    00B8    LD	0x38,A
44:                   }
45:                   if (water_work_mode.water_mode == WATER_WORK_MODE_FIVE)
  066A    3005    LDIA	0x5
  066B    0661    XORA	0x61
  066C    1D03    SNZB	0x3,2
  066D    2E70    JP	0x670
46:                   {
47:                       // MotorWaterDuty=101;
48:                       MotorWaterDuty=96;
  066E    3060    LDIA	0x60
  066F    00B8    LD	0x38,A
49:                   }
50:                   water_work_mode.water_mode_out_put = water_work_mode.water_mode;
  0670    0861    LD	A,0x61
  0671    00E2    LD	0x62,A
  0672    0008    RET
51:               }
52:               
53:               // void app_process_set_water_mode_init()
54:               // {
55:               //     app_led_water_mode_set();
56:               //     water_motor();
57:               // }
58:               
59:               void app_process_set_water_mode_next(void)
  0795    3006    LDIA	0x6
60:               {
61:                   water_work_mode.water_mode++;
  0796    0AE1    INCR	0x61
62:                   if (water_work_mode.water_mode > WATER_WORK_MODE_FIVE)
  0797    0261    SUBA	0x61
  0798    1C03    SNZB	0x3,0
  0799    0008    RET
63:                   {
64:                       water_work_mode.water_mode = WATER_WORK_MODE_ONE;
  079A    01E1    CLR	0x61
  079B    0AE1    INCR	0x61
  079C    0008    RET
65:                   }
66:                   // app_led_water_mode_set();
67:                   // if (water_work_state == WATER_WORK_STATE_WORKING)
68:                   // {
69:                   //     water_motor();
70:                   // }
71:               }
72:               
73:               void MotorWaterDrive()
74:               {
75:                   if(water_work_mode.water_mode_out_put == WATER_WORK_MODE_IDEL)
  06DA    1283    CLRB	0x3,5
  06DB    0862    LD	A,0x62
  06DC    1D03    SNZB	0x3,2
  06DD    2EE0    JP	0x6E0
76:                   {
77:                       MotorWaterOff;
  06DE    1285    CLRB	0x5,5
78:                       return;
  06DF    0008    RET
79:                   }
80:                   CntWaterDrive++;
  06E0    0AB9    INCR	0x39
81:                   if(CntWaterDrive==1)
  06E1    0B39    SZDECA	0x39
  06E2    2EE4    JP	0x6E4
82:                   {
83:                   MotorWaterOn;
  06E3    1685    SETB	0x5,5
84:                   }
85:                   if(CntWaterDrive==MotorWaterDuty)
  06E4    0839    LD	A,0x39
  06E5    0638    XORA	0x38
  06E6    1903    SZB	0x3,2
86:                   {
87:                   MotorWaterOff;
  06E7    1285    CLRB	0x5,5
88:                   }	 
89:                   if(CntWaterDrive>99)
  06E8    3064    LDIA	0x64
  06E9    0239    SUBA	0x39
  06EA    1803    SZB	0x3,0
90:                   {
91:                   CntWaterDrive=0;
  06EB    01B9    CLR	0x39
  06EC    0008    RET
92:                   }		
93:               }
94:               
95:               void app_process_water_working()
96:               {
97:                    if (!water_work_step)
  059A    083A    LD	A,0x3A
  059B    1D03    SNZB	0x3,2
  059C    2D9F    JP	0x59F
98:                   {
99:                       water_work_step++;
  059D    0ABA    INCR	0x3A
100:                  }
  059E    0008    RET
101:                  else
102:                  {
103:                      water_work_mode.water_mode_count++;
  059F    0AE3    INCR	0x63
  05A0    1903    SZB	0x3,2
  05A1    0AE4    INCR	0x64
104:                      if (water_work_mode.water_mode_count == SECOND(30))
  05A2    30B8    LDIA	0xB8
  05A3    0663    XORA	0x63
  05A4    300B    LDIA	0xB
  05A5    1903    SZB	0x3,2
  05A6    0664    XORA	0x64
  05A7    1D03    SNZB	0x3,2
  05A8    2DAB    JP	0x5AB
105:                      {
106:                          water_work_mode.water_mode_out_put = WORK_MODE_IDEL;
  05A9    01E2    CLR	0x62
107:                      }
  05AA    0008    RET
108:                      else if (water_work_mode.water_mode_count >= SECOND(30) + MS(200))
  05AB    300B    LDIA	0xB
  05AC    0264    SUBA	0x64
  05AD    30CC    LDIA	0xCC
  05AE    1903    SZB	0x3,2
  05AF    0263    SUBA	0x63
  05B0    1C03    SNZB	0x3,0
  05B1    0008    RET
  05B2    3004    LDIA	0x4
109:                      {
110:                          water_work_mode.water_mode_count = 0;
  05B3    01E3    CLR	0x63
  05B4    01E4    CLR	0x64
111:              			water_work_mode.times++;
  05B5    0AE5    INCR	0x65
112:              			if(water_work_mode.times >=  4)   
  05B6    0265    SUBA	0x65
  05B7    1C03    SNZB	0x3,0
  05B8    2DC0    JP	0x5C0
113:              			{
114:              				water_work_mode.times = 0;
  05B9    01E5    CLR	0x65
115:                              if (app_charge.Remind)
  05BA    1683    SETB	0x3,5
  05BB    1E20    SNZB	0x20,4
  05BC    2DBE    JP	0x5BE
116:                              {
117:                                  app_charge.flag_remind_delay_10s = 1;
118:              				    app_charge.remind_delay_10s_timer = 0;
  05BD    24B2    CALL	0x4B2
119:                              }
120:                                  //关机
121:                              app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  05BE    3000    LDIA	0x0
  05BF    2FC3    JP	0x7C3
122:                          }
123:                          else
124:                          {
125:                              water_work_mode.water_mode_out_put = water_work_mode.water_mode;
  05C0    0861    LD	A,0x61
  05C1    00E2    LD	0x62,A
  05C2    0008    RET
126:                          }
127:                      }
128:                  }
129:              }
130:              
131:              void water_turn_off()
  077B    30F8    LDIA	0xF8
132:              {
133:                  water_work_mode.water_mode_count = 0;
  077C    01E3    CLR	0x63
  077D    01E4    CLR	0x64
134:                  water_work_mode.times = 0;
  077E    01E5    CLR	0x65
135:                  //关电机
136:                  water_work_mode.water_mode_out_put = WATER_WORK_MODE_IDEL;
  077F    01E2    CLR	0x62
137:                  //关灯
138:                  set_led_state(LED_INDEX_8 | LED_INDEX_7 | LED_INDEX_6 | LED_INDEX_5 | LED_INDEX_4, LED_STATE_OFF);
  0780    00D3    LD	0x53,A
  0781    01D4    CLR	0x54
  0782    01D5    CLR	0x55
  0783    2D6E    JP	0x56E
139:              }
140:              
141:              void app_process_water_workoff()
142:              {
143:                  water_turn_off();
  07CC    2F7B    JP	0x77B
144:              }
145:              
146:              static uint16_t water_mode_led_cnt;
147:              void app_process_water_mdoe_led()
148:              {
149:                   if (!water_work_step)
  0673    083A    LD	A,0x3A
  0674    1D03    SNZB	0x3,2
  0675    2E7C    JP	0x67C
150:                  {
151:                      water_mode_led_cnt = SECOND(10);
  0676    30E8    LDIA	0xE8
  0677    00A4    LD	0x24,A
  0678    3003    LDIA	0x3
  0679    00A5    LD	0x25,A
152:                      water_work_step++;
  067A    0ABA    INCR	0x3A
153:                  }
  067B    0008    RET
154:                  else
155:                  {
156:                      water_work_mode.water_mode_count++;
  067C    0AE3    INCR	0x63
  067D    1903    SZB	0x3,2
  067E    0AE4    INCR	0x64
157:                      if (water_mode_led_cnt)
  067F    0824    LD	A,0x24
  0680    0425    ORA	0x25
  0681    1903    SZB	0x3,2
  0682    0008    RET
158:                      {
159:                          water_mode_led_cnt--;
  0683    3001    LDIA	0x1
  0684    02A4    SUBR	0x24
  0685    3000    LDIA	0x0
  0686    1C03    SNZB	0x3,0
  0687    03A5    DECR	0x25
  0688    02A5    SUBR	0x25
160:                          if (!water_mode_led_cnt)
  0689    0824    LD	A,0x24
  068A    0425    ORA	0x25
  068B    1D03    SNZB	0x3,2
  068C    0008    RET
161:                          {
162:                              //关机
163:                              app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  068D    3000    LDIA	0x0
  068E    2FC3    JP	0x7C3
164:                          }
165:                      }
166:                  }
167:              }
168:              
169:              void app_water_process_work()
170:              {
171:                  switch (water_work_state)
  0730    086C    LD	A,0x6C
  0731    0084    LD	0x4,A
  0732    3004    LDIA	0x4
  0733    0204    SUBA	0x4
  0734    1803    SZB	0x3,0
  0735    0008    RET
  0736    3007    LDIA	0x7
  0737    008A    LD	0xA,A
  0738    30C8    LDIA	0xC8
  0739    0704    ADDA	0x4
  073A    0082    LD	0x2,A
  073B    0008    RET
172:                  {
173:                  case WATER_WORK_STATE_WORKING:
174:                      app_process_water_working();
  073C    2D9A    JP	0x59A
175:                      break;
176:                  case WATER_WORK_STATE_POWEROFF:
177:                      app_process_water_workoff();
  073D    2F7B    JP	0x77B
178:                      break;
179:                  case WATER_WORK_STATE_MODE_LED:
180:                      app_process_water_mdoe_led();
  073E    2E73    JP	0x673
181:                      break;
182:                  
183:                  default:
184:                      break;
185:                  }
186:              }
187:              
188:              
189:              
190:              
191:              
192:              
193:              
194:              
195:              
196:              
197:              
198:              
199:              
200:              
201:              
202:              
203:              
204:              
205:              
206:              
207:              
208:              
209:              
210:              
211:              
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_process.c ----------------------------------------------------------------------
1:                 #include "main.h"
2:                
3:                uint8_t work_step;
4:                volatile work_state_t app_work_state =  WORK_STATE_POWEROFF;
5:                uint16_t bat_remind_timer;	
6:                // 定义一个全局计时器
7:                static uint16_t mode_led_display_timer;
8:                
9:                // 新增一个处理函数
10:               void app_process_mode_led_display()
11:               {
12:                   if (!work_step)
  068F    0840    LD	A,0x40
  0690    1D03    SNZB	0x3,2
  0691    2E9A    JP	0x69A
13:                   {
14:                       // 1. 确保电机是关闭的
15:                       work_mode.mode_out_put = WORK_MODE_IDEL;
  0692    01E7    CLR	0x67
16:                       // 2. 确保模式灯是根据当前模式点亮的
17:                       app_led_mode_set();
  0693    260F    CALL	0x60F
18:                       // 3. 启动15秒倒计时
19:                       mode_led_display_timer = SECOND(15);
  0694    30DC    LDIA	0xDC
  0695    00A8    LD	0x28,A
  0696    3005    LDIA	0x5
  0697    00A9    LD	0x29,A
20:                       work_step++;
  0698    0AC0    INCR	0x40
21:                   }
  0699    0008    RET
22:                   else
23:                   {
24:                       // 4. 开始倒计时
25:                       if (mode_led_display_timer)
  069A    0828    LD	A,0x28
  069B    0429    ORA	0x29
  069C    1903    SZB	0x3,2
  069D    0008    RET
26:                       {
27:                           mode_led_display_timer--;
  069E    3001    LDIA	0x1
  069F    02A8    SUBR	0x28
  06A0    3000    LDIA	0x0
  06A1    1C03    SNZB	0x3,0
  06A2    03A9    DECR	0x29
  06A3    02A9    SUBR	0x29
28:                           if (!mode_led_display_timer)
  06A4    0828    LD	A,0x28
  06A5    0429    ORA	0x29
  06A6    1D03    SNZB	0x3,2
  06A7    0008    RET
29:                           {
30:                               // 5. 时间到，自动关机（回到彻底的POWEROFF状态）
31:                               app_process_set_work_state(WORK_STATE_POWEROFF);
  06A8    3000    LDIA	0x0
  06A9    2FBE    JP	0x7BE
32:                           }
33:                       }
34:                   }
35:               }
36:               
37:               app_process_mode_t work_mode = 
38:               {
39:                   WORK_MODE_TWO,0,0,0
40:                   // WORK_MODE_ONE,
41:                   // WORK_MODE_ONE
42:               };
43:               
44:               //uint8_t power_off_led_timer;
45:               //uint8_t blink_cnt;
46:               
47:               
48:               
49:               bit flag_old_mode;
50:               
51:               app_timer_t app_timer = 
52:               {
53:               	0
54:               };
55:               
56:               void turn_off()//这是牙刷的
57:               {
58:               	work_mode.work_mode_count = 0;
59:               	work_mode.times = 0;
60:                   work_mode.mode_out_put = WORK_MODE_IDEL;
61:               	set_led_state(LED_INDEX_1 | LED_INDEX_2 | LED_INDEX_3, LED_STATE_OFF);
62:               }
63:               
64:               void app_process_set_work_state(work_state_t states)
  07BE    1283    CLRB	0x3,5
  07BF    00D3    LD	0x53,A
65:               {
66:                   app_work_state = states;
  07C0    00ED    LD	0x6D,A
67:                   work_step = 0;
  07C1    01C0    CLR	0x40
  07C2    0008    RET
68:               }
69:               
70:               u16 times;
71:               void app_process_working()
72:               {
73:                   if (!work_step)
  0487    0840    LD	A,0x40
  0488    1D03    SNZB	0x3,2
  0489    2C8C    JP	0x48C
74:                   {
75:                       //turn_off();
76:                       work_step++;
  048A    0AC0    INCR	0x40
77:                   }
  048B    0008    RET
78:                   else
79:                   {
80:                       work_chang_timing();//5s      
  048C    26C4    CALL	0x6C4
81:                       work_mode.work_mode_count++;
  048D    1283    CLRB	0x3,5
  048E    0AE8    INCR	0x68
  048F    1903    SZB	0x3,2
  0490    0AE9    INCR	0x69
82:                       if (work_mode.work_mode_count == SECOND(30))
  0491    30B8    LDIA	0xB8
  0492    0668    XORA	0x68
  0493    300B    LDIA	0xB
  0494    1903    SZB	0x3,2
  0495    0669    XORA	0x69
  0496    1D03    SNZB	0x3,2
  0497    2C9A    JP	0x49A
83:                       {
84:                           work_mode.mode_out_put = WORK_MODE_IDEL;
  0498    01E7    CLR	0x67
85:                       }
  0499    0008    RET
86:                       else if (work_mode.work_mode_count >= SECOND(30) + MS(200))
  049A    300B    LDIA	0xB
  049B    0269    SUBA	0x69
  049C    30CC    LDIA	0xCC
  049D    1903    SZB	0x3,2
  049E    0268    SUBA	0x68
  049F    1C03    SNZB	0x3,0
  04A0    0008    RET
  04A1    3004    LDIA	0x4
87:                       {
88:                           work_mode.work_mode_count = 0;
  04A2    01E8    CLR	0x68
  04A3    01E9    CLR	0x69
89:               			work_mode.times++;
  04A4    0AEA    INCR	0x6A
90:               			if(work_mode.times >=  4)   
  04A5    026A    SUBA	0x6A
  04A6    1C03    SNZB	0x3,0
  04A7    2CAF    JP	0x4AF
91:               			{
92:               				work_mode.times = 0;
  04A8    01EA    CLR	0x6A
93:                               if (app_charge.Remind)
  04A9    1683    SETB	0x3,5
  04AA    1E20    SNZB	0x20,4
  04AB    2CAD    JP	0x4AD
94:                               {
95:                                   app_charge.flag_remind_delay_10s = 1;
96:               				    app_charge.remind_delay_10s_timer = 0;
  04AC    24B2    CALL	0x4B2
97:                               }
98:                               app_process_set_work_state(WORK_STATE_POWEROFF);
  04AD    3000    LDIA	0x0
  04AE    2FBE    JP	0x7BE
99:                           }
100:                          else
101:                          {
102:                              work_mode.mode_out_put = work_mode.mode;
  04AF    0866    LD	A,0x66
  04B0    00E7    LD	0x67,A
  04B1    0008    RET
103:                          }
104:                      }
105:                  }
106:              }
107:              
108:              void app_process_power_off()
  0784    3007    LDIA	0x7
109:              {
110:                  work_mode.work_mode_count = 0;
  0785    01E8    CLR	0x68
  0786    01E9    CLR	0x69
111:              	work_mode.times = 0;
  0787    01EA    CLR	0x6A
112:                  work_mode.mode_out_put = WORK_MODE_IDEL;
  0788    01E7    CLR	0x67
113:              	set_led_state(LED_INDEX_1 | LED_INDEX_2 | LED_INDEX_3, LED_STATE_OFF);
  0789    00D3    LD	0x53,A
  078A    01D4    CLR	0x54
  078B    01D5    CLR	0x55
  078C    2D6E    JP	0x56E
114:              }
115:              
116:              void app_process_go_to_sleep()
117:              {
118:                  if (app_work_state == WORK_STATE_POWEROFF && water_work_state == WATER_WORK_STATE_POWEROFF && !app_charge.flag_remind_delay_10s && !app_charge.LowLed)
  06FE    086D    LD	A,0x6D
  06FF    1D03    SNZB	0x3,2
  0700    2F0C    JP	0x70C
  0701    086C    LD	A,0x6C
  0702    1D03    SNZB	0x3,2
  0703    2F0C    JP	0x70C
  0704    1683    SETB	0x3,5
  0705    0822    LD	A,0x22
  0706    1D03    SNZB	0x3,2
  0707    2F0C    JP	0x70C
  0708    0827    LD	A,0x27
  0709    1D03    SNZB	0x3,2
  070A    2F0C    JP	0x70C
119:                  {
120:                      GotoSleep();
  070B    2BD5    JP	0x3D5
121:                  }
122:                  else
123:                  {
124:                      CntSleep = 0;
  070C    1283    CLRB	0x3,5
  070D    01C1    CLR	0x41
  070E    0008    RET
125:                  }
126:              }
127:              
128:              
129:              void app_process_charing()
130:              {
131:                 if (!work_step)
  073F    0840    LD	A,0x40
  0740    1D03    SNZB	0x3,2
  0741    0008    RET
132:                  {
133:                      app_process_power_off();
  0742    2784    CALL	0x784
134:                      app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  0743    3000    LDIA	0x0
  0744    27C3    CALL	0x7C3
135:                      app_timer.charge_to_oldmode_count = SECOND(8);
  0745    3020    LDIA	0x20
  0746    1683    SETB	0x3,5
  0747    00BA    LD	0x3A,A
  0748    3003    LDIA	0x3
  0749    00BB    LD	0x3B,A
136:                      work_step++;
  074A    1283    CLRB	0x3,5
  074B    0AC0    INCR	0x40
137:                  }
  074C    0008    RET
138:                  else
139:                  {
140:                      // charge_to_oldmode_timing();
141:                      // if (app_charge.flag_charge_force_full_24hour)
142:                      // {
143:                      //     set_led_state(LED_INDEX_9 | LED_INDEX_10,LED_STATE_OFF);
144:                      // }
145:                      // else if (app_charge.FullCharge || app_charge.ForceFullCharge)
146:                      // {
147:                      //     set_led_state(LED_INDEX_9,LED_STATE_ON);
148:                      //     set_led_state(LED_INDEX_10,LED_STATE_OFF);
149:                      // }
150:                      // else
151:                      // {
152:                      //     set_led_state(LED_INDEX_10,LED_STATE_ON);
153:                      //     set_led_state(LED_INDEX_9,LED_STATE_OFF);
154:                      // }
155:              	}
156:              }
157:              
158:              // void process_lowBat_led()
159:              // {
160:              //     switch (work_step)
161:              //     {
162:              //     case 0:
163:              //         flag_discharge_once = 0;
164:              //         flag_old_mode = 0;
165:              //         turn_off();
166:              //         work_step++;
167:              //         power_off_led_timer = 0;
168:              //         blink_cnt = 6;//  烁十  
169:              //         break;
170:              //     case 1:
171:              //         power_off_led_timer++;
172:              //         if (power_off_led_timer / MS(300))
173:              //         {
174:              //             power_off_led_timer = 0;
175:              //             if (blink_cnt)
176:              //             {
177:              //                 blink_cnt--;
178:              //                 if (!blink_cnt)
179:              //                 {
180:              //                     work_step++;
181:              //                 }
182:              //             }
183:              //         }
184:              //         break;
185:              //     case 2:
186:              //         app_process_set_work_state(WORK_STATE_POWEROFF);
187:              //         break;
188:              //     default:
189:              //         break;
190:              //     }
191:              // }
192:              
193:              // void process_old_mode_run()
194:              // {
195:              //     static u16 old_mode_count;
196:              //     switch (work_step)
197:              //     {
198:              //     case 0:
199:              //         turn_off();
200:              //         work_step++;
201:              //         break;
202:              //     case 1:
203:              //         old_mode_count++;
204:              //         if (old_mode_count == MINUTE(2))
205:              //         {
206:              //             work_mode.mode_out_put = work_mode.mode;
207:              //         }
208:              //         else if(old_mode_count >= MINUTE(2))
209:              // 		{
210:              //             work_mode.mode_out_put = WORK_MODE_IDEL;
211:              //             INA = 0;
212:              //             INB = 0;
213:              // 			old_mode_count = 0;
214:              // 		}
215:              //         break;
216:              //     default:
217:              //         break;
218:              //     }
219:              // }
220:              
221:              void process_null()
222:              {
223:              
224:              }
225:              
226:              work_state_action_t work_state_action_tab[] = 
227:              {
228:                  {WORK_STATE_POWEROFF,app_process_power_off},
229:                  {WORK_STATE_WORKING,app_process_working},
230:                  {WORK_STATE_CHARGING,app_process_charing},
231:                  //{WORK_STATE_CHARGED,process_charged},
232:                  //{WORK_STATE_REMIND_CHARGE,process_remind_charge},
233:                  //{WORK_STATE_POWEROFF_MODE_LED,process_power_off_mode_led},
234:                  //{WORK_STATE_LOWBAT_LED,process_lowBat_led},
235:                  //{WORK_STATE_OLD_MODE_RUN,process_old_mode_run},
236:                  //{WORK_STATE_NULL,process_null},
237:              };
238:              
239:              void app_process_work()
240:              {
241:              	// uint8_t i = 0;
242:                  // for ( ; i < SIZE_ARRAY(work_state_action_tab); i++)
243:                  // {
244:                  //     if(work_state_action_tab[i].states == app_work_state)
245:                  //     {
246:                  //         work_state_action_tab[i].cb();
247:                  //         break;
248:                  //     }
249:                  // }
250:                  if (app_work_state == WORK_STATE_POWEROFF)
  06ED    086D    LD	A,0x6D
  06EE    1D03    SNZB	0x3,2
  06EF    2EF1    JP	0x6F1
251:                  {
252:                      app_process_power_off();
  06F0    2784    CALL	0x784
253:                  }
254:                  if (app_work_state == WORK_STATE_WORKING)
  06F1    0B6D    SZDECA	0x6D
  06F2    2EF4    JP	0x6F4
255:                  {
256:                      app_process_working();
  06F3    2487    CALL	0x487
257:                  }
258:                  if (app_work_state == WORK_STATE_CHARGING)
  06F4    3002    LDIA	0x2
  06F5    066D    XORA	0x6D
  06F6    1D03    SNZB	0x3,2
  06F7    2EF9    JP	0x6F9
259:                  {
260:                      app_process_charing();
  06F8    273F    CALL	0x73F
261:                  }
262:              	if (app_work_state == WORK_STATE_MODE_LED)
  06F9    3006    LDIA	0x6
  06FA    066D    XORA	0x6D
  06FB    1D03    SNZB	0x3,2
  06FC    0008    RET
263:                  {
264:                      app_process_mode_led_display();
  06FD    2E8F    JP	0x68F
265:                  }
266:                  // if (app_work_state == WORK_STATE_OLD_MODE_RUN)
267:                  // {
268:                  //     process_old_mode_run();
269:                  // }
270:              }
271:              
272:              
273:              
274:              
275:              
276:              
277:              
278:              
279:              
280:              
281:              
282:              
283:              
284:              
285:              
286:              
287:              
288:              
289:              
290:              
291:              
292:              
293:              
294:              
295:              
296:              
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_timer.c ----------------------------------------------------------------------
1:                #include "main.h"
2:                
3:                void work_chang_timing()	
4:                {
5:                	if (app_timer.work_updown_count)
  06C4    1683    SETB	0x3,5
  06C5    0837    LD	A,0x37
  06C6    0436    ORA	0x36
  06C7    0435    ORA	0x35
  06C8    0434    ORA	0x34
  06C9    1903    SZB	0x3,2
  06CA    0008    RET
6:                	{
7:                		app_timer.work_updown_count--;
  06CB    3001    LDIA	0x1
  06CC    02B4    SUBR	0x34
  06CD    3000    LDIA	0x0
  06CE    1C03    SNZB	0x3,0
  06CF    3001    LDIA	0x1
  06D0    02B5    SUBR	0x35
  06D1    3000    LDIA	0x0
  06D2    1C03    SNZB	0x3,0
  06D3    3001    LDIA	0x1
  06D4    02B6    SUBR	0x36
  06D5    3000    LDIA	0x0
  06D6    1C03    SNZB	0x3,0
  06D7    3001    LDIA	0x1
  06D8    02B7    SUBR	0x37
  06D9    0008    RET
8:                		// if (!app_timer.work_updown_count)
9:                		// {
10:               			// app_process_set_work_state(WORK_STATE_POWEROFF);
11:               		// }
12:               	}	
13:               }
14:               
15:               void charge_to_oldmode_timing()	
16:               {
17:               	if (app_timer.charge_to_oldmode_count)
18:               	{
19:               		app_timer.charge_to_oldmode_count--;
20:               		// if (!app_timer.charge_to_oldmode_count)
21:               		// {
22:               
23:               		// }
24:               	}	
25:               }
26:               
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
36:               
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_key.c ----------------------------------------------------------------------
1:                #include "main.h"
2:                
3:                key_type_t key_brush_pwrtype = KEY_TYPE_IDLE;
4:                key_type_t key_water_pwr_type = KEY_TYPE_IDLE;
5:                key_type_t key_water_mode_type = KEY_TYPE_IDLE;
6:                //key_type_t key_mode_type = KEY_TYPE_IDLE;
7:                
8:                //bit flag_no_charge;
9:                
10:               volatile uchar KeyPressCnt1 = 0;
11:               volatile uchar KeyRelaxCnt1 = 0;
12:               
13:               volatile uchar KeyPressCnt2 = 0;
14:               volatile uchar KeyRelaxCnt2 = 0;
15:               
16:               volatile uchar KeyPressCnt3 = 0;
17:               volatile uchar KeyRelaxCnt3 = 0;
18:               
19:               volatile uchar KeyContinuousTriggerCnt = 0; // <--- 新增：用于连续触发的计时器
20:               
21:               void key_brush_pwr_check()
22:               {
23:               	if(!IO_KEY_BRUSH_PWR)
  0514    1283    CLRB	0x3,5
  0515    1906    SZB	0x6,2
  0516    2D2E    JP	0x52E
24:               	{
25:               		// --- 1. 初始长按计时 ---
26:               		if(KeyPressCnt1 <= 30) // 计时到0.3秒
  0517    301F    LDIA	0x1F
  0518    0249    SUBA	0x49
  0519    1803    SZB	0x3,0
  051A    2D21    JP	0x521
27:               		{
28:               			KeyPressCnt1++;
  051B    0AC9    INCR	0x49
29:               			if(KeyPressCnt1 == 30)  // 第一次达到0.3秒
  051C    301E    LDIA	0x1E
  051D    0649    XORA	0x49
  051E    1903    SZB	0x3,2
  051F    2D27    JP	0x527
  0520    2D29    JP	0x529
30:               			{	
31:               				key_brush_pwrtype = KEY_TYPE_LONG; // 触发第一次长按事件
  0527    3002    LDIA	0x2
  0528    00CC    LD	0x4C,A
32:               			}
33:               		}
34:               		// --- 2. 连续长按触发计时 ---
35:               		else // KeyPressCnt1 > 30，说明已经进入长按状态
36:               		{
37:               			KeyContinuousTriggerCnt++; // 启动连续触发计时器
  0521    0AC3    INCR	0x43
38:               
39:                           // 每隔20次*10ms = 200ms (0.2秒) 触发一次
40:               			if (KeyContinuousTriggerCnt >= 30) 
  0522    301E    LDIA	0x1E
  0523    0243    SUBA	0x43
  0524    1C03    SNZB	0x3,0
  0525    2D29    JP	0x529
41:               			{
42:               				KeyContinuousTriggerCnt = 0; // 清零计时器，准备下一次触发
  0526    01C3    CLR	0x43
43:               				key_brush_pwrtype = KEY_TYPE_LONG; // 再次触发长按事件
44:               			}
45:               		}
46:               
47:               		if(KeyPressCnt1 >= 2)
  0529    3002    LDIA	0x2
  052A    0249    SUBA	0x49
  052B    1803    SZB	0x3,0
48:               		{
49:               			KeyRelaxCnt1 = 0;
  052C    01C8    CLR	0x48
  052D    0008    RET
50:               		}
51:               		
52:               		/*
53:               		if(KeyPressCnt1 < 100)
54:               		{
55:               			KeyPressCnt1++;
56:               		}
57:               		if(KeyPressCnt1 >= 2)
58:               		{
59:               			KeyRelaxCnt1 = 0;
60:               		}
61:               		// if (KeyPressCnt1 == 50)   //diy
62:               		// {
63:               		// 	key_brush_pwrtype = KEY_TYPE_LONG;
64:               		// }
65:               		if(KeyPressCnt1 == 100)  //长按1s
66:               		{	
67:               			KeyPressCnt1 = 101;
68:               			//如果第二个按键没按下，这里有效
69:               			key_brush_pwrtype = KEY_TYPE_LONG;
70:               		}*/
71:               	}
72:               	else
73:               	{
74:               		if(KeyRelaxCnt1 < 2)
  052E    3002    LDIA	0x2
  052F    0248    SUBA	0x48
  0530    1803    SZB	0x3,0
  0531    2D34    JP	0x534
75:               		{
76:               			KeyRelaxCnt1++;
  0532    0AC8    INCR	0x48
77:               		}
  0533    0008    RET
78:               		else
79:               		{	
80:               			if(KeyPressCnt1 >= 3 && KeyPressCnt1 <= 30)
  0534    3003    LDIA	0x3
  0535    0249    SUBA	0x49
  0536    1C03    SNZB	0x3,0
  0537    2D3E    JP	0x53E
  0538    301F    LDIA	0x1F
  0539    0249    SUBA	0x49
  053A    1803    SZB	0x3,0
  053B    2D3E    JP	0x53E
81:               			{
82:               				//单击
83:                               key_brush_pwrtype = KEY_TYPE_SHORT;
  053C    3005    LDIA	0x5
  053D    00CC    LD	0x4C,A
84:               			}
85:               			KeyPressCnt1 = 0;
  053E    01C9    CLR	0x49
86:               			 KeyContinuousTriggerCnt = 0; // 松手时必须清零连续触发计时器
  053F    01C3    CLR	0x43
  0540    0008    RET
87:               		}
88:               	}
89:               } 
90:               
91:               void key_water_pwr_check()
92:               {
93:               	if(!IO_KEY_WATER_PWR)
  05C3    1806    SZB	0x6,0
  05C4    2DD7    JP	0x5D7
94:               	{
95:               		if(KeyPressCnt2 < 200)
  05C5    30C8    LDIA	0xC8
  05C6    0247    SUBA	0x47
  05C7    1803    SZB	0x3,0
  05C8    2DCA    JP	0x5CA
96:               		{
97:               			KeyPressCnt2++;
  05C9    0AC7    INCR	0x47
98:               		}
99:               		if(KeyPressCnt2 >= 2)
  05CA    3002    LDIA	0x2
  05CB    0247    SUBA	0x47
  05CC    1803    SZB	0x3,0
100:              		{
101:              			KeyRelaxCnt2 = 0;
  05CD    01C6    CLR	0x46
102:              		}
103:              		// if (KeyPressCnt1 == 50)   //diy
104:              		// {
105:              		// 	key_water_pwr_type = KEY_TYPE_LONG;
106:              		// }
107:              		if(KeyPressCnt2 == 200)  //长按5s
  05CE    30C8    LDIA	0xC8
  05CF    0647    XORA	0x47
  05D0    1D03    SNZB	0x3,2
  05D1    0008    RET
108:              		{	
109:              			KeyPressCnt2 = 201;
  05D2    30C9    LDIA	0xC9
  05D3    00C7    LD	0x47,A
110:              			//如果第二个按键没按下，这里有效
111:              			key_water_pwr_type = KEY_TYPE_LONG_LONG;
  05D4    3003    LDIA	0x3
  05D5    00CB    LD	0x4B,A
  05D6    0008    RET
112:              		}
113:              	}
114:              	else
115:              	{
116:              		if(KeyRelaxCnt2 < 2)
  05D7    3002    LDIA	0x2
  05D8    0246    SUBA	0x46
  05D9    1803    SZB	0x3,0
  05DA    2DDD    JP	0x5DD
117:              		{
118:              			KeyRelaxCnt2++;
  05DB    0AC6    INCR	0x46
119:              		}
  05DC    0008    RET
120:              		else
121:              		{	
122:              			if(KeyPressCnt2 >= 3 && KeyPressCnt2 <= 50)
  05DD    3003    LDIA	0x3
  05DE    0247    SUBA	0x47
  05DF    1C03    SNZB	0x3,0
  05E0    2DE7    JP	0x5E7
  05E1    3033    LDIA	0x33
  05E2    0247    SUBA	0x47
  05E3    1803    SZB	0x3,0
  05E4    2DE7    JP	0x5E7
123:              			{
124:              				//单击
125:                              key_water_pwr_type = KEY_TYPE_SHORT;
  05E5    3005    LDIA	0x5
  05E6    00CB    LD	0x4B,A
126:              			}
127:              			KeyPressCnt2 = 0;
  05E7    01C7    CLR	0x47
  05E8    0008    RET
128:              		}
129:              	}
130:              } 
131:              void key_water_mode_check()
132:              {
133:              	if(!IO_KEY_WATER_MODE)
  05E9    1886    SZB	0x6,1
  05EA    2DFD    JP	0x5FD
134:              	{
135:              		if(KeyPressCnt3 < 200)
  05EB    30C8    LDIA	0xC8
  05EC    0245    SUBA	0x45
  05ED    1803    SZB	0x3,0
  05EE    2DF0    JP	0x5F0
136:              		{
137:              			KeyPressCnt3++;
  05EF    0AC5    INCR	0x45
138:              		}
139:              		if(KeyPressCnt3 >= 2)
  05F0    3002    LDIA	0x2
  05F1    0245    SUBA	0x45
  05F2    1803    SZB	0x3,0
140:              		{
141:              			KeyRelaxCnt3 = 0;
  05F3    01C4    CLR	0x44
142:              		}
143:              		// if (KeyPressCnt1 == 50)   //diy
144:              		// {
145:              		// 	key_water_mode_type = KEY_TYPE_LONG;
146:              		// }
147:              		if(KeyPressCnt3 == 200)  //长按5s
  05F4    30C8    LDIA	0xC8
  05F5    0645    XORA	0x45
  05F6    1D03    SNZB	0x3,2
  05F7    0008    RET
148:              		{	
149:              			KeyPressCnt3 = 201;
  05F8    30C9    LDIA	0xC9
  05F9    00C5    LD	0x45,A
150:              			//如果第二个按键没按下，这里有效
151:              			key_water_mode_type = KEY_TYPE_LONG_LONG;
  05FA    3003    LDIA	0x3
  05FB    00CA    LD	0x4A,A
  05FC    0008    RET
152:              		}
153:              	}
154:              	else
155:              	{
156:              		if(KeyRelaxCnt3 < 2)
  05FD    3002    LDIA	0x2
  05FE    0244    SUBA	0x44
  05FF    1803    SZB	0x3,0
  0600    2E03    JP	0x603
157:              		{
158:              			KeyRelaxCnt3++;
  0601    0AC4    INCR	0x44
159:              		}
  0602    0008    RET
160:              		else
161:              		{	
162:              			if(KeyPressCnt3 >= 3 && KeyPressCnt3 <= 50)
  0603    3003    LDIA	0x3
  0604    0245    SUBA	0x45
  0605    1C03    SNZB	0x3,0
  0606    2E0D    JP	0x60D
  0607    3033    LDIA	0x33
  0608    0245    SUBA	0x45
  0609    1803    SZB	0x3,0
  060A    2E0D    JP	0x60D
163:              			{
164:              				//单击
165:                              key_water_mode_type = KEY_TYPE_SHORT;
  060B    3005    LDIA	0x5
  060C    00CA    LD	0x4A,A
166:              			}
167:              			KeyPressCnt3 = 0;
  060D    01C5    CLR	0x45
  060E    0008    RET
168:              		}
169:              	}
170:              } 
171:              
172:              void charge_or_lowBat_check()
173:              {
174:                  if (app_charge.Charge)  //充电
  06AA    1683    SETB	0x3,5
  06AB    1C20    SNZB	0x20,0
  06AC    2EAE    JP	0x6AE
175:                  {
176:              		// if (!flag_old_mode)
177:              		// {
178:              		// 	if (key_brush_pwrtype == KEY_TYPE_LONG_LONG)
179:              		// 	{
180:              		// 		if (app_timer.charge_to_oldmode_count)
181:              		// 		{
182:              		// 			flag_old_mode = 1;
183:              		// 			app_process_set_work_state(WORK_STATE_OLD_MODE_RUN); 
184:              		// 			app_process_set_mode_init();
185:              		// 		}
186:              		// 	}
187:              		// }
188:              		key_brush_pwrtype = KEY_TYPE_IDLE;
189:              		key_water_pwr_type = KEY_TYPE_IDLE;
190:              		key_water_mode_type = KEY_TYPE_IDLE;
191:                  } 
  06AD    2EBF    JP	0x6BF
192:                  else if (app_charge.LowPower) //低电
  06AE    0826    LD	A,0x26
  06AF    1903    SZB	0x3,2
  06B0    0008    RET
193:                  {
194:                      if (key_brush_pwrtype || key_water_pwr_type || key_water_mode_type)
  06B1    1283    CLRB	0x3,5
  06B2    084C    LD	A,0x4C
  06B3    1D03    SNZB	0x3,2
  06B4    2EBA    JP	0x6BA
  06B5    084B    LD	A,0x4B
  06B6    1903    SZB	0x3,2
  06B7    084A    LD	A,0x4A
  06B8    1903    SZB	0x3,2
  06B9    0008    RET
195:                      {
196:              			app_charge.LowLed = TURE;
  06BA    1683    SETB	0x3,5
  06BB    01A7    CLR	0x27
  06BC    0AA7    INCR	0x27
197:              			app_charge.LowLed_cnt = 0;
  06BD    01A8    CLR	0x28
198:                          key_brush_pwrtype = KEY_TYPE_IDLE;
199:              			key_water_pwr_type = KEY_TYPE_IDLE;
200:              			key_water_mode_type = KEY_TYPE_IDLE;
  06BE    2EBF    JP	0x6BF
201:                      }
202:                  }
203:              
204:              	// if (!app_charge.Charge)
205:              	// {
206:              	// 	if (flag_old_mode)
207:              	// 	{
208:              	// 		if (key_brush_pwrtype == KEY_TYPE_SHORT)
209:              	// 		{
210:              	// 			key_brush_pwrtype = KEY_TYPE_IDLE;
211:              	// 			app_process_set_work_state(WORK_STATE_POWEROFF);
212:              	// 		}
213:              	// 	}
214:              	// }
215:              	
216:              	
217:              	// if(key_brush_pwrtype == KEY_TYPE_LONG_LONG)
218:              	// {
219:              	// 	key_brush_pwrtype = KEY_TYPE_IDLE;
220:              	// }
221:              }
222:              
223:              void handle_key_pwr()
224:              {
225:                  switch (key_brush_pwrtype)
  04B7    2CDB    JP	0x4DB
226:                  {
227:                  case KEY_TYPE_SHORT:
228:              		// 如果当前是“工作”状态，则关机
229:                      if (app_work_state == WORK_STATE_WORKING)
  04B8    0B6D    SZDECA	0x6D
  04B9    2CC7    JP	0x4C7
230:                      {
231:                          if (water_work_state == WATER_WORK_STATE_POWEROFF && app_charge.Remind)
  04BA    086C    LD	A,0x6C
  04BB    1D03    SNZB	0x3,2
  04BC    2CC4    JP	0x4C4
  04BD    1683    SETB	0x3,5
  04BE    1E20    SNZB	0x20,4
  04BF    2CC4    JP	0x4C4
232:                          {
233:                              app_charge.flag_remind_delay_10s = 1;
  04C0    01A2    CLR	0x22
  04C1    0AA2    INCR	0x22
234:                              app_charge.remind_delay_10s_timer = 0;
  04C2    01A3    CLR	0x23
  04C3    01A4    CLR	0x24
235:                          }
236:                          app_process_set_work_state(WORK_STATE_POWEROFF);
  04C4    3000    LDIA	0x0
  04C5    27BE    CALL	0x7BE
237:                      }
  04C6    2CE4    JP	0x4E4
238:                      // 如果是“关机”或“仅显示LED”状态，则开机工作
239:                      else if (app_work_state == WORK_STATE_POWEROFF || app_work_state == WORK_STATE_MODE_LED)
  04C7    086D    LD	A,0x6D
  04C8    1903    SZB	0x3,2
  04C9    2CCE    JP	0x4CE
  04CA    3006    LDIA	0x6
  04CB    066D    XORA	0x6D
  04CC    1D03    SNZB	0x3,2
  04CD    2CE4    JP	0x4E4
  04CE    3001    LDIA	0x1
240:                      {
241:                          app_charge.flag_remind_delay_10s = 0;
  04CF    1683    SETB	0x3,5
  04D0    01A2    CLR	0x22
242:                          // 开机，使用当前已经选好的模式
243:                          app_process_set_work_state(WORK_STATE_WORKING); 
  04D1    27BE    CALL	0x7BE
244:                          app_process_set_mode_init(); // 初始化电机参数和计时器
  04D2    275B    CALL	0x75B
  04D3    2CE4    JP	0x4E4
245:                      }
246:              		/*
247:              		if (app_work_state == WORK_STATE_POWEROFF || app_charge.flag_remind_delay_10s)
248:              		{
249:              			app_charge.flag_remind_delay_10s = 0;
250:              			app_process_set_work_state(WORK_STATE_WORKING); 
251:              			app_process_set_mode_init();
252:              		}
253:              		else if (app_work_state == WORK_STATE_WORKING)
254:              		{
255:              			// if (app_timer.work_updown_count)
256:              			// {
257:              			// 	app_process_set_mode_next();
258:              			// }
259:              	 		// else
260:              			// {
261:              				if (water_work_state == WATER_WORK_STATE_POWEROFF)
262:              				{
263:              					if (app_charge.Remind)
264:              					{
265:              						app_charge.flag_remind_delay_10s = 1;
266:              						app_charge.remind_delay_10s_timer = 0;
267:              					}
268:              				}
269:              				app_process_set_work_state(WORK_STATE_POWEROFF);
270:              			// }
271:              		}*/
272:                      break;
273:              		
274:                  case KEY_TYPE_LONG:
275:              		// if (app_work_state == WORK_STATE_WORKING)
276:              		// {
277:              		// 	if (water_work_state == WATER_WORK_STATE_POWEROFF)
278:              		// 	{
279:              		// 		if (app_charge.Remind)
280:              		// 		{
281:              		// 			app_charge.flag_remind_delay_10s = 1;
282:              		// 			app_charge.remind_delay_10s_timer = 0;
283:              		// 		}
284:              		// 	}
285:              		// 	app_process_set_work_state(WORK_STATE_POWEROFF);
286:              		// }
287:                      app_process_set_mode_next();
  04D4    2771    CALL	0x771
288:              		// 2. 根据当前的工作状态，决定下一步做什么
289:                      if (app_work_state == WORK_STATE_WORKING)
  04D5    0B6D    SZDECA	0x6D
  04D6    2CD8    JP	0x4D8
  04D7    2CE4    JP	0x4E4
290:                      {
291:                          // 如果本来就是开机状态，那么什么也不用做。
292:                          // 电机会在下一个PWM周期自动采用新的参数，不会停止。
293:                      }
294:                      else // 包括 WORK_STATE_POWEROFF 和 WORK_STATE_MODE_LED 状态
295:                      {
296:                          // 如果原来是关机或仅显示LED的状态，
297:                          // 那么切换模式后，进入（或刷新）“仅显示LED”状态
298:                          app_process_set_work_state(WORK_STATE_MODE_LED);
  04D8    3006    LDIA	0x6
  04D9    27BE    CALL	0x7BE
  04DA    2CE4    JP	0x4E4
  04DB    1283    CLRB	0x3,5
  04DC    084C    LD	A,0x4C
  04DD    3A02    XORIA	0x2
  04DE    1903    SZB	0x3,2
  04DF    2CD4    JP	0x4D4
  04E0    3A07    XORIA	0x7
  04E1    1903    SZB	0x3,2
  04E2    2CB8    JP	0x4B8
  04E3    2CE4    JP	0x4E4
299:                      }
300:                      
301:              
302:                      break;
303:                  default:
304:                      break;
305:                  }
306:              	key_brush_pwrtype = KEY_TYPE_IDLE;
  04E4    01CC    CLR	0x4C
  04E5    0008    RET
307:              }
308:              
309:              void handle_key_water()
310:              {
311:              	switch (key_water_pwr_type)
  038F    2BAF    JP	0x3AF
312:                  {
313:                  case KEY_TYPE_SHORT:
314:              		if (water_work_state == WATER_WORK_STATE_WORKING)
  0390    0B6C    SZDECA	0x6C
  0391    2B9B    JP	0x39B
315:              		{
316:              			if (app_work_state == WORK_STATE_POWEROFF)
  0392    086D    LD	A,0x6D
  0393    1D03    SNZB	0x3,2
  0394    2B99    JP	0x399
317:              			{
318:              				if (app_charge.Remind)
  0395    1683    SETB	0x3,5
  0396    1E20    SNZB	0x20,4
  0397    2B99    JP	0x399
319:              				{
320:              					app_charge.flag_remind_delay_10s = 1;
321:              					app_charge.remind_delay_10s_timer = 0;
  0398    24B2    CALL	0x4B2
322:              				}
323:              			}
324:              			app_process_set_water_state(WATER_WORK_STATE_POWEROFF); 
  0399    3000    LDIA	0x0
  039A    2BAC    JP	0x3AC
325:              		}
326:              		else if (water_work_state == WATER_WORK_STATE_POWEROFF  || app_charge.flag_remind_delay_10s || water_work_state == WATER_WORK_STATE_MODE_LED)//开机
  039B    086C    LD	A,0x6C
  039C    1683    SETB	0x3,5
  039D    1903    SZB	0x3,2
  039E    2BA8    JP	0x3A8
  039F    0822    LD	A,0x22
  03A0    1D03    SNZB	0x3,2
  03A1    2BA7    JP	0x3A7
  03A2    3003    LDIA	0x3
  03A3    1283    CLRB	0x3,5
  03A4    066C    XORA	0x6C
  03A5    1D03    SNZB	0x3,2
  03A6    2BAD    JP	0x3AD
327:              		{
328:              			app_charge.flag_remind_delay_10s = 0;
  03A7    1683    SETB	0x3,5
  03A8    01A2    CLR	0x22
329:              			app_led_water_mode_set();
  03A9    2412    CALL	0x412
330:              			water_motor();
  03AA    2654    CALL	0x654
331:              			app_process_set_water_state(WATER_WORK_STATE_WORKING);
  03AB    3001    LDIA	0x1
  03AC    27C3    CALL	0x7C3
332:              		}
333:              		key_water_pwr_type = KEY_TYPE_IDLE;
  03AD    01CB    CLR	0x4B
334:                      break;
  03AE    2BB4    JP	0x3B4
  03AF    084B    LD	A,0x4B
  03B0    3A05    XORIA	0x5
  03B1    1903    SZB	0x3,2
  03B2    2B90    JP	0x390
  03B3    2BB4    JP	0x3B4
335:              		
336:                  default:
337:                      break;
338:                  }
339:              	key_water_pwr_type = KEY_TYPE_IDLE;
  03B4    01CB    CLR	0x4B
340:              	//----------------------water_mode---------------------------//
341:              	switch (key_water_mode_type)
  03B5    2BCB    JP	0x3CB
342:                  {
343:                  case KEY_TYPE_SHORT:
344:              		if (water_work_state == WATER_WORK_STATE_WORKING)
  03B6    0B6C    SZDECA	0x6C
  03B7    2BBC    JP	0x3BC
345:              		{
346:              			app_process_set_water_mode_next();
  03B8    2795    CALL	0x795
347:              			app_led_water_mode_set();
  03B9    2412    CALL	0x412
348:              			water_motor();
  03BA    2654    CALL	0x654
349:              		}
  03BB    2BC9    JP	0x3C9
350:              		else if (water_work_state == WATER_WORK_STATE_POWEROFF)
  03BC    086C    LD	A,0x6C
351:              		{
352:              			app_process_set_water_state(WATER_WORK_STATE_MODE_LED);
  03BD    3003    LDIA	0x3
  03BE    1D03    SNZB	0x3,2
  03BF    2BC2    JP	0x3C2
  03C0    27C3    CALL	0x7C3
  03C1    2BC8    JP	0x3C8
353:              			app_led_water_mode_set();
  03C2    066C    XORA	0x6C
  03C3    1D03    SNZB	0x3,2
  03C4    2BC9    JP	0x3C9
354:              		}
355:              		else if (water_work_state == WATER_WORK_STATE_MODE_LED)
356:              		{
357:              			app_process_set_water_state(WATER_WORK_STATE_MODE_LED);
  03C5    3003    LDIA	0x3
  03C6    27C3    CALL	0x7C3
358:              			app_process_set_water_mode_next();
  03C7    2795    CALL	0x795
359:              			app_led_water_mode_set();
  03C8    2412    CALL	0x412
360:              		}
361:              		key_water_mode_type = KEY_TYPE_IDLE;
  03C9    01CA    CLR	0x4A
362:                      break;
  03CA    2BD3    JP	0x3D3
  03CB    084A    LD	A,0x4A
  03CC    3A02    XORIA	0x2
  03CD    1903    SZB	0x3,2
  03CE    2BD3    JP	0x3D3
  03CF    3A07    XORIA	0x7
  03D0    1903    SZB	0x3,2
  03D1    2BB6    JP	0x3B6
  03D2    2BD3    JP	0x3D3
363:                  case KEY_TYPE_LONG:
364:              		// app_charge.flag_remind_delay_10s = 0;
365:              		// app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
366:                      break;
367:                  default:
368:                      break;
369:                  }
370:              	key_water_mode_type = KEY_TYPE_IDLE;
  03D3    01CA    CLR	0x4A
  03D4    0008    RET
371:              }
372:              
373:              void app_process_key()
374:              {
375:              	key_brush_pwr_check();
  07B2    2514    CALL	0x514
376:              	key_water_pwr_check();
  07B3    25C3    CALL	0x5C3
377:              	key_water_mode_check();
  07B4    25E9    CALL	0x5E9
378:                  charge_or_lowBat_check();
  07B5    26AA    CALL	0x6AA
379:                  handle_key_pwr();
  07B6    24B7    CALL	0x4B7
380:              	handle_key_water();
  07B7    2B8F    JP	0x38F
381:              }
382:              
383:              
384:              
385:              
386:              
387:              
388:              
389:              
390:              
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_motor.c ----------------------------------------------------------------------
1:                 #include "main.h"
2:                
3:                // work_state_t work_mode = WORK_MODE_IDEL;
4:                // work_state_t work_mode_old_keep;
5:                // volatile unsigned char ModeDuty = 0;
6:                // volatile unsigned char ModeDuty_restore = 0;
7:                // volatile unsigned char Mode2TimeCnt = 0;
8:                // volatile unsigned char TimerDiyShakeDelay;
9:                // unsigned char TimerDiyDelay300ms;
10:               
11:               
12:               u8 low_a;
13:               u8 dead_area1;
14:               
15:               u8 low_b;
16:               u8 dead_area_b1;
17:               u8 dead_area_b2;
18:               
19:               //u8 Period;
20:               //u8 DutyLow;
21:               //u8 DutyHigh;
22:               //u8 motor_time;
23:               
24:               MOTOR_InitTypeDef MOTOR_InitStruct = { 0 };
25:               //---------------------------------------------
26:               
27:               app_motor_pwm_pram_t app_motor_pwm_pram = 
28:               {
29:                   0
30:               };
31:               
32:               static volatile uint16_t motor_fix_cnt;
33:               
34:               void app_process_set_mode_init()
35:               {
36:                   work_mode.mode_out_put = work_mode.mode;
  075B    0866    LD	A,0x66
  075C    00E7    LD	0x67,A
37:                   app_timer.work_updown_count = SECOND(5);
  075D    3001    LDIA	0x1
  075E    1683    SETB	0x3,5
  075F    01B7    CLR	0x37
  0760    01B6    CLR	0x36
  0761    00B5    LD	0x35,A
  0762    30F4    LDIA	0xF4
  0763    00B4    LD	0x34,A
38:                   app_led_mode_set();
  0764    260F    CALL	0x60F
39:               	app_process_motor_duty();
  0765    2AF6    JP	0x2F6
40:               }
41:               
42:               void app_process_set_mode_next(void)
  0771    3004    LDIA	0x4
43:               {
44:                   work_mode.mode++;
  0772    1283    CLRB	0x3,5
  0773    0AE6    INCR	0x66
45:               	if (work_mode.mode > WORK_MODE_THREE)
  0774    0266    SUBA	0x66
  0775    1C03    SNZB	0x3,0
  0776    2F79    JP	0x779
46:               	{
47:               		work_mode.mode = WORK_MODE_ONE;
  0777    01E6    CLR	0x66
  0778    0AE6    INCR	0x66
48:               	}
49:                   //app_timer.work_updown_count = SECOND(5);
50:                   app_led_mode_set();
  0779    260F    CALL	0x60F
51:               	app_process_motor_duty();
  077A    2AF6    JP	0x2F6
52:               }
53:               
54:               void app_process_motor_duty()
55:               {
56:               	 switch (work_mode.mode)
  02F6    2B0B    JP	0x30B
57:                   {
58:                   case WORK_MODE_ONE:
59:                       MOTOR_InitStruct.Period = MOTOR_155Hz;
  02F7    307F    LDIA	0x7F
  02F8    1683    SETB	0x3,5
  02F9    00BC    LD	0x3C,A
60:                       MOTOR_InitStruct.DutyLow = MOTOR_155Hz_Duty_100;
  02FA    3033    LDIA	0x33
  02FB    2B05    JP	0x305
61:                       MOTOR_InitStruct.DutyHigh = MOTOR_155Hz_Duty_100;
62:                       work_mode.mode_out_put = work_mode.mode;
63:                       break;
64:                   case WORK_MODE_TWO:
65:                       MOTOR_InitStruct.Period = MOTOR_200Hz;
  02FC    3062    LDIA	0x62
  02FD    1683    SETB	0x3,5
  02FE    00BC    LD	0x3C,A
66:                       MOTOR_InitStruct.DutyLow = MOTOR_200Hz_Duty_90;
  02FF    3027    LDIA	0x27
  0300    2B05    JP	0x305
67:                       MOTOR_InitStruct.DutyHigh = MOTOR_200Hz_Duty_90;
68:                        work_mode.mode_out_put = work_mode.mode;
69:                       break;
70:                   case WORK_MODE_THREE:
71:                       MOTOR_InitStruct.Period = MOTOR_260Hz;
  0301    304B    LDIA	0x4B
  0302    1683    SETB	0x3,5
  0303    00BC    LD	0x3C,A
72:                       MOTOR_InitStruct.DutyLow = MOTOR_260Hz_Duty_70;
  0304    301E    LDIA	0x1E
  0305    00BD    LD	0x3D,A
73:                       MOTOR_InitStruct.DutyHigh = MOTOR_260Hz_Duty_70;
  0306    00BE    LD	0x3E,A
74:                       work_mode.mode_out_put = work_mode.mode;
  0307    1283    CLRB	0x3,5
  0308    0866    LD	A,0x66
  0309    00E7    LD	0x67,A
75:                       break;
  030A    2B16    JP	0x316
  030B    0866    LD	A,0x66
  030C    3A01    XORIA	0x1
  030D    1903    SZB	0x3,2
  030E    2AF7    JP	0x2F7
  030F    3A03    XORIA	0x3
  0310    1903    SZB	0x3,2
  0311    2AFC    JP	0x2FC
  0312    3A01    XORIA	0x1
  0313    1903    SZB	0x3,2
  0314    2B01    JP	0x301
  0315    2B16    JP	0x316
76:                   
77:                   default: 
78:                       break;
79:                   }
80:               	low_a = (MOTOR_InitStruct.DutyLow);//低电平的时间
  0316    1683    SETB	0x3,5
  0317    083D    LD	A,0x3D
  0318    1283    CLRB	0x3,5
  0319    00BF    LD	0x3F,A
81:                   dead_area1 =  (MOTOR_InitStruct.Period);
  031A    1683    SETB	0x3,5
  031B    083C    LD	A,0x3C
  031C    1283    CLRB	0x3,5
  031D    00BE    LD	0x3E,A
82:               
83:                   dead_area_b1 = MOTOR_InitStruct.DutyLow + (((MOTOR_InitStruct.Period - MOTOR_InitStruct.DutyLow) - MOTOR_InitStruct.DutyHigh) >> 1);
  031E    1683    SETB	0x3,5
  031F    083C    LD	A,0x3C
  0320    1283    CLRB	0x3,5
  0321    00D3    LD	0x53,A
  0322    01D4    CLR	0x54
  0323    0854    LD	A,0x54
  0324    00D6    LD	0x56,A
  0325    1683    SETB	0x3,5
  0326    083D    LD	A,0x3D
  0327    1283    CLRB	0x3,5
  0328    0253    SUBA	0x53
  0329    00D5    LD	0x55,A
  032A    1C03    SNZB	0x3,0
  032B    03D6    DECR	0x56
  032C    0856    LD	A,0x56
  032D    00D8    LD	0x58,A
  032E    1683    SETB	0x3,5
  032F    083E    LD	A,0x3E
  0330    1283    CLRB	0x3,5
  0331    0255    SUBA	0x55
  0332    00D7    LD	0x57,A
  0333    1C03    SNZB	0x3,0
  0334    03D8    DECR	0x58
  0335    0D58    RLCA	0x58
  0336    0CD8    RRCR	0x58
  0337    0CD7    RRCR	0x57
  0338    1683    SETB	0x3,5
  0339    083D    LD	A,0x3D
  033A    1283    CLRB	0x3,5
  033B    0757    ADDA	0x57
  033C    00BC    LD	0x3C,A
84:                   low_b = MOTOR_InitStruct.DutyHigh + dead_area_b1;
  033D    1683    SETB	0x3,5
  033E    073E    ADDA	0x3E
  033F    1283    CLRB	0x3,5
  0340    00BD    LD	0x3D,A
85:                   dead_area_b2 =  (MOTOR_InitStruct.Period);
  0341    1683    SETB	0x3,5
  0342    083C    LD	A,0x3C
  0343    1283    CLRB	0x3,5
  0344    00BB    LD	0x3B,A
  0345    0008    RET
86:               }
87:               
88:               #if 1
89:               void Mode_control(void)	//50us
90:               {
91:               	//if((app_work_state == WORK_STATE_WORKING || app_work_state == WORK_STATE_OLD_MODE_RUN))
92:               	//if(PwrOnBit && (!MotorStopBit))
93:               	//{
94:               		if(WORK_MODE_IDEL == work_mode.mode_out_put)
  0346    0867    LD	A,0x67
  0347    1D03    SNZB	0x3,2
  0348    2B4C    JP	0x34C
95:               		{
96:               			INA = 0;
  0349    1286    CLRB	0x6,5
97:               			INB = 0;
  034A    1306    CLRB	0x6,6
98:               			return;
  034B    0008    RET
99:               		}
100:              
101:              		motor_fix_cnt++;
  034C    0AA6    INCR	0x26
  034D    1903    SZB	0x3,2
  034E    0AA7    INCR	0x27
102:              		if (motor_fix_cnt <= low_a) 
  034F    083F    LD	A,0x3F
  0350    00F0    LD	0x70,A
  0351    01F1    CLR	0x71
  0352    0827    LD	A,0x27
  0353    0271    SUBA	0x71
  0354    1D03    SNZB	0x3,2
  0355    2B58    JP	0x358
  0356    0826    LD	A,0x26
  0357    0270    SUBA	0x70
  0358    1C03    SNZB	0x3,0
  0359    2B5C    JP	0x35C
103:              		{
104:              			INA = 0;
  035A    1286    CLRB	0x6,5
105:              			// INA_OFF
106:              		}
  035B    2B67    JP	0x367
107:              		else if (motor_fix_cnt <= dead_area1)
  035C    083E    LD	A,0x3E
  035D    00F0    LD	0x70,A
  035E    01F1    CLR	0x71
  035F    0827    LD	A,0x27
  0360    0271    SUBA	0x71
  0361    1D03    SNZB	0x3,2
  0362    2B65    JP	0x365
  0363    0826    LD	A,0x26
  0364    0270    SUBA	0x70
  0365    1803    SZB	0x3,0
108:              		{
109:              			INA = 1;
  0366    1686    SETB	0x6,5
110:              			// INA_ON
111:              		}
112:              		else
113:              		{
114:              			// motor_fix_cnt = 0;
115:              		}
116:              
117:              		if (motor_fix_cnt <= dead_area_b1)
  0367    083C    LD	A,0x3C
  0368    00F0    LD	0x70,A
  0369    01F1    CLR	0x71
  036A    0827    LD	A,0x27
  036B    0271    SUBA	0x71
  036C    1D03    SNZB	0x3,2
  036D    2B70    JP	0x370
  036E    0826    LD	A,0x26
  036F    0270    SUBA	0x70
  0370    1C03    SNZB	0x3,0
  0371    2B74    JP	0x374
118:              		{
119:              			INB = 1;
  0372    1706    SETB	0x6,6
120:              			// INB_ON
121:              		}
  0373    0008    RET
122:              		else if (motor_fix_cnt <= low_b)
  0374    083D    LD	A,0x3D
  0375    00F0    LD	0x70,A
  0376    01F1    CLR	0x71
  0377    0827    LD	A,0x27
  0378    0271    SUBA	0x71
  0379    1D03    SNZB	0x3,2
  037A    2B7D    JP	0x37D
  037B    0826    LD	A,0x26
  037C    0270    SUBA	0x70
  037D    1C03    SNZB	0x3,0
  037E    2B81    JP	0x381
123:              		{
124:              			INB = 0;
  037F    1306    CLRB	0x6,6
125:              			// INB_OFF
126:              		}
  0380    0008    RET
127:              		else if (motor_fix_cnt <= dead_area_b2)
  0381    083B    LD	A,0x3B
  0382    00F0    LD	0x70,A
  0383    01F1    CLR	0x71
  0384    0827    LD	A,0x27
  0385    0271    SUBA	0x71
  0386    1D03    SNZB	0x3,2
  0387    2B8A    JP	0x38A
  0388    0826    LD	A,0x26
  0389    0270    SUBA	0x70
  038A    1803    SZB	0x3,0
  038B    2B72    JP	0x372
128:              		{
129:              			INB = 1;
130:              			// INB_ON
131:              		}
132:              		else
133:              		{
134:              			motor_fix_cnt = 0;
  038C    01A6    CLR	0x26
  038D    01A7    CLR	0x27
  038E    0008    RET
135:              		}
136:              	//}
137:              }
138:              
139:              #endif
140:              
141:              // void app_motor_process()
142:              // {
143:              //    if (app_work_state == WORK_STATE_WORKING)
144:              //     {
145:              //         if (!app_charge.Charge)
146:              //         {
147:              //             app_motor_mode_one_set();
148:              //             app_motor_mode_two_set();
149:              //             app_motor_mode_three_set();
150:              //             app_motor_pulse_mode_set();
151:              //             app_motor_diy_mode_set();
152:              //         }
153:              //     }
154:              // }
155:              
156:              
157:              
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_charge.c ----------------------------------------------------------------------
1:                
2:                #include "main.h"
3:                
4:                app_charge_t app_charge = 
5:                {
6:                	0
7:                	// .Charge = 0,
8:                	// .FullCharge = 0,
9:                	// .low_bat_3V3 = 0,
10:               	// .LowPower = 0,
11:               	// .LowLed = 0,
12:               	// .ChargeCnt = 0,
13:               	// .ChargeFullCnt = 0,
14:               };
15:               
16:               bit flag_charge_once;
17:               bit flag_discharge_once;
18:               
19:               volatile uint adresultvdd_back = 0;
20:               
21:               //bit flag_charge_force_full_24hour;
22:               unsigned long charge_force_full_cnt;
23:               
24:               unsigned char charge_full_cnt;
25:               unsigned int charge_full_cnt1;
26:               
27:               volatile uint adresult_chagrge_vdd = 0;
28:               //u16 Charge_BatAdValue = 0;
29:               u8	Charge_BatAdSumCnt = 0;
30:               u16 Charge_BatAdTmp = 0;
31:               u32 Charge_BatAdSum = 0;
32:               
33:               #define CHARGE_VOL_SET_FULL   1300   //1V
34:               
35:               #define CHARGE_VOL_SET   1700   //2.4V
36:               
37:               #define _XTAL_FREQ 16000000UL		//如果用16M晶振则改为16000000UL
38:               void ChargePwmOut(unsigned char Duty)
  0720    00D3    LD	0x53,A
39:               {
40:               	if(Duty == 0)
  0721    0853    LD	A,0x53
  0722    1D03    SNZB	0x3,2
  0723    2F28    JP	0x728
41:               	{
42:               		PWM0EN = 0;
  0724    101B    CLRB	0x1B,0
43:               		TRISB3 = 1;
  0725    1683    SETB	0x3,5
  0726    1586    SETB	0x6,3
44:               	}
  0727    0008    RET
45:               	else
46:               	{
47:               		if(!PWM0EN)
  0728    1C1B    SNZB	0x1B,0
48:               		{
49:               			PWM0EN = 1;
  0729    141B    SETB	0x1B,0
50:               		}
51:               		CHRG_OUT_PUT();
  072A    1683    SETB	0x3,5
  072B    1186    CLRB	0x6,3
52:               		PWMD0L = Duty;
  072C    1283    CLRB	0x3,5
  072D    0853    LD	A,0x53
  072E    0096    LD	0x16,A
  072F    0008    RET
53:               	}
54:               }
55:               
56:               void Charge_Check(void)                       // 0001 0001
57:               {	
58:               	ADCON0 = 0b00110001;   //AN12 0011 0001
  002E    3031    LDIA	0x31
  002F    1283    CLRB	0x3,5
  0030    009F    LD	0x1F,A
59:               	__delay_us(20);		//延时100us 	
  0031    301A    LDIA	0x1A
  0032    1283    CLRB	0x3,5
  0033    00E0    LD	0x60,A
  0034    0BE0    SZDECR	0x60
  0035    2834    JP	0x34
60:               	ADCON1 = 0b00000100;   //2.4V
  0036    3004    LDIA	0x4
  0037    1683    SETB	0x3,5
  0038    009F    LD	0x1F,A
61:               	__delay_us(20);		//延时100us 	
  0039    301A    LDIA	0x1A
  003A    1283    CLRB	0x3,5
  003B    00E0    LD	0x60,A
  003C    0BE0    SZDECR	0x60
  003D    283C    JP	0x3C
62:               	adresult_chagrge_vdd = AdcResultChk(VREF2_4V,CHARGE_AN12);
  003E    300C    LDIA	0xC
  003F    1283    CLRB	0x3,5
  0040    00D9    LD	0x59,A
  0041    3004    LDIA	0x4
  0042    274D    CALL	0x74D
  0043    085A    LD	A,0x5A
  0044    00B3    LD	0x33,A
  0045    0859    LD	A,0x59
  0046    00B2    LD	0x32,A
63:               	// if(Charge_BatAdSumCnt < 8)
64:               	// {
65:               	// 	Charge_BatAdSumCnt++;
66:               	// 	Charge_BatAdSum += Charge_BatAdTmp;
67:               	// }
68:               	// else
69:               	// {
70:               	// 	adresult_chagrge_vdd = Charge_BatAdTmp >> 3;
71:               		
72:               	// 	Charge_BatAdSum = 0;
73:               	// 	Charge_BatAdSumCnt = 0;
74:               	// }
75:               	if (adresult_chagrge_vdd < CHARGE_VOL_SET_FULL) //拔电
  0047    3005    LDIA	0x5
  0048    0233    SUBA	0x33
  0049    3014    LDIA	0x14
  004A    1903    SZB	0x3,2
  004B    0232    SUBA	0x32
  004C    1803    SZB	0x3,0
  004D    2869    JP	0x69
76:               	{
77:               		if (!flag_charge_once)
  004E    1B7B    SZB	0x7B,6
  004F    286C    JP	0x6C
78:               		{
79:               			app_charge.DisChargeCnt++;
  0050    1683    SETB	0x3,5
  0051    0AAB    INCR	0x2B
  0052    1903    SZB	0x3,2
  0053    0AAC    INCR	0x2C
80:               			if(app_charge.DisChargeCnt >= MS(500))
  0054    3000    LDIA	0x0
  0055    022C    SUBA	0x2C
  0056    3032    LDIA	0x32
  0057    1903    SZB	0x3,2
  0058    022B    SUBA	0x2B
  0059    1C03    SNZB	0x3,0
  005A    286C    JP	0x6C
  005B    3003    LDIA	0x3
81:               			{
82:               				flag_charge_once = 1;
  005C    177B    SETB	0x7B,6
83:               				flag_discharge_once = 0;
  005D    12FB    CLRB	0x7B,5
84:               
85:               				app_charge.DisChargeCnt = 0;
  005E    01AB    CLR	0x2B
  005F    01AC    CLR	0x2C
86:               				app_charge.Charge = FLASE;
  0060    1020    CLRB	0x20,0
87:               				app_charge.FullCharge = FLASE;
  0061    10A0    CLRB	0x20,1
88:                          		set_led_state(LED_INDEX_9 | LED_INDEX_10,LED_STATE_OFF);
  0062    2134    CALL	0x134
  0063    256E    CALL	0x56E
89:               				ChargePwmOut(0);
  0064    3000    LDIA	0x0
  0065    2720    CALL	0x720
90:               				app_process_set_work_state(WORK_STATE_POWEROFF);
  0066    3000    LDIA	0x0
  0067    27BE    CALL	0x7BE
  0068    286C    JP	0x6C
91:               			}
92:               		}
93:               	}
94:               	else
95:               	{
96:               		app_charge.DisChargeCnt = 0;
  0069    1683    SETB	0x3,5
  006A    01AB    CLR	0x2B
  006B    01AC    CLR	0x2C
97:               	}
98:               	if (adresult_chagrge_vdd > CHARGE_VOL_SET)
  006C    3006    LDIA	0x6
  006D    1283    CLRB	0x3,5
  006E    0233    SUBA	0x33
  006F    30A5    LDIA	0xA5
  0070    1903    SZB	0x3,2
  0071    0232    SUBA	0x32
  0072    1C03    SNZB	0x3,0
  0073    2891    JP	0x91
99:               	{
100:              		if (!flag_discharge_once)
  0074    1AFB    SZB	0x7B,5
  0075    2894    JP	0x94
101:              		{
102:              			if (app_charge.ChargeCnt <= MS(100))
  0076    3000    LDIA	0x0
  0077    1683    SETB	0x3,5
  0078    022A    SUBA	0x2A
  0079    300B    LDIA	0xB
  007A    1903    SZB	0x3,2
  007B    0229    SUBA	0x29
  007C    1803    SZB	0x3,0
  007D    2882    JP	0x82
103:              			{
104:              				app_charge.ChargeCnt++;
  007E    0AA9    INCR	0x29
  007F    1903    SZB	0x3,2
  0080    0AAA    INCR	0x2A
105:              			}
  0081    2894    JP	0x94
106:              			else
107:              			{
108:              				flag_charge_once = 0;
  0082    137B    CLRB	0x7B,6
109:              				flag_discharge_once = 1;
  0083    16FB    SETB	0x7B,5
110:              
111:              				app_charge.ChargeFullCnt = 0;
  0084    01AD    CLR	0x2D
  0085    01AE    CLR	0x2E
112:              				app_charge.ChargeCnt = 0;
  0086    01A9    CLR	0x29
  0087    01AA    CLR	0x2A
113:              				app_charge.Charge = TURE;
  0088    1420    SETB	0x20,0
114:              				app_charge.FullCharge = 0;
  0089    10A0    CLRB	0x20,1
115:              
116:              				adresultvdd_back = 4096;
  008A    1283    CLRB	0x3,5
  008B    01B4    CLR	0x34
  008C    3010    LDIA	0x10
  008D    00B5    LD	0x35,A
117:              				app_process_set_work_state(WORK_STATE_CHARGING);
  008E    3002    LDIA	0x2
  008F    27BE    CALL	0x7BE
  0090    2894    JP	0x94
118:              			}
119:              		}
120:              	}
121:              	else
122:              	{
123:              		app_charge.ChargeCnt = 0;
  0091    1683    SETB	0x3,5
  0092    01A9    CLR	0x29
  0093    01AA    CLR	0x2A
124:              	}
125:              	if(app_charge.Charge)
  0094    1683    SETB	0x3,5
  0095    1C20    SNZB	0x20,0
  0096    2921    JP	0x121
126:              	{
127:              		if(app_charge.FullCharge || app_charge.ForceFullCharge)
  0097    18A0    SZB	0x20,1
  0098    289B    JP	0x9B
  0099    1D20    SNZB	0x20,2
  009A    28CC    JP	0xCC
128:              		{
129:              			if (charge_force_full_cnt <= (100UL * 3600 *15 + 100UL * 3600 *9)) //再过九个小时灯灭
  009B    0846    LD	A,0x46
  009C    1D03    SNZB	0x3,2
  009D    28B2    JP	0xB2
  009E    3083    LDIA	0x83
  009F    0245    SUBA	0x45
  00A0    1D03    SNZB	0x3,2
  00A1    28A8    JP	0xA8
  00A2    30D6    LDIA	0xD6
  00A3    0244    SUBA	0x44
  00A4    1D03    SNZB	0x3,2
  00A5    28A8    JP	0xA8
  00A6    3001    LDIA	0x1
  00A7    0243    SUBA	0x43
  00A8    1803    SZB	0x3,0
  00A9    28B2    JP	0xB2
130:              			// if (charge_force_full_cnt <= (100UL * 60 *2 + 100UL * 60 *1)) //再过九个小时灯灭
131:              			{
132:              				charge_force_full_cnt++;
  00AA    0AC3    INCR	0x43
  00AB    1903    SZB	0x3,2
  00AC    0AC4    INCR	0x44
  00AD    1903    SZB	0x3,2
  00AE    0AC5    INCR	0x45
  00AF    1903    SZB	0x3,2
  00B0    0AC6    INCR	0x46
133:              			}
  00B1    28B3    JP	0xB3
134:              			else
135:              			{
136:              				app_charge.flag_charge_force_full_24hour = 1;
  00B2    15A0    SETB	0x20,3
137:              			}
138:              			if (app_charge.flag_charge_force_full_24hour)
  00B3    1DA0    SNZB	0x20,3
  00B4    28B8    JP	0xB8
139:              			{
140:              				CHRG_OUT_PUT_FULL();//关掉充电
  00B5    1283    CLRB	0x3,5
  00B6    212E    CALL	0x12E
141:              			}
  00B7    0008    RET
142:              			else
143:              			{
144:              				if (app_charge.ForceFullCharge)
  00B8    1920    SZB	0x20,2
  00B9    28B5    JP	0xB5
145:              				{
146:              					CHRG_OUT_PUT_FULL();//关掉充电
147:              				}
148:              				else
149:              				{
150:              					if (adresultvdd > Voltage4V05)  //如果小于4.05V复冲
  00BA    3004    LDIA	0x4
  00BB    1283    CLRB	0x3,5
  00BC    0237    SUBA	0x37
  00BD    30BE    LDIA	0xBE
  00BE    1903    SZB	0x3,2
  00BF    0236    SUBA	0x36
  00C0    1C03    SNZB	0x3,0
  00C1    28C4    JP	0xC4
151:              					{
152:              						ChargePwmOut(60);
  00C2    303C    LDIA	0x3C
  00C3    2F20    JP	0x720
153:              					}
154:              					else if(adresultvdd <= Voltage4V15)
  00C4    3004    LDIA	0x4
  00C5    0237    SUBA	0x37
  00C6    309D    LDIA	0x9D
  00C7    1903    SZB	0x3,2
  00C8    0236    SUBA	0x36
  00C9    1803    SZB	0x3,0
  00CA    0008    RET
  00CB    28B5    JP	0xB5
155:              					{
156:              						CHRG_OUT_PUT_FULL();//关掉充电
157:              					}
158:              			}
159:              			}
160:              			
161:              		}
162:              		else
163:              		{
164:              			//当电池电压冲到4.1V，强制充满电
165:              			// if (adresultvdd < Voltage4V1)
166:              			// {
167:              			// 	SysTime30minCnt++;
168:              			// 	if (SysTime30minCnt > 100UL * 60 * 30)//30min
169:              			// 	{
170:              			// 		app_charge.FullCharge = 1;
171:              			// 	}
172:              			// }
173:              			// else
174:              			// {
175:              			// 	SysTime30minCnt = 0;
176:              			// }	
177:              			if (adresultvdd <= Voltage4V1) //如果大于4.15V停止充电
178:              			{
179:              				if (++charge_full_cnt1 >= MINUTE(30))
180:              				{
181:              					CHRG_OUT_PUT_FULL();//关掉充电
182:              					app_charge.FullCharge = TURE;
183:              				}
184:              			} 
185:              			if (adresultvdd <= Voltage4V2) //如果大于4.2V停止充电
  00CC    3004    LDIA	0x4
  00CD    1283    CLRB	0x3,5
  00CE    0237    SUBA	0x37
  00CF    3093    LDIA	0x93
  00D0    1903    SZB	0x3,2
  00D1    0236    SUBA	0x36
  00D2    1803    SZB	0x3,0
  00D3    28DD    JP	0xDD
186:              			{
187:              				if (++charge_full_cnt >= 100)
  00D4    3064    LDIA	0x64
  00D5    0ACD    INCR	0x4D
  00D6    024D    SUBA	0x4D
  00D7    1C03    SNZB	0x3,0
  00D8    28DE    JP	0xDE
188:              				{
189:              					CHRG_OUT_PUT_FULL();//关掉充电
  00D9    212E    CALL	0x12E
190:              					app_charge.FullCharge = TURE;
  00DA    1683    SETB	0x3,5
  00DB    14A0    SETB	0x20,1
  00DC    28DE    JP	0xDE
191:              				}
192:              			} 
193:              			else
194:              			{
195:              				charge_full_cnt = 0;
  00DD    01CD    CLR	0x4D
196:              			}
197:              			//
198:              			if (charge_force_full_cnt <= 100UL * 3600 *15)//100 * 3600 *15  
  00DE    1683    SETB	0x3,5
  00DF    0846    LD	A,0x46
  00E0    1D03    SNZB	0x3,2
  00E1    28F6    JP	0xF6
  00E2    3052    LDIA	0x52
  00E3    0245    SUBA	0x45
  00E4    1D03    SNZB	0x3,2
  00E5    28EC    JP	0xEC
  00E6    3065    LDIA	0x65
  00E7    0244    SUBA	0x44
  00E8    1D03    SNZB	0x3,2
  00E9    28EC    JP	0xEC
  00EA    30C1    LDIA	0xC1
  00EB    0243    SUBA	0x43
  00EC    1803    SZB	0x3,0
  00ED    28F6    JP	0xF6
199:              			// if (charge_force_full_cnt <= 100UL * 60 * 2)//100 * 3600 *15  
200:              			{
201:              				charge_force_full_cnt++;
  00EE    0AC3    INCR	0x43
  00EF    1903    SZB	0x3,2
  00F0    0AC4    INCR	0x44
  00F1    1903    SZB	0x3,2
  00F2    0AC5    INCR	0x45
  00F3    1903    SZB	0x3,2
  00F4    0AC6    INCR	0x46
202:              			}
  00F5    28F7    JP	0xF7
203:              			else
204:              			{
205:              				app_charge.ForceFullCharge = TURE;
  00F6    1520    SETB	0x20,2
206:              			}
207:              
208:              			if (adresultvdd_back >= adresultvdd)
  00F7    1283    CLRB	0x3,5
  00F8    0837    LD	A,0x37
  00F9    0235    SUBA	0x35
  00FA    1D03    SNZB	0x3,2
  00FB    28FE    JP	0xFE
  00FC    0836    LD	A,0x36
  00FD    0234    SUBA	0x34
  00FE    1C03    SNZB	0x3,0
  00FF    2904    JP	0x104
209:              			{
210:              				adresultvdd_back = adresultvdd;
  0100    0837    LD	A,0x37
  0101    00B5    LD	0x35,A
  0102    0836    LD	A,0x36
  0103    00B4    LD	0x34,A
211:              			}
212:              			
213:              			
214:              			if(adresultvdd_back < Voltage4V1)
  0104    3004    LDIA	0x4
  0105    0235    SUBA	0x35
  0106    30AF    LDIA	0xAF
  0107    1903    SZB	0x3,2
  0108    0234    SUBA	0x34
  0109    1803    SZB	0x3,0
  010A    290D    JP	0x10D
215:              			{
216:              				ChargePwmOut(60);
  010B    303C    LDIA	0x3C
  010C    2F20    JP	0x720
217:              			}
218:              			else if(adresultvdd_back < Voltage4V0)
  010D    3004    LDIA	0x4
  010E    0235    SUBA	0x35
  010F    30CC    LDIA	0xCC
  0110    1903    SZB	0x3,2
  0111    0234    SUBA	0x34
  0112    1803    SZB	0x3,0
  0113    2916    JP	0x116
219:              			{
220:              				ChargePwmOut(60);
  0114    303C    LDIA	0x3C
  0115    2F20    JP	0x720
221:              			}
222:              			else if(adresultvdd_back < Voltage3V4)
  0116    3005    LDIA	0x5
  0117    0235    SUBA	0x35
  0118    30A5    LDIA	0xA5
  0119    1903    SZB	0x3,2
  011A    0234    SUBA	0x34
  011B    1803    SZB	0x3,0
  011C    291F    JP	0x11F
223:              			{
224:              				ChargePwmOut(80);
  011D    3050    LDIA	0x50
  011E    2F20    JP	0x720
225:              			}
226:              			else
227:              			{
228:              				ChargePwmOut(60);   //小于3.5V就是60%的pwm输出
  011F    303C    LDIA	0x3C
  0120    2F20    JP	0x720
229:              			}
230:              		}
231:              	}
232:              	else
233:              	{
234:              		charge_full_cnt1 = 0;
235:              		charge_full_cnt = 0;
  0121    1283    CLRB	0x3,5
  0122    01CD    CLR	0x4D
236:              		charge_force_full_cnt = 0;
  0123    1683    SETB	0x3,5
  0124    01C3    CLR	0x43
  0125    01C4    CLR	0x44
  0126    01C5    CLR	0x45
  0127    01C6    CLR	0x46
237:              		app_charge.flag_charge_force_full_24hour = 0;
  0128    11A0    CLRB	0x20,3
238:              		app_charge.FullCharge = 0;
  0129    10A0    CLRB	0x20,1
239:              		app_charge.ForceFullCharge = 0;	
  012A    1120    CLRB	0x20,2
240:              		app_charge.ChargeFullCnt = 0;
  012B    01AD    CLR	0x2D
  012C    01AE    CLR	0x2E
  012D    0008    RET
241:              	}
242:              }
243:              
244:              void app_process_charge()
245:              {
246:                  Charge_Check(); 
  07CD    282E    JP	0x2E
247:              }
---- F:\zyl-work\正在研发文件夹\03-艾柏尔\ABB868\app_adc.c ----------------------------------------------------------------------
1:                
2:                #include "main.h"
3:                
4:                volatile unsigned int	adresult;
5:                volatile unsigned long adsum;
6:                volatile unsigned int admin,admax;
7:                volatile unsigned char adtimes;
8:                volatile uint adresultvdd = 0;
9:                volatile uint adresultvdd_back = 0;
10:               volatile unsigned char BatStates = 5;
11:               volatile unsigned char BatAdcCnt;
12:               volatile unsigned char CntLowPowerOff;
13:               volatile uint adresultmotor;
14:               volatile uchar motor_lock_cnt = 0;
15:               // unsigned char FlagOldMode;
16:               unsigned char bat_remind_delay;
17:               
18:               //u16 BatAdValue = 0;
19:               u8	BatAdSumCnt = 0;
20:               u16 BatAdTmp = 0;
21:               u32 BatAdSum = 0;
22:               
23:               
24:               #define _XTAL_FREQ 16000000UL		//如果用16M晶振则改为16000000UL
25:               
26:               
27:               static uint AdcOneChk(uchar adch,uchar adldo)	//ADC单次采样
28:               {
29:               	volatile uchar i = 0;
  0541    01D6    CLR	0x56
30:               	volatile uint ad_result;
31:               	
32:               	//ADCON1 = adldo;//0B00001100;						//左对齐，用2.4V做AD参考 
33:               	__delay_us(20);		//延时100us 					//延时20us
  0542    301A    LDIA	0x1A
  0543    1283    CLRB	0x3,5
  0544    00D5    LD	0x55,A
  0545    0BD5    SZDECR	0x55
  0546    2D45    JP	0x545
  0547    0000    NOP
  0548    0000    NOP
  0549    0000    NOP
  054A    0000    NOP
34:               	//ADCON0 = 0X41 | (adch << 2);	//16分频
35:               	asm("nop");
36:               	asm("nop");
37:               	asm("nop");
38:               	asm("nop");
39:               	GODONE = 1;						//开始转换
  054B    1283    CLRB	0x3,5
  054C    149F    SETB	0x1F,1
40:               
41:               	while(GODONE)
  054D    1C9F    SNZB	0x1F,1
  054E    2D56    JP	0x556
  054F    0064    CLRWDT
42:               	{
43:               		asm("clrwdt");
44:               		if(0 == (--i))
  0550    1283    CLRB	0x3,5
  0551    0BD6    SZDECR	0x56
  0552    2D4D    JP	0x54D
45:               			return 0;				//转换超时
  0553    01D3    CLR	0x53
  0554    01D4    CLR	0x54
  0555    0008    RET
46:               	}
47:               	ad_result=ADRESH;
  0556    081E    LD	A,0x1E
  0557    00D7    LD	0x57,A
  0558    01D8    CLR	0x58
48:               	ad_result= (ad_result<<4);
  0559    0ED7    SWAPR	0x57
  055A    0ED8    SWAPR	0x58
  055B    30F0    LDIA	0xF0
  055C    05D8    ANDR	0x58
  055D    0857    LD	A,0x57
  055E    390F    ANDIA	0xF
  055F    04D8    ORR	0x58
  0560    30F0    LDIA	0xF0
  0561    05D7    ANDR	0x57
49:               	ad_result +=(ADRESL>>4);	//计算12位AD值
  0562    1683    SETB	0x3,5
  0563    0E1E    SWAPA	0x1E
  0564    390F    ANDIA	0xF
  0565    1283    CLRB	0x3,5
  0566    07D7    ADDR	0x57
  0567    1803    SZB	0x3,0
  0568    0AD8    INCR	0x58
50:               	//ad_result=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值;
51:               	return ad_result;
  0569    0858    LD	A,0x58
  056A    00D4    LD	0x54,A
  056B    0857    LD	A,0x57
  056C    00D3    LD	0x53,A
  056D    0008    RET
52:               }
53:               
54:               uint AdcResultChk(uchar adch,uchar adldo)//ADC多次采样
  074D    00DC    LD	0x5C,A
55:               {
56:               	volatile uchar i = 0;
  074E    01DD    CLR	0x5D
57:               	volatile uint ad_value;
58:               	volatile uint ad_value_max;
59:               	volatile uint ad_value_min;
60:               	
61:               	volatile uint ad_temp;
62:               	
63:               	ad_value = AdcOneChk(adch,adldo);
  074F    0859    LD	A,0x59
  0750    00D3    LD	0x53,A
  0751    2541    CALL	0x541
  0752    0854    LD	A,0x54
  0753    00DF    LD	0x5F,A
  0754    0853    LD	A,0x53
  0755    00DE    LD	0x5E,A
64:                   return ad_value;
  0756    085F    LD	A,0x5F
  0757    00DA    LD	0x5A,A
  0758    085E    LD	A,0x5E
  0759    00D9    LD	0x59,A
  075A    0008    RET
65:               	
66:               	// ad_value_max = ad_value;//获取最大值
67:               	// ad_value_min = ad_value;//获取最小值
68:               	// ad_temp = ad_value;
69:               	// for(i = 9;i > 0;i--)
70:               	// {
71:               	// 	ad_value = AdcOneChk(adch,adldo);
72:               	// 	if(ad_value > ad_value_max)
73:               	// 	{
74:               	// 		ad_temp += ad_value_max;
75:               	// 		ad_value_max = ad_value;
76:               	// 	}
77:               	// 	else if(ad_value < ad_value_min)
78:               	// 	{
79:               	// 		ad_temp += ad_value_min;
80:               	// 		ad_value_min = ad_value;
81:               	// 	}
82:               	// 	else
83:               	// 	{
84:               	// 		ad_temp += ad_value;
85:               	// 	}
86:               	// }
87:               
88:               	// ad_temp -= ad_value_max;
89:               	// ad_temp -= ad_value_min;
90:               
91:               	// return (ad_temp>>3);	//平均值
92:               }
93:               
94:               
95:               //bit flag_charge_force_full;
96:               bit flag_charge_force_full_24hour;
97:               unsigned long charge_force_full_cnt;
98:               void app_adc_bat_voltage_check()
99:               {
100:                  ADCON0 = 0b00111101;   //AN15
  0295    303D    LDIA	0x3D
  0296    1283    CLRB	0x3,5
  0297    009F    LD	0x1F,A
101:                  __delay_us(20);		//延时100us 	
  0298    301A    LDIA	0x1A
  0299    1283    CLRB	0x3,5
  029A    00E0    LD	0x60,A
  029B    0BE0    SZDECR	0x60
  029C    2A9B    JP	0x29B
102:                  ADCON1 = 0b00000000;   //VDD
  029D    1683    SETB	0x3,5
  029E    019F    CLR	0x1F
103:                  __delay_us(20);		//延时100us 
  029F    301A    LDIA	0x1A
  02A0    1283    CLRB	0x3,5
  02A1    00E0    LD	0x60,A
  02A2    0BE0    SZDECR	0x60
  02A3    2AA2    JP	0x2A2
  02A4    300F    LDIA	0xF
104:              
105:                  adresultvdd = AdcResultChk(ANVdd,VREFVdd);
  02A5    1283    CLRB	0x3,5
  02A6    01D9    CLR	0x59
  02A7    274D    CALL	0x74D
  02A8    085A    LD	A,0x5A
  02A9    00B7    LD	0x37,A
  02AA    0859    LD	A,0x59
  02AB    00B6    LD	0x36,A
106:                  // BatAdTmp = AdcResultChk(ANVdd,VREFVdd);
107:                  // if(BatAdSumCnt < 32)
108:              	// {
109:              	// 	BatAdSumCnt++;
110:              	// 	BatAdSum += BatAdTmp;
111:              	// }
112:              	// else
113:              	// {
114:              	// 	adresultvdd = BatAdSum >> 5;
115:              		
116:              	// 	BatAdSum = 0;
117:              	// 	BatAdSumCnt = 0;
118:              	// }
119:              
120:                  if(app_charge.Charge)		//充电
  02AC    1683    SETB	0x3,5
  02AD    1C20    SNZB	0x20,0
  02AE    2AC4    JP	0x2C4
121:                  {
122:                      if(adresultvdd < Voltage3V2)      //3.0V  //// / 1.2V/3.0*4096=1638
  02AF    3005    LDIA	0x5
  02B0    1283    CLRB	0x3,5
  02B1    0237    SUBA	0x37
  02B2    30FF    LDIA	0xFF
  02B3    1903    SZB	0x3,2
  02B4    0236    SUBA	0x36
  02B5    1803    SZB	0x3,0
  02B6    2AC2    JP	0x2C2
123:                      {
124:                          CntLowPowerOff++;
  02B7    0AD0    INCR	0x50
125:                          if(CntLowPowerOff > 250)
  02B8    30FB    LDIA	0xFB
  02B9    0250    SUBA	0x50
  02BA    1C03    SNZB	0x3,0
  02BB    0008    RET
126:                          {
127:                              CntLowPowerOff = 0;
  02BC    01D0    CLR	0x50
128:                              app_charge.Remind = 0;
  02BD    1683    SETB	0x3,5
  02BE    1220    CLRB	0x20,4
129:                              app_charge.LowLed = 0;
  02BF    01A7    CLR	0x27
130:                              app_charge.LowPower = 0;
  02C0    01A6    CLR	0x26
  02C1    0008    RET
131:                          }		 
132:                      }
133:                      else
134:                      {
135:                          CntLowPowerOff = 0;
  02C2    01D0    CLR	0x50
  02C3    0008    RET
136:                      }
137:                  }           //用电
138:                  else
139:                  {
140:                      if(adresultvdd > Voltage2V9 - 20)      //3.0V  //// / 1.2V/3.0*4096=1638
  02C4    3006    LDIA	0x6
  02C5    1283    CLRB	0x3,5
  02C6    0237    SUBA	0x37
  02C7    308B    LDIA	0x8B
  02C8    1903    SZB	0x3,2
  02C9    0236    SUBA	0x36
  02CA    1C03    SNZB	0x3,0
  02CB    2AE2    JP	0x2E2
141:                      {
142:                          CntLowPowerOff++;
  02CC    0AD0    INCR	0x50
143:                          if(CntLowPowerOff > 100)
  02CD    3065    LDIA	0x65
  02CE    0250    SUBA	0x50
  02CF    1C03    SNZB	0x3,0
  02D0    2AE3    JP	0x2E3
144:                          {
145:                              CntLowPowerOff = 0;
  02D1    01D0    CLR	0x50
146:                              app_charge.Remind = FLASE;
  02D2    1683    SETB	0x3,5
  02D3    1220    CLRB	0x20,4
147:              
148:                              if (!app_charge.LowPower)
  02D4    0826    LD	A,0x26
  02D5    1D03    SNZB	0x3,2
  02D6    2AE3    JP	0x2E3
149:                              {
150:                                  app_process_set_work_state(WORK_STATE_POWEROFF);
  02D7    3000    LDIA	0x0
  02D8    27BE    CALL	0x7BE
151:                                  app_process_set_water_state(WATER_WORK_STATE_POWEROFF);
  02D9    3000    LDIA	0x0
  02DA    27C3    CALL	0x7C3
152:                                  app_charge.LowPower = 1;
  02DB    1683    SETB	0x3,5
  02DC    01A6    CLR	0x26
  02DD    0AA6    INCR	0x26
153:                                  app_charge.LowLed = TURE;
  02DE    01A7    CLR	0x27
  02DF    0AA7    INCR	0x27
154:                                  app_charge.LowLed_cnt = 0;
  02E0    01A8    CLR	0x28
  02E1    2AE3    JP	0x2E3
155:                              }
156:                          }		 
157:                      }
158:                      else
159:                      {
160:                          CntLowPowerOff = 0;
  02E2    01D0    CLR	0x50
161:                      }
162:              
163:                      if(adresultvdd > Voltage3V4 -15)
  02E3    3005    LDIA	0x5
  02E4    1283    CLRB	0x3,5
  02E5    0237    SUBA	0x37
  02E6    3097    LDIA	0x97
  02E7    1903    SZB	0x3,2
  02E8    0236    SUBA	0x36
  02E9    1C03    SNZB	0x3,0
  02EA    2AF4    JP	0x2F4
  02EB    3065    LDIA	0x65
164:                      {
165:                          bat_remind_delay++;
  02EC    0ACE    INCR	0x4E
166:                          if(bat_remind_delay > 100)
  02ED    024E    SUBA	0x4E
  02EE    1C03    SNZB	0x3,0
  02EF    0008    RET
167:                          {
168:                              bat_remind_delay = 0;
  02F0    01CE    CLR	0x4E
169:                              app_charge.Remind = 1;
  02F1    1683    SETB	0x3,5
  02F2    1620    SETB	0x20,4
  02F3    0008    RET
170:                          }
171:                      }
172:                      else
173:                      {
174:                          bat_remind_delay = 0;
  02F4    01CE    CLR	0x4E
  02F5    0008    RET
175:                      }
176:                      
177:                  }
178:              }		
179:              
180:              void MotorAdcIChk(void)
181:              {
182:                  // if (app_work_state == WORK_STATE_WORKING)
183:                  // {
184:                      adresultmotor = AdcResultChk(ANI_DET,VREF2_0V);
185:                      {
186:                          if(adresultmotor > MOTORIOVER)
187:                          {
188:                              if(motor_lock_cnt <= MS(200))
189:                              {
190:                                  motor_lock_cnt++;
191:                              }
192:                              else
193:                              {
194:                                  app_process_set_work_state(WORK_STATE_POWEROFF);
195:                              }
196:                          }
197:                          else
198:                          {
199:                              motor_lock_cnt = 0;
200:                              // if(motor_lock_cnt > 20)
201:                              // {
202:                              // 	motor_lock_cnt--;
203:                              // }
204:                              // 	else
205:                              // 	{
206:                              // 		motor_lock_cnt = 0;
207:                              // 	}
208:                          }
209:                      }
210:                  // }
211:              }
212:              
213:              void app_adc_process()
214:              {
215:                  //MotorAdcIChk();
216:                  app_adc_bat_voltage_check();
  07CE    2A95    JP	0x295
217:              }
218:              
219:              
220:              
221:              
222:              
223:              
224:              
225:              
226:              
227:              
228:              
229:              
230:              
231:              
232:              
233:              
234:              
235:              
236:              
237:              
238:              
239:              
240:              
241:              
242:              // volatile unsigned int adresultmotor;
243:              // volatile unsigned int adresultvdd;
244:              // volatile unsigned long adsum;
245:              // volatile unsigned int admin,admax;
246:              // volatile unsigned char adtimes;
247:              
248:              // volatile unsigned char BatStates = 4;
249:              
250:              // volatile unsigned char CntLowPowerOff;
251:              
252:              
253:              // volatile unsigned char BatAdcCnt;
254:              
255:              
256:              // unsigned char CntOverCurrent;
257:              // volatile unsigned char Mode2ADCDelay;
258:              
259:              // bool FlagAdcSwitch;
260:              // bool FlagAdcVddOver;
261:              // bool FlagAdcMotorOver;
262:              
263:              
264:              // bool FlagCharge = 0;
265:              // bool FlagAdcSwitch=0;
266:              // bool FlagAdcMotorOver;
267:              // bool FlagAdcVddOver;
268:              // bool FlagLowPower;
269:              // bool FlagFullCharge;
270:              // bool FlagLowLed = 0;;
271:              
272:              
273:              // void AdcChkVdd()
274:              // {
275:              // 	volatile unsigned int ad_temp;	
276:              
277:              // 	GODONE = 1;						//开始转换
278:              
279:              // 	unsigned char i = 0;
280:              // 	while(GODONE)
281:              // 	{
282:              // 		if(0 == (--i))
283:              // 		return;
284:              // 	}
285:              // 	ad_temp=ADRESH;
286:              // 	ad_temp= (ad_temp<<4);
287:              // 	ad_temp +=(ADRESL>>4);	//计算12位AD值
288:              	
289:              // 	if(0 == admax)
290:              // 	{
291:              // 		admax = ad_temp;
292:              // 		admin = ad_temp;
293:              // 	}
294:              // 	else if(ad_temp > admax)
295:              // 		admax = ad_temp;				//AD采样最大值
296:              // 	else if(ad_temp < admin)
297:              // 		admin = ad_temp;				//AD采样最小值
298:              	
299:              // 	adsum += ad_temp;
300:              // 	//Flag10ms_Adc=1;
301:              // 	if(++adtimes >= 10)
302:              // 	{
303:              // 		adsum -= admax;
304:              // 		if(adsum >= admin)	adsum -= admin;
305:              // 		else	adsum = 0;
306:              // 		if(FlagAdcSwitch==0)
307:              // 		{
308:              // 			adresultvdd = (unsigned int)(adsum >> 3);		//8次平均值作为最终结果	
309:              // 			FlagAdcVddOver=TURE;
310:              // 			ADCON0 = 0b00000001;   //AN0
311:              // 			ADCON1 = 0b00000101;   //2.0V
312:              // 			//需要转换ADC始终频率
313:              // 				// ADCON0 = 0xc0;  //改变时钟分频，//转换通道检测AN0， 1100 0001
314:              // 				// LDOEN = 1;       //设置参考电压LDO
315:              // 			FlagAdcSwitch=1;		  
316:              // 		}
317:              // 		else
318:              // 		{
319:              // 			adresultmotor = (unsigned int)(adsum >> 3);		//8次平均值作为最终结果	
320:              // 			FlagAdcMotorOver=TURE;
321:              // 			ADCON0 = 0b00111101;   //AN15
322:              //           	ADCON1 = 0b00000000;   //VDD
323:              // 			//需要转换ADC始终频率
324:              // 			// ADCON0 = 0x7d;  //改变时钟分频，//转换通道检测基准电压 0111 1101
325:              // 			// LDOEN = 0;       //设置参考电压VDD
326:              // 		  	FlagAdcSwitch=0;		  
327:              // 		}										
328:              // 		adsum = 0;
329:              // 		admin = 0;
330:              // 		admax = 0;
331:              // 		adtimes = 0;
332:              // 	}
333:              // }
334:              
335:              // bool get_bat_low_state()
336:              // {
337:              //     return FlagLowLed;
338:              // }
339:              // void clear_bat_low_state()
340:              // {
341:              //     FlagLowLed = FLASE;
342:              // }
343:              
344:              // void voltage_check()  //低压检测
345:              // {
346:              // 	if(FlagAdcVddOver==TURE)
347:              //     {
348:              // 		FlagAdcVddOver=FLASE;
349:              	   
350:              // 		if(FlagCharge)		//充电
351:              // 		{
352:              // 			// if(adresultvdd < Voltage3V3)      //3.0V  //// / 1.2V/3.0*4096=1638
353:              // 			// {
354:              // 			// 	CntLowPowerOff++;
355:              // 			// 	if(CntLowPowerOff > 2)
356:              // 			// 	{
357:              // 			// 		CntLowPowerOff = 0;
358:              // 			// 		//if(!FlagLowPower)
359:              // 			// 		//{
360:              // 			// 			//	FlagLowLed = 1;
361:              // 			// 		//}
362:              // 			// 		FlagLowPower = FLASE;
363:              					
364:              // 			// 		//BatStates = 1;
365:              // 			// 	}		 
366:              // 			// }
367:              // 			// else
368:              // 			// {
369:              // 			// 	CntLowPowerOff = 0;
370:              // 			// }
371:              			
372:              // 			if(BatStates == 1)
373:              // 			{
374:              // 				if(adresultvdd < Voltage3V4)  
375:              // 				{
376:              // 					BatAdcCnt++;
377:              // 					if(BatAdcCnt > 2)
378:              // 					{
379:              // 						BatAdcCnt = 0;
380:              // 						BatStates = 2; //大于3.3V
381:              
382:              // 						if(!FlagLowPower)
383:              // 						//{
384:              // 							//	FlagLowLed = 1;
385:              // 						//}
386:              // 						FlagLowPower = FLASE;
387:              // 						FlagLowLed = FLASE;
388:              // 						//BatStates = 1;
389:              // 					}
390:              // 				}
391:              // 				else
392:              // 				{
393:              // 					BatAdcCnt = 0;
394:              // 				}
395:              // 			}
396:              // 			else if(BatStates == 2)
397:              // 			{
398:              // 				if(adresultvdd < Voltage3V7)	
399:              // 				{
400:              // 					BatAdcCnt++;
401:              // 					if(BatAdcCnt > 2)
402:              // 					{
403:              // 						BatAdcCnt = 0;
404:              // 						BatStates = 3;	//大于3.7V
405:              // 					}
406:              // 				}
407:              // 				else
408:              // 				{
409:              // 					BatAdcCnt = 0;
410:              // 				}
411:              // 			}
412:              // 			else if(BatStates == 3)
413:              // 			{
414:              // 				if(adresultvdd < Voltage3V9)
415:              // 				{
416:              // 					BatAdcCnt++;
417:              // 					if(BatAdcCnt > 2)
418:              // 					{
419:              // 						BatAdcCnt = 0;
420:              // 						BatStates = 4;	//大于3.9V
421:              // 					}
422:              // 				}
423:              // 				else
424:              // 				{
425:              // 					BatAdcCnt = 0;
426:              // 				}
427:              // 			}
428:              // 		}
429:              // 		else    //用电
430:              // 		{
431:              // 			if(adresultvdd > Voltage3V0)      //3.0V  //// / 1.2V/3.0*4096=1638
432:              // 			{
433:              // 				CntLowPowerOff++;
434:              // 				if(CntLowPowerOff > 2)
435:              // 				{
436:              // 					CntLowPowerOff = 0;
437:              // 					if(!FlagLowPower)
438:              // 					{
439:              // 						FlagLowLed = TURE;
440:              
441:              // 						// led_deinit();
442:              // 						// motor_PwmOut(0);
443:              // 						// CntLedFlash = 0;
444:              // 						set_work_state(WORK_STATE_LOWBAT_LED);
445:              // 					}
446:              // 					FlagLowPower = TURE;
447:              // 					BatStates = 1;
448:              // 					set_work_state(WORK_STATE_POWEROFF);
449:              // 					// if(!FlagLowPower)
450:              // 					// {
451:              // 					// 	FlagLowLed = TURE;
452:              
453:              // 					// 	// led_deinit();
454:              // 					// 	// motor_PwmOut(0);
455:              // 					// 	// CntLedFlash = 0;
456:              // 					// 	// set_work_state(WORK_STATE_LOWBAT_LED);
457:              // 					// }
458:              // 					// FlagLowPower = TURE;
459:              					
460:              // 				}		 
461:              // 			}
462:              // 			else
463:              // 			{
464:              // 				CntLowPowerOff = 0;
465:              // 			}
466:              			
467:              // 			if(BatStates == 4)		         //3.9~4.2V
468:              // 			{
469:              // 				if(adresultvdd > Voltage3V9)  
470:              // 				{
471:              // 					BatAdcCnt++;
472:              // 					if(BatAdcCnt > 2)
473:              // 					{
474:              // 						BatAdcCnt = 0;
475:              // 						BatStates = 3; 
476:              // 					}
477:              // 				}
478:              // 				else
479:              // 				{
480:              // 					BatAdcCnt = 0;
481:              // 				}
482:              // 			}
483:              // 			else if(BatStates == 3)			//3.6~3.9V
484:              // 			{
485:              // 				if(adresultvdd > Voltage3V6)
486:              // 				{
487:              // 					BatAdcCnt++;
488:              // 					if(BatAdcCnt > 2)
489:              // 					{
490:              // 						BatAdcCnt = 0;
491:              // 						BatStates = 2;
492:              // 					}
493:              // 				}
494:              // 				else
495:              // 				{
496:              // 					BatAdcCnt = 0;
497:              // 				}
498:              // 			}
499:              // 			else if(BatStates == 2)			//3.3~3.6V
500:              // 			{
501:              // 				if(adresultvdd > Voltage3V3)
502:              // 				{
503:              // 					BatAdcCnt++;
504:              // 					if(BatAdcCnt > 2)
505:              // 					{
506:              // 						BatAdcCnt = 0;
507:              // 						BatStates = 1;     //小于3.3V
508:              
509:              // 						// if(!FlagLowPower)
510:              // 						// {
511:              // 						// 	FlagLowLed = TURE;
512:              
513:              // 						// 	// led_deinit();
514:              // 						// 	// motor_PwmOut(0);
515:              // 						// 	// CntLedFlash = 0;
516:              // 						// 	set_work_state(WORK_STATE_LOWBAT_LED);
517:              // 						// }
518:              // 						// FlagLowPower = TURE;
519:              // 						// BatStates = 1;
520:              // 					}
521:              // 				}
522:              // 				else
523:              // 				{
524:              // 					BatAdcCnt = 0;
525:              // 				}
526:              // 			}
527:              // 			// else if(BatStates == 1)			//已经小于3.0
528:              // 			// {
529:              // 			// 	if(adresultvdd > Voltage3V0)
530:              // 			// 	{
531:              // 			// 		BatAdcCnt++;
532:              // 			// 		if(BatAdcCnt > 2)
533:              // 			// 		{
534:              // 			// 			BatAdcCnt = 0;
535:              
536:              // 			// 			if(!FlagLowPower)
537:              // 			// 			{
538:              // 			// 				FlagLowLed = TURE;
539:              
540:              // 			// 				// led_deinit();
541:              // 			// 				// motor_PwmOut(0);
542:              // 			// 				// CntLedFlash = 0;
543:              // 			// 				set_work_state(WORK_STATE_LOWBAT_LED);
544:              // 			// 			}
545:              // 			// 			FlagLowPower = TURE;
546:              // 			// 			BatStates = 1;
547:              // 			// 		}
548:              // 			// 	}
549:              // 			// 	else
550:              // 			// 	{
551:              // 			// 		BatAdcCnt = 0;
552:              // 			// 	}
553:              // 			// }
554:              // 		}
555:              // 	}		
556:              // }
557:              
558:              
559:              // void MotorOverCurrentProtect() //电压过大保护
560:              // {
561:              // //   if(States==2)
562:              // //   {
563:              // 	if(FlagAdcMotorOver)
564:              // 	{
565:              // 		FlagAdcMotorOver=FLASE;
566:              // 		if(adresultmotor>ProtectSet) //电压  todo...
567:              // 		{
568:              // 			if (ModeDuty)
569:              // 			{
570:              // 				Mode2ADCDelay++;
571:              // 				if (Mode2ADCDelay >= 1)
572:              // 				{
573:              // 					Mode2ADCDelay = 0;
574:              // 					CntOverCurrent++;
575:              // 				}
576:              // 			} 
577:              // 			else
578:              // 			{
579:              
580:              // 			}
581:              				
582:              // 			if(CntOverCurrent>2)
583:              // 			{
584:              // 				CntOverCurrent=0; 
585:              // 				set_work_state(WORK_STATE_POWEROFF);
586:              // 			}				
587:              // 	  	}
588:              // 		else
589:              // 		{
590:              // 			//CntOverCurrent=0;			
591:              // 		}			
592:              // 	}	
593:              //   //}	
594:              // }
595:              
596:              // void process_adc_check()
597:              // {
598:              // 	AdcChkVdd();
599:              // 	voltage_check();
600:              // 	MotorOverCurrentProtect();
601:              // }
602:              
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280A    JP	0xA
  000A    280B    JP	0xB
---- start_initialization ------------------------------------------------------------------
  000B    3003    LDIA	0x3
  000C    00E1    LD	0x61,A
  000D    3002    LDIA	0x2
  000E    01E2    CLR	0x62
  000F    01E3    CLR	0x63
  0010    01E4    CLR	0x64
  0011    01E5    CLR	0x65
  0012    00E6    LD	0x66,A
  0013    3005    LDIA	0x5
  0014    01E7    CLR	0x67
  0015    01E8    CLR	0x68
  0016    01E9    CLR	0x69
  0017    01EA    CLR	0x6A
  0018    00EB    LD	0x6B,A
  0019    30A0    LDIA	0xA0
  001A    1383    CLRB	0x3,7
  001B    0084    LD	0x4,A
  001C    30D7    LDIA	0xD7
  001D    278D    CALL	0x78D
  001E    3020    LDIA	0x20
  001F    0084    LD	0x4,A
  0020    3053    LDIA	0x53
  0021    278D    CALL	0x78D
  0022    01FB    CLR	0x7B
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F9    LD	0x79,A
  0007    080A    LD	A,0xA
  0008    00FA    LD	0x7A,A
  0009    2C4D    JP	0x44D
---- common_function ------------------------------------------------------------------
  0023    0183    CLR	0x3
  0024    2E35    JP	0x635
  0025    00FF    LD	0x7F,A
  0026    3000    LDIA	0x0
  0027    008A    LD	0xA,A
  0028    087F    LD	A,0x7F
  0029    0782    ADDR	0x2
  002A    282A    JP	0x2A
  002B    2F84    JP	0x784
  002C    2F3F    JP	0x73F
  002D    2C87    JP	0x487
  012E    101B    CLRB	0x1B,0
  012F    1683    SETB	0x3,5
  0130    1186    CLRB	0x6,3
  0131    1283    CLRB	0x3,5
  0132    1186    CLRB	0x6,3
  0133    0008    RET
  0134    1283    CLRB	0x3,5
  0135    01D3    CLR	0x53
  0136    00D4    LD	0x54,A
  0137    01D5    CLR	0x55
  0138    0008    RET
  022C    3002    LDIA	0x2
  022D    1283    CLRB	0x3,5
  022E    01D3    CLR	0x53
  022F    00D4    LD	0x54,A
  0230    01D5    CLR	0x55
  0231    0008    RET
  0290    1283    CLRB	0x3,5
  0291    1505    SETB	0x5,2
  0292    1683    SETB	0x3,5
  0293    1105    CLRB	0x5,2
  0294    0008    RET
  0448    00D3    LD	0x53,A
  0449    01D4    CLR	0x54
  044A    01D5    CLR	0x55
  044B    0AD5    INCR	0x55
  044C    0008    RET
  04B2    01A2    CLR	0x22
  04B3    0AA2    INCR	0x22
  04B4    01A3    CLR	0x23
  04B5    01A4    CLR	0x24
  04B6    0008    RET
  06BF    1283    CLRB	0x3,5
  06C0    01CC    CLR	0x4C
  06C1    01CB    CLR	0x4B
  06C2    01CA    CLR	0x4A
  06C3    0008    RET
  078D    0064    CLRWDT
  078E    0180    CLR	0x0
  078F    0A84    INCR	0x4
  0790    0604    XORA	0x4
  0791    1903    SZB	0x3,2
  0792    3400    RET	0x0
  0793    0604    XORA	0x4
  0794    2F8E    JP	0x78E
  07C8    2F3D    JP	0x73D
  07C9    2F3C    JP	0x73C
  07CA    2F3B    JP	0x73B
  07CB    2F3E    JP	0x73E
